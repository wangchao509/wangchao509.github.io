<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL章节0 | whc的学习笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="主要是java技术类笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.44acb28c.css" as="style"><link rel="preload" href="/docs/assets/js/app.54a4cdcf.js" as="script"><link rel="preload" href="/docs/assets/js/5.7c82c2c2.js" as="script"><link rel="preload" href="/docs/assets/js/3.02c95c72.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.e67adc99.js"><link rel="prefetch" href="/docs/assets/js/11.8b744868.js"><link rel="prefetch" href="/docs/assets/js/12.eea5766e.js"><link rel="prefetch" href="/docs/assets/js/2.9151ef46.js"><link rel="prefetch" href="/docs/assets/js/4.3820cc2f.js"><link rel="prefetch" href="/docs/assets/js/6.5f18c9d2.js"><link rel="prefetch" href="/docs/assets/js/7.0d5780ef.js"><link rel="prefetch" href="/docs/assets/js/8.5d0d470d.js"><link rel="prefetch" href="/docs/assets/js/9.c80a059c.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.44acb28c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">whc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">站点介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>markdown知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/markdown.html" class="sidebar-link">前端知识介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MySQL知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/mysql0.html" aria-current="page" class="active sidebar-link">MySQL章节0</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/mysql0.html#生产的数据库要交给dba去弄" class="sidebar-link">生产的数据库要交给DBA去弄</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#虚拟机上安装mysql" class="sidebar-link">虚拟机上安装mysql</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#配置mysql" class="sidebar-link">配置MySQL</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#简单的jdbc连接" class="sidebar-link">简单的jdbc连接</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#远程登录报错" class="sidebar-link">远程登录报错</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#什么是mysql驱动" class="sidebar-link">什么是mysql驱动</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#数据库连接池的作用" class="sidebar-link">数据库连接池的作用</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#mysql基础知识" class="sidebar-link">MySQL基础知识</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#初步了解innodb存储引擎的架构设计" class="sidebar-link">初步了解InnoDB存储引擎的架构设计</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#mysql-binlog" class="sidebar-link">MySQL binlog</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#基于binlog和redo-log完成事务的提交" class="sidebar-link">基于binlog和redo log完成事务的提交</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#后台io线程随机将内存中更新后的脏数据刷回到磁盘" class="sidebar-link">后台IO线程随机将内存中更新后的脏数据刷回到磁盘</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#基于更新数据的流程-总结一下innodb存储引擎的架构原理" class="sidebar-link">基于更新数据的流程，总结一下InnoDB存储引擎的架构原理</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#生产环境数据库配置" class="sidebar-link">生产环境数据库配置</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#buffer-pool的地位" class="sidebar-link">Buffer Pool的地位</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#预读机制" class="sidebar-link">预读机制</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#lru链表冷数据区域和flush链表数据刷入磁盘的三个时机" class="sidebar-link">LRU链表冷数据区域和Flush链表数据刷入磁盘的三个时机</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#如何通过多个buffer-pool来优化数据库的性能" class="sidebar-link">如何通过多个Buffer Pool来优化数据库的性能</a></li><li class="sidebar-sub-header"><a href="/docs/mysql0.html#数据库压测" class="sidebar-link">数据库压测</a></li></ul></li><li><a href="/docs/mysql.html" class="sidebar-link">MySQL章节1</a></li><li><a href="/docs/mysql2.html" class="sidebar-link">MySQL章节2</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JAVA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/thread.html" class="sidebar-link">多线程知识</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql章节0"><a href="#mysql章节0" class="header-anchor">#</a> MySQL章节0</h1> <h2 id="生产的数据库要交给dba去弄"><a href="#生产的数据库要交给dba去弄" class="header-anchor">#</a> 生产的数据库要交给DBA去弄</h2> <p><img src="/docs/assets/img/dba_install_db.983e9ebe.png" alt="安装数据库" title="dba_install_db.png"></p> <h2 id="虚拟机上安装mysql"><a href="#虚拟机上安装mysql" class="header-anchor">#</a> 虚拟机上安装mysql</h2> <p>可以照着如下链接来安装（亲试可行）：<br>
https://blog.csdn.net/qq_36582604/article/details/80526287</p> <h3 id="下载并安装mysql官方的-yum-repository"><a href="#下载并安装mysql官方的-yum-repository" class="header-anchor">#</a> 下载并安装MySQL官方的 Yum Repository</h3> <blockquote><p>wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</p></blockquote> <p>使用上面的命令就直接下载了安装用的Yum Repository,然后安装它：</p> <blockquote><p>yum -y install mysql57-community-release-el7-10.noarch.rpm</p></blockquote> <h3 id="开始安装mysql服务器"><a href="#开始安装mysql服务器" class="header-anchor">#</a> 开始安装MySQL服务器</h3> <blockquote><p>yum -y install mysql-community-server</p></blockquote> <p>至此MySQL就安装完成了，然后是对MySQL的一些设置。<br>
find / -name mysql -print  找不到安装目录可以用该命令搜索。<br>
data默认放在：/var/lib/mysql</p> <p><font color="FF0000" size="4">mysql默认安装位置：/usr/share/mysql</font></p> <h3 id="配置环境变量"><a href="#配置环境变量" class="header-anchor">#</a> 配置环境变量</h3> <blockquote><p>export LD_LIBRARY_PATH=/usr/share/mysql</p></blockquote> <h3 id="安装mysql-devel"><a href="#安装mysql-devel" class="header-anchor">#</a> 安装mysql-devel</h3> <p>安装mysql-devel，才能使用mysql_config</p> <blockquote><p>yum install -y mysql-devel</p></blockquote> <h2 id="配置mysql"><a href="#配置mysql" class="header-anchor">#</a> 配置MySQL</h2> <p><strong>启动MySQL</strong></p> <blockquote><p>systemctl start mysqld.service</p></blockquote> <p><strong>查看mysql的运行状态</strong></p> <blockquote><p>systemctl status mysqld.service</p></blockquote> <p><strong>找出root用户的密码</strong></p> <blockquote><p>grep &quot;password&quot; /var/log/mysqld.log</p></blockquote> <p><img src="data:image/png;base64,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" alt="mysql密码" title="mysql_password.png"></p> <p><strong>客户端登录数据库</strong></p> <blockquote><p>mysql -uroot -p</p></blockquote> <p>输入初始密码（是上面图片最后面的xsOf=nB7)1p），此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：</p> <p><strong>修改密码</strong></p> <blockquote><p>ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';</p></blockquote> <p>其中‘new password’替换成你要设置的密码，注意:密码设置必须要大小写字母数字和特殊符号（,/';:等）,不然不能配置成功.<br> <font color="FF0000" size="4">我自己的数据库密码：Whc@1987</font></p> <p><strong>先登录进去，然后再修改密码的方案</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1,vi /etc/my.cnf  
2,在[mysqld]后面加入一行，内容如下：skip-grant-tables 
3,直接登录mysql，不需要输入密码。命令如下：mysql -uroot -p ，然后直接回车，不输入密码，回车。   
4,flush privileges;  
5,set password for root@localhost=password('123456');
6,flush privileges;  
此时修改密码成功了。然后就要注释掉skip-grant-tables，并重启mysql，重启命令:service mysqld restart
7,重新登录：mysql -uroot -p123456
</code></pre></div><p><img src="/docs/assets/img/mysql_modify1.90498c70.png" alt="mysql修改密码" title="mysql_modify1.png"></p> <p><strong>开启mysql的远程访问</strong><br>
执行以下命令开启远程访问限制（注意：下面命令开启的IP是 192.168.0.1，如要开启所有的，用%代替IP）</p> <blockquote><p>grant all privileges on <em>.</em> to 'root'@'%' identified by 'Whc@1987' with grant option;<br>
然后再输入下面两行命令<br>
flush privileges;<br>
exit;</p></blockquote> <p><strong>为firewalld添加开放端口</strong><br>
其实可以直接关闭防火墙，如果不想关闭，就要开放如下两个端口，这样别的机器就可以远程访问数据库了。</p> <blockquote><p>添加mysql端口3306和Tomcat端口8080<br>
firewall-cmd --zone=public --add-port=3306/tcp --permanent<br>
firewall-cmd --zone=public --add-port=8080/tcp --permanent<br>
重启防火墙<br>
firewall-cmd --reload</p></blockquote> <p><strong>更改mysql的语言</strong><br>
首先重新登录mysql，然后输入status：<br> <img src="/docs/assets/img/mysql_status.ab6e76d2.png" alt="查看mysql状态" title="mysql_status.png"></p> <p>可以看到，绿色箭头处（Server characterset:    latin1）不是utf-8<br>
因此我们先退出mysql，然后再到、etc目录下的my.cnf文件下修改一下文件内容</p> <p><img src="data:image/png;base64,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" alt="mysql的配置文件my.cnf" title="mysql_language_set.png"></p> <p>在/etc/my.cnf中新增如图的四行代码：</p> <blockquote><p>[client]<br>
default-character-set=utf8<br>
character-set-server=utf8<br>
collation-server=utf8_general_ci</p></blockquote> <p>保存更改后的my.cnf文件后，重启下mysql，然后输入status再次查看，你就会发现变化啦</p> <p><img src="/docs/assets/img/mysql_language_set2.282f2ffd.png" alt="mysql的配置文件my.cnf" title="mysql_language_set2.png"></p> <p><strong>重启MySQL</strong></p> <blockquote><p>service mysqld restart</p></blockquote> <p>登录mysql客户端，输入status命令，查看MySQL状态，发现语言已经修改成功<br> <img src="/docs/assets/img/mysql_language_set3.524f376a.png" alt="mysql的配置文件my.cnf" title="mysql_language_set3.png"></p> <p>最后，到Windows下用cmd命令启动mysql啦(前面把密码改成了Whc@1987)！！</p> <blockquote><p>mysql -h 192.168.37.128 -P 3306 -u root -p</p></blockquote> <p><img src="/docs/assets/img/mysql_language_set4.59d64f39.png" alt="mysql的配置文件my.cnf" title="mysql_language_set4.png"></p> <h2 id="简单的jdbc连接"><a href="#简单的jdbc连接" class="header-anchor">#</a> 简单的jdbc连接</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> url<span class="token operator">=</span><span class="token string">&quot;jdbc:mysql://192.168.37.1:3308/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> user <span class="token operator">=</span> <span class="token string">&quot;root&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> password <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="远程登录报错"><a href="#远程登录报错" class="header-anchor">#</a> 远程登录报错</h2> <p><strong>报错信息：</strong>&quot;Host 'lchdevwangc' is not allowed to connect to this MySQL server&quot;<br> <strong>解决方案：</strong><br>
在navicat的查询窗口（下图最右侧的加号按钮）执行如下命令：</p> <blockquote><p>grant all PRIVILEGES on nacos.* to 'root'@'192.168.37.1' identified by '123456' WITH GRANT OPTION;<br>
flush privileges;</p></blockquote> <p>nacos指的是数据库的名字，root指的是访问数据库的用户的用户名（不是计算机名）<br> <strong>执行后在下图中可以看到授权信息</strong><br> <img src="/docs/assets/img/mysql_privilege1.3dadf22d.png" alt="navicat 给mysql授权" title="mysql_privilege1.png"></p> <p>一般用上面的命令就可以搞定权限问题，但是我们可以<strong>查看nacos数据库对哪些ip放开了权限</strong>，如下图：<br> <img src="/docs/assets/img/mysql_privilege2.889ab93e.png" alt="navicat 给mysql授权" title="mysql_privilege2.png"><br> <img src="/docs/assets/img/mysql_privilege3.60de2e7e.png" alt="navicat 给mysql授权" title="mysql_privilege3.png"></p> <h2 id="什么是mysql驱动"><a href="#什么是mysql驱动" class="header-anchor">#</a> 什么是mysql驱动</h2> <p>这段maven配置就引入了一个MySql驱动，mysql-connector-java是面向java语言的mysql驱动。</p> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><strong>MySQL驱动负责跟数据库建立网络连接</strong></p> <h2 id="数据库连接池的作用"><a href="#数据库连接池的作用" class="header-anchor">#</a> 数据库连接池的作用</h2> <p>频繁的创建连接和销毁连接会导致数据库的性能较低，加入数据库连接池后，连接用完并不销毁，而是重新放入数据库连接池。<br>
常见的数据库连接池有：DBCP、C3P0，Druid。</p> <p><font color="FFD700" size="4">我们的系统采用数据库连接池的方式去并发访问数据库，然后数据库自己其实也会维护一个连接池，其中管理了各种系统跟这台数据库服务器建立的所有连接</font></p> <p><img src="/docs/assets/img/tomcat2mysql.8ce18130.png" alt="数据库连接池" title="tomcat2mysql.png"></p> <h2 id="mysql基础知识"><a href="#mysql基础知识" class="header-anchor">#</a> MySQL基础知识</h2> <h4 id="网络连接必须让线程来处理"><a href="#网络连接必须让线程来处理" class="header-anchor">#</a> 网络连接必须让线程来处理</h4> <p>现在假设我们的数据库服务器连接池中的某个连接收到了网络请求，假设就是一条SQL语句，那么大家先思考一个问题，谁负责从这个连接中去监听网络请求？谁负责从网络连接里把请求数据读取出来？</p> <p>我想很多人恐怕没思考过这个问题，但是如果大家对计算机基础知识有一个简单了解的话，应该或多或少知道一点，那就是网络连接必须得分配给一个线程去进行处理，由一个线程负责监听请求和读取请求数据，比如从网络连接中读取和解析出来一条我们的系统发送过去的SQL语句，如下图所示：<br> <img src="/docs/assets/img/tomcat2mysql2.9e89bf7b.png" alt="数据库连接池" title="tomcat2mysql2.png"></p> <h4 id="sql接口-负责处理接收到的sql语句"><a href="#sql接口-负责处理接收到的sql语句" class="header-anchor">#</a> SQL接口：负责处理接收到的sql语句</h4> <p>思考一个问题，当mysql内部的工作线程从一个网络连接中读取出来一个SQL语句后，此时会如何执行这个SQL语句呢？<br>
MySQL内部提供了一个组件，就是SQL接口（SQL interface），他是一套执行SQL语句的接口，专门用来执行我们发送给MySQL的增删改查的SQL语句。</p> <p><img src="/docs/assets/img/tomcat2mysql3.5a30c76e.png" alt="数据库连接池之SQL接口" title="tomcat2mysql3.png"></p> <h4 id="_3-查询解析器-让mysql能看懂sql语句"><a href="#_3-查询解析器-让mysql能看懂sql语句" class="header-anchor">#</a> 3）查询解析器：让MySQL能看懂SQL语句</h4> <p>假设有一个sql语句：Select id,name,age from users where id =1<br>
MySQL是看不懂这个SQL的，需要借助<strong>查询解析器</strong><br>
这个查询解析器（Parser）就是负责对SQL语句进行解析的，比如对上面那个SQL语句进行一下拆解，拆解成以下几个部分：<br>
1.我们现在要从“users”表查询数据<br>
2.查询“id”字段的值等于1的那行数据<br>
3.对查出来的那行数据要提取里面的“id，name，age”三个字段<br> <img src="/docs/assets/img/tomcat2mysql4.1351ff40.png" alt="数据库连接池之查询解析器" title="tomcat2mysql4.png"></p> <h4 id="查询优化器-选择最优的查询路径"><a href="#查询优化器-选择最优的查询路径" class="header-anchor">#</a> 查询优化器：选择最优的查询路径</h4> <p><font color="FF0000" size="3">查询优化器（Optimizer）作用是：选择一个最优的查询路径。</font></p> <p>举个例子（纯属用于理解的例子，不代表真是的MySQL原理）<br>
1， 直接定位到users表中的id=1的一行数据，然后查询出这行数据的“id，name，age”三个字段的值就可以了。<br>
2， 先把users表中的每一行数据的“id，name，age”三个字段的值都查询出来，然后从这批数据里过滤出来id=1的那行数据即可。</p> <p>上面就是一个最简单的SQL语句的两种实现路径，其实我们会发现，要完成这个SQL语句的目标，两个路径都可以做到，但是哪一种更好呢？显然感觉第一种查询路径更好一些。</p> <p>所以查询优化器大概是干这个的，他会针对你的sql语句生成查询路径，然后选择一个最优的查询路径。相当于他会告诉你，你应该按照一个什么样的步骤和顺序，去执行哪些操作，然后一步一步的把SQL语句给完成了。<br> <img src="/docs/assets/img/tomcat2mysql5.ac8c75f6.png" alt="数据库连接池之查询优化器" title="tomcat2mysql5.png"></p> <h4 id="调用存储引擎接口-真正执行sql语句"><a href="#调用存储引擎接口-真正执行sql语句" class="header-anchor">#</a> 调用存储引擎接口，真正执行SQL语句</h4> <p>最后一步，就是把查询优化器选择的最优查询路径，也就是你到底应该按照一个什么样的顺序和步骤去执行这个SQL语句计划的，把这个计划交给底层的存储引擎去真正的执行。<br> <img src="/docs/assets/img/tomcat2mysql6.94a10751.png" alt="数据库连接池之存储引擎" title="tomcat2mysql6.png"></p> <p>那么问题来了，我们已经知道一个SQL语句要如何执行了，但是我们现在怎么知道哪些数据在内存里？哪些数据在磁盘里呢？我们执行的时候是更新内存的数据还是更新磁盘的数据？我们如果更新磁盘的数据，先查询哪个磁盘文件，再更新哪个磁盘文件？</p> <p>这个就需要存储引擎了。<br> <img src="/docs/assets/img/tomcat2mysql7.315ce011.png" alt="数据库连接池之查询解析器" title="tomcat2mysql7.png"></p> <p>MySQL的架构设计中，SQL接口、SQL解析器、查询优化器其实都是通用的，他就是一套组件而已。<br>
但是存储引擎的话，有很多种，比如我们常见的InnoDB、MyISAM、Memory等等。<strong>不过一般MySQL默认使用InnoDB引擎</strong>。</p> <h4 id="执行器-根据执行计划调用存储引擎的接口"><a href="#执行器-根据执行计划调用存储引擎的接口" class="header-anchor">#</a> 执行器：根据执行计划调用存储引擎的接口</h4> <p>思考一个问题，存储引擎可以帮助我们去访问内存和磁盘上的数据，那么是谁来调用存储引擎的接口呢？<br>
执行器会根据优化器选择的执行方案，去调用存储引擎的接口按照一定的顺序和步骤，把SQL语句的逻辑给执行了。</p> <p>举个例子，比如执行器可能会先调用存储引擎的一个接口，去获取users表中的第一行数据，然后判断一下这行数据的id字段是否等于我们期望的一个值，如果不是的话，接着去获取users表的下一行数据。</p> <p>就是基于上诉思路，<strong>执行器就会根据我们的优化器生成的一套执行计划，然后不停的调用存储引擎的各种接口，去完成SQL语句的执行计划</strong>，大致就是不停的更新或者提取一些数据出来。<br> <img src="/docs/assets/img/tomcat2mysql8.c01ef993.png" alt="数据库连接池之执行器" title="tomcat2mysql8.png"></p> <p><font color="FF0000" size="4">课后思考题：</font><br>
各个存储引擎的区别？<br>
从业务场景考虑，有的场景可能是高并发的更新，有的场景可能是大规模的数据查询，有的场景可能是允许数据丢失的</p> <h2 id="初步了解innodb存储引擎的架构设计"><a href="#初步了解innodb存储引擎的架构设计" class="header-anchor">#</a> 初步了解InnoDB存储引擎的架构设计</h2> <p><img src="/docs/assets/img/tomcat2mysql9.2e9d80c5.png" alt="数据库连接池之执行器" title="tomcat2mysql9.png"></p> <h4 id="innodb重要的缓存结构-缓冲池"><a href="#innodb重要的缓存结构-缓冲池" class="header-anchor">#</a> InnoDB重要的缓存结构：缓冲池</h4> <p>InnoDB存储引擎中有一个非常重要的组件，就是<strong>缓冲池（Buffer Pool）</strong>，
这里面会缓存很多数据，以便于以后再查询的时候，万一在内存缓冲池里有数据，就不用去查磁盘了。</p> <p><img src="/docs/assets/img/innodb1.c091f99e.png" alt="innodb之Buffer Pool" title="innodb1.png"><br>
Update users set name=’xxx’ where id =10<br> <font color="FFD700" size="4">所以当InnoDB存储引擎要执行更新语句的时候，比如对”id=10”这一行数据，其实会先看看“id=10”这行数据是否在缓冲池里，如果不在的话，那么会直接从磁盘里  加载到缓冲池里来，而且接着还会对这行记录加独占锁。</font></p> <p><img src="/docs/assets/img/innodb2.503adaa4.png" alt="innodb之Buffer Pool" title="innodb2.png"></p> <h4 id="undo日志文件-如何让你更新的数据可以回滚"><a href="#undo日志文件-如何让你更新的数据可以回滚" class="header-anchor">#</a> undo日志文件：如何让你更新的数据可以回滚</h4> <p>把更新前的数据写入undo日志文件中，便于后面进行回滚操作。</p> <p><img src="/docs/assets/img/innodb3.a36f94ce.png" alt="innodb之undo log日志" title="innodb3.png"></p> <h4 id="更新buffer-pool中的缓存数据"><a href="#更新buffer-pool中的缓存数据" class="header-anchor">#</a> 更新Buffer Pool中的缓存数据</h4> <p>当我们把要更新的那行记录从磁盘文件加载到缓冲池中，同时对其进行加锁后，而且还把更新前的旧值写入undo日志文件后，我们就可以正式更新这行记录了，更新的时候，先更新缓冲池中的记录，此时这个数据就是脏数据了（因为此时磁盘中的数据还是更新前的数据，磁盘和内存中的数据不一致了）。</p> <p><img src="/docs/assets/img/innodb4.9341493d.png" alt="innodb之undo log日志" title="innodb4.png"></p> <h4 id="redo-log-buffer-万一系统宕机-如何避免数据丢失"><a href="#redo-log-buffer-万一系统宕机-如何避免数据丢失" class="header-anchor">#</a> Redo Log Buffer:万一系统宕机，如何避免数据丢失</h4> <p>现在内存中的数据已经修改，但是磁盘中的数据还没有修改，如果此时MySQL所在的机器宕机了，比如会导致内存里修改的数据丢失，怎么办？
这个时候必须把对内存所做的修改写入到一个Redo Log Buffer中去，他是内存中的一个缓冲区，是用来存放redo日志的。</p> <p><img src="/docs/assets/img/innodb5.a92d22e4.png" alt="innodb之undo log日志" title="innodb5.png"></p> <p>如果还没有提交事务，MySQL宕机了怎么办？
此时Buffer Pool中的数据会丢失，同时你写入Redo Log Buffer中的redo日志也会丢失。其实这时数据丢失不影响，MySQL重启之后，数据库的数据没有发生变化。相当于没有提交事务。</p> <p><img src="/docs/assets/img/innodb6.5dbe92dc.png" alt="innodb之undo log日志" title="innodb6.png"></p> <h4 id="提交事务的时候将redo日志写入磁盘中"><a href="#提交事务的时候将redo日志写入磁盘中" class="header-anchor">#</a> 提交事务的时候将redo日志写入磁盘中</h4> <p>接着我们想提交事务了，此时会根据一定的策略把redo日志从redo log buffer中刷入到磁盘文件里。</p> <p><font color="FF0000" size="4">redo log buffer刷回磁盘策略参数：innodb_flush_log_at_trx_commit=0</font><br>
含义：提交事务的时候，不会把redo log buffer中的数据刷入到磁盘中，此时可能你都提交事务了，但是MySQL突然宕机了，然后此时内存中的所有数据都会丢失。<br> <img src="/docs/assets/img/innodb7.4c75962e.png" alt="innodb之redo log buffer日志" title="innodb7.png"></p> <p><font color="FF0000" size="4">redo log buffer刷回磁盘策略参数（建议设置）：innodb_flush_log_at_trx_commit=1</font><br>
含义：提交事务的时候，必须把数据从redo log buffer中刷入到磁盘上。只要事务提交成功，那么redo log就必然在磁盘里了。因为是先写的redo log日志，然后再把数据刷入磁盘文件中。</p> <p><img src="/docs/assets/img/innodb8.97fedf6e.png" alt="innodb之redo log buffer日志" title="innodb8.png"><br>
有可能此时Buffer Pool中的数据还没有写入磁盘，但是此时内存里的数据已经是更新后的数据，然后磁盘上是更新前的数据。这种状态下（redo log已刷入磁盘，但是事务还没提交，所以Buffer Pool中的数据可能还没刷回磁盘），MySQL突然崩溃，会丢失数据吗？
<img src="/docs/assets/img/innodb9.111edc35.png" alt="innodb之redo log buffer日志" title="innodb9.png"><br>
这种情况不会丢失数据，因为redo log里记录了修改后的数据，mysql重启之后，可以根据redo log日志文件恢复之前做的修改。</p> <p><img src="/docs/assets/img/innodb11.ee69aca2.png" alt="innodb之redo log buffer日志" title="innodb11.png"></p> <p><font color="FF0000" size="4">redo log buffer刷回磁盘策略参数：innodb_flush_log_at_trx_commit=2</font><br>
含义：提交事务的时候，<strong>把redo日志写入磁盘文件对应的os cache缓存中去</strong>，而不是直接写入磁盘文件；可能1s后才会把os cache里的数据写入到磁盘文件里去。
在把redo日志写入磁盘文件之前mysql宕机的话，那么数据会丢失。
<img src="/docs/assets/img/innodb12.68283f20.png" alt="innodb之redo log buffer日志" title="innodb12.png"></p> <p><strong>redo log日志刷盘策略的选择建议</strong><br>
建议设置为1，这样可以保证redo log写入到了磁盘上，即使mysql宕机，还可以根据redo log恢复数据。0和1都可能导致数据丢失。</p> <h2 id="mysql-binlog"><a href="#mysql-binlog" class="header-anchor">#</a> MySQL binlog</h2> <h3 id="binlog概念"><a href="#binlog概念" class="header-anchor">#</a> binlog概念</h3> <p><strong>Redo log是一种偏向物理性质的重做日志</strong>，因为他里面记录了类似这样的东西，“对哪个数据页中的什么记录，做了个什么修改”
<strong>redo log是innoDB特有的一个东西</strong>。</p> <p><strong>binlog叫做归档日志</strong>，它里面记录的偏向于逻辑性的日志，类似于“对users表中id=10这一行数据做了更新操作，更新以后的值是什么”</p> <h3 id="binlog写入时机"><a href="#binlog写入时机" class="header-anchor">#</a> binlog写入时机</h3> <p>在提交事务的时候会把redo log写入到磁盘中去，然后其实在提交事务的时候我们同时会把这次更新对应的binlog日志写入到磁盘中去。<br> <img src="/docs/assets/img/binlog1.1738211f.png" alt="binlog日志" title="binlog1.png"></p> <p>从上图可以看出我们把更新语句的执行拆分为了两个阶段，上图 中1/2/3/4几个步骤，其本质就是你执行更新语句的时候干的事；5和6两个步骤是从你提交事务开始的，属于提交事务的阶段了。</p> <h3 id="binlog刷盘策略"><a href="#binlog刷盘策略" class="header-anchor">#</a> binlog刷盘策略</h3> <p>Binlog其实也有不同的刷盘策略，有一个参数叫 sync_binlog，它既是控制刷盘策略的参数，默认值是0。</p> <p><font color="FF0000" size="4">bin log刷回磁盘策略参数：sync_binlog=0</font><br>
含义：binlog是先写入os cache，然后再写入磁盘。</p> <p><img src="/docs/assets/img/binlog2.a15a4b95.png" alt="binlog刷入磁盘策略" title="binlog2.png"></p> <p><font color="FF0000" size="4">bin log刷回磁盘策略参数：sync_binlog=1</font><br>
含义：会强制在提交事务的时候把binlog刷入磁盘，这样提交事务之后，哪怕宕机，磁盘上的binlog是不会丢的。<br> <img src="/docs/assets/img/binlog3.762a2f43.png" alt="binlog刷入磁盘策略" title="binlog3.png"></p> <h2 id="基于binlog和redo-log完成事务的提交"><a href="#基于binlog和redo-log完成事务的提交" class="header-anchor">#</a> 基于binlog和redo log完成事务的提交</h2> <p><font color="FF0000" size="4">当我们把binlog写入磁盘文件后，接着就会完成最终的事务提交，此时会把本次更新对应的binlog文件名称和位置都写入到redo log日志文件中去，同时在redo log中写入一个commit标记。</font></p> <p><img src="/docs/assets/img/binlog4.3affa347.png" alt="binlog和redo log" title="binlog4.png"></p> <p><font color="0000FF" size="4">最后一步写入commit标记的作用：刚完成步骤5时，mysql宕机了，此时redo log中没有commit标记，可以判定事务失败了。<br>
如果完成了6，也就是写入binlog日志文件成功后，mysql宕机了，因为redo log中没有commit标记，也可以判定事务失败了。</font></p> <p>必须是在redo log中写入了最终的事务commit标记了，事务才算提交成功，而且redo log和bin log中都有本次更新对应的日志，他们完全是一致的。</p> <h2 id="后台io线程随机将内存中更新后的脏数据刷回到磁盘"><a href="#后台io线程随机将内存中更新后的脏数据刷回到磁盘" class="header-anchor">#</a> 后台IO线程随机将内存中更新后的脏数据刷回到磁盘</h2> <p>现在我们假设已经提交了事务了，此时更新“update users set name='xxx' where id='10' &quot;,他已经把内存里的buffer pool中的缓存数据更新了，同时磁盘里有redo日志和binlog日志，都记录了我们把id=10这行数据的name修改为了name=xxx</p> <p>此时，我们思考一个问题，磁盘上id=10的这条数据的name字段更新了吗？<br>
没有更新，还是以前的值。</p> <p><strong>所以MySQL有一个后台的IO线程，会在之后某个时间里，随机的把内存buffer pool中的修改后的脏数据给刷回到磁盘上的数据文件里去</strong>，看下图：</p> <p><img src="/docs/assets/img/io_flush_data1.814680d4.png" alt="binlog和redo log" title="io_flush_data1.png"></p> <p>在你IO线程把脏数据刷回磁盘前，哪怕mysql宕机崩溃了也没关系，因为重启之后，会根据redo日志回复之前提交事务做过的修改到内存里去。然后等待合适的时机，IO线程自然还是会把这个修改后的数据刷到磁盘上的数据文件里去。</p> <h2 id="基于更新数据的流程-总结一下innodb存储引擎的架构原理"><a href="#基于更新数据的流程-总结一下innodb存储引擎的架构原理" class="header-anchor">#</a> 基于更新数据的流程，总结一下InnoDB存储引擎的架构原理</h2> <p>大家通过一次更新数据的流程，可以清晰的看到，InnoDB存储引擎主要就是包含了一些buffer pool，redo log buffer等内存里的缓存数据，同时还包含了一些undo日志文件，redo log日志文件等，同时mysql server自己还有binlog日志文件。</p> <p>在你执行更新的时候，每条SQL语句，都会对应的修改buffer pool里的缓存数据，写redo log日志、写redo log buffer、写binlog日志几个步骤。<br>
但是当你提交事务的时候，一定会把redo log刷入磁盘，binlog刷入磁盘，完成redo log中的事务commit标记，最后后台的IO线程会随机的把buffer pool里的脏数据刷回磁盘里去。</p> <h2 id="生产环境数据库配置"><a href="#生产环境数据库配置" class="header-anchor">#</a> 生产环境数据库配置</h2> <h3 id="数据库机器的选择以及大致的并发能力"><a href="#数据库机器的选择以及大致的并发能力" class="header-anchor">#</a> 数据库机器的选择以及大致的并发能力</h3> <p><img src="/docs/assets/img/prod_db_config1.00a05412.png" alt="生产数据库配置对应的并发能力" title="prod_db_config1.png"><br> <img src="/docs/assets/img/prod_db_config2.47eddb1d.png" alt="生产数据库配置对应的并发能力" title="prod_db_config2.png"><br> <img src="/docs/assets/img/prod_db_config3.3e0838bb.png" alt="生产数据库配置对应的并发能力" title="prod_db_config3.png"><br> <img src="/docs/assets/img/prod_db_config4.81c68376.png" alt="生产数据库配置对应的并发能力" title="prod_db_config4.png"></p> <p>如果有可能，<strong>最好使用SSD固态硬盘而不是普通的机械硬盘</strong>，能进一步提升数据库的性能。</p> <h2 id="buffer-pool的地位"><a href="#buffer-pool的地位" class="header-anchor">#</a> Buffer Pool的地位</h2> <p><font color="0000FF" size="4">Buffer Pool是一个内存数据结构。</font><br>
你在对数据库进行增删改的时候，实际上主要就是针对Buffer Pool中的数据进行的。也就是你是对内存里的数据进行了增删改。<br>
Redo log和binlog就是为了帮助我们在mysql宕机时快速恢复数据用的，要不然你做了一堆的增删改，最后这些动作没有生效，这样就太可怕了。</p> <p><img src="/docs/assets/img/buffer_pool1.54b0742b.png" alt="buffer pool整体示意图" title="buffer_pool1.png"></p> <h3 id="buffer-pool的大小如何设置"><a href="#buffer-pool的大小如何设置" class="header-anchor">#</a> Buffer Pool的大小如何设置</h3> <p>Buffer Pool的默认大小是128M，有点小。生产环境需要对Buffer Pool大小进行调整。如果我们的数据库是在16核32G的机器上，那么可以给Buffer Pool分配2G的内存。<br> <font color="0000FF" size="4">使用下面的配置就可以了：<br>
[server]<br>
innodb_buffer_pool_size = 2147483648</font></p> <h3 id="数据页-mysql抽象出来的数据单位"><a href="#数据页-mysql抽象出来的数据单位" class="header-anchor">#</a> 数据页：MySql抽象出来的数据单位</h3> <p><img src="/docs/assets/img/data_page1.51023b97.png" alt="数据页" title="data_page1.png"></p> <p>所以实际上假设我们要更新一条数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去。<br> <img src="/docs/assets/img/data_page2.a8676c77.png" alt="数据页" title="data_page2.png"></p> <h3 id="磁盘上的数据页和buffer-pool中的缓存页是如何对应起来的"><a href="#磁盘上的数据页和buffer-pool中的缓存页是如何对应起来的" class="header-anchor">#</a> 磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的</h3> <p>实际上默认情况下，<font color="0000FF" size="4">磁盘中存放的数据页的大小是16KB。Buffer Pool中的数据页叫做缓存页，</font>因为毕竟Buffer Pool是一个缓存池，里面的数据是从磁盘中加载到内存中去的。</p> <h3 id="缓存页对应的描述信息是什么"><a href="#缓存页对应的描述信息是什么" class="header-anchor">#</a> 缓存页对应的描述信息是什么</h3> <p><font color="FFD900" size="4">缓存页“描述数据”包含：数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及其它信息。</font><br> <strong>描述数据也可以叫做控制数据</strong>。
<img src="/docs/assets/img/data_page3.358148e1.png" alt="数据页" title="data_page3.png"></p> <p>而且我们要注意一点，Buffer Pool中的<strong>描述数据</strong>大概相当于缓存页大小的5%左右，<font color="FF0000" size="4">也就是说每个描述数据大概是800个字节，然后假设你设置Buffer Pool大小是128MB,实际上Buffer pool的大小可能有130多MB，因为里面还要存储缓存页的描述数据。</font></p> <h3 id="数据库启动的时候-是如何初始化buffer-pool的"><a href="#数据库启动的时候-是如何初始化buffer-pool的" class="header-anchor">#</a> 数据库启动的时候，是如何初始化Buffer Pool的</h3> <p>第一步：数据库启动的时候，会按照你设置的Buffer Pool的大小，稍微比这大一些，去申请一块内存区域作为Buffer Pool的内存区域。<br>
第二步：数据库会按照默认的缓存页的16KB的大小及800个字节左右的描述数据的大小，在Buffer Pool中划分出来一个个的缓存页和他们对应的描述数据（这个时候缓存页是空的）。</p> <h3 id="怎么知道哪个缓存页是空闲的"><a href="#怎么知道哪个缓存页是空闲的" class="header-anchor">#</a> 怎么知道哪个缓存页是空闲的</h3> <p><font color="FF0000" size="4">数据库会为Buffer Pool设计一个free链表，它是一个双向链表数据结构。</font>链表里每个节点都是一个空闲的缓存页的描述数据块的地址。<br>
所以在数据库刚启动的时候，数据库是空的，但是free链表里面存了所有的缓存数据页的描述数据块。<br> <img src="/docs/assets/img/free_linked_list1.ca35bffb.png" alt="free链表" title="free_linked_list1.png"></p> <p>大家可以看到上面出现了一个free链表，这个free链表里就是各个缓存页的描述数据块，只要缓存页是空闲的，那么他们对应的描述数据块就会加入到这个free链表中，每个节点都会双向连接自己的前后节点，组成一个双向链表。<br>
另外要注意，free链表有一个<strong>基础节点</strong>，它会引用链表的头节点和尾节点，里面还存储了有多少个描述数据块节点，也就是有多少个空闲的缓存页。<br> <font color="FF0000" size="4">还有一点，这个free链表本身就是由Buffer Pool里的描述数据块组成的，你可以认为每个描述数据块里都有两个指针，一个是free_pre,一个是free_next,分别指向free链表的上一个节点，和free链表的下一个节点。</font><br>
前面是为了画图需要，才把free链表给抽出来了，其实就是原有的描述数据块组成的双向链表。</p> <h3 id="如何加载数据页到缓存页中"><a href="#如何加载数据页到缓存页中" class="header-anchor">#</a> 如何加载数据页到缓存页中</h3> <p><img src="/docs/assets/img/data_page4.40216497.png" alt="数据页" title="data_page4.png"></p> <h3 id="怎么知道一个数据页有没有被缓存呢"><a href="#怎么知道一个数据页有没有被缓存呢" class="header-anchor">#</a> 怎么知道一个数据页有没有被缓存呢</h3> <p><font color="FF0000" size="4">数据库有一个哈希表数据结构，他会用表空间号+数据页号作为key，缓存页的地址作为value。当你要使用一个数据页的时候，可以通过“表空间号+数据页号”作为key，去哈希表里查一下，如果没有就读取数据页，如果有，说明数据页已经被缓存了。</font><br> <img src="/docs/assets/img/data_page5.6bb040fc.png" alt="数据页" title="data_page5.png"></p> <h3 id="如何减少内存碎片"><a href="#如何减少内存碎片" class="header-anchor">#</a> 如何减少内存碎片</h3> <p><img src="/docs/assets/img/data_page6.b188fced.png" alt="减少内存碎片" title="data_page6.png"></p> <h3 id="脏数据页-flush链表"><a href="#脏数据页-flush链表" class="header-anchor">#</a> 脏数据页（flush链表）</h3> <p>不是所有的缓存页都是脏数据页，<font color="FF0000" size="4">只有缓存页和磁盘上的数据页数据不一致时，缓存页才是脏数据页。</font>有的缓存页可能是因为查询的时候被读取到Buffer Pool中去的，这些数据是没有经过修改的。查询的缓存页是不需要刷回磁盘的，怎么区分要不要刷回磁盘呢？<br>
数据库引入了跟free链表结构类似的<font color="FF0000" size="4">flush链表，它本质上也是通过缓存页的描述数据块的前后两个指针，存放被修改过的描述数据块，组成一个双向链表。所以flush链表的数据是要刷回磁盘的数据。</font><br>
因为free存放的是空闲的缓存页，flush存放的是被修改的缓存页，所以它们都用数据块的前后指针就能组成两个链表，没有交叉的部分。<br> <img src="/docs/assets/img/flush_linkedList1.4117800f.png" alt="flush链表" title="flush_linkedList1.png"></p> <h3 id="如何淘汰一些缓存数据页"><a href="#如何淘汰一些缓存数据页" class="header-anchor">#</a> 如何淘汰一些缓存数据页</h3> <p>需要把缓存页的数据给刷到磁盘上的数据页里去，然后这个缓存页就可以清空了，让它变成一个空闲的缓存页。<br> <img src="/docs/assets/img/discard_data_page1.e4bb5b4a.png" alt="缓存页刷回磁盘" title="discard_data_page1.png"></p> <h3 id="缓存命中率的概念"><a href="#缓存命中率的概念" class="header-anchor">#</a> 缓存命中率的概念</h3> <p>就是说在100次查询中，有30次命中了缓存，那么可以说缓存命中率很高；如果100次查询中，只有最开始加载到缓存中，后面一次都没命中，就可以说缓存命中率低。</p> <h3 id="lru缓存淘汰算法"><a href="#lru缓存淘汰算法" class="header-anchor">#</a> LRU缓存淘汰算法</h3> <p>此时需要引入一个LRU（Least Recently Used最近最少使用）链表。<br> <strong>原理：每次从磁盘加载数据页到缓存中去的时候，同时把这个缓存页的描述数据块放入LRU链表的头部中。</strong>
然后假设某个缓存页的描述数据块本来在LRU链表的尾部，后续只要你查询或者修改了这个缓存页的数据，也要把这个缓存页挪到LRU链表的头部，也就是说最近被访问的缓存页一定在链表的头部。
然后只需要取出链表尾部的数据，刷入磁盘并清空该缓存页。它一定是最近最少被访问的缓存页。</p> <h3 id="sql里表和行的概念与表空间、数据页的关系"><a href="#sql里表和行的概念与表空间、数据页的关系" class="header-anchor">#</a> SQL里表和行的概念与表空间、数据页的关系</h3> <p>表和行是逻辑概念。<br>
表空间和数据页是物理概念。实际上在物理层面，你的表里的数据都是存放在一个表空间中，表空间是由一堆磁盘上的文件组成的，这些数据文件里都存放了你表里的数据，这些数据是由一个个的数据页组织起来的。<br> <strong>预读机制和全表扫描会导致频繁被访问的缓存页被淘汰</strong>。</p> <h2 id="预读机制"><a href="#预读机制" class="header-anchor">#</a> 预读机制</h2> <h3 id="mysql预读机制"><a href="#mysql预读机制" class="header-anchor">#</a> mysql预读机制</h3> <p><strong>所谓预读机制就是你加载一个数据页的时候，可能连带着把它相邻的数据页也加载到缓存里</strong>。<br> <strong>预读机制带来的问题</strong>：之前链表中是经常被访问的缓存页，但是预读之后，预读的数据页并不是常用的，甚至预读进去的数据压根没人访问，当没有空闲的缓存页时，你把链表尾部的缓存页给刷入磁盘，然后清空该缓存页，实际上这样做是不合适的。<br>
为什么要预读，还不是为了提升性能，假设你访问01数据页，接下来你看你会接着访问02数据页，如果不预读，你看你需要两次IO操作，如果预读了，一次IO就够了。<br> <img src="/docs/assets/img/pre_read.3231bb97.png" alt="预读机制" title="pre_read.png"></p> <h3 id="什么情况下会触发mysql的预读机制"><a href="#什么情况下会触发mysql的预读机制" class="header-anchor">#</a> 什么情况下会触发mysql的预读机制</h3> <p>A）有一个参数是Innodb_read_ahead_threshold,它的默认值是56，含义是如果顺序访问一个区里的多个数据页，访问的数据页的数量超过了这个阈值，此时就会触发预读机制，把下一个相邻区的所有数据页给加载到缓存中去<br>
B）还有一个参数innodb_random_ahead,默认是OFF，关闭的。
含义是如果Buffer Pool里缓存了一个区里的13个连续的数据页，而且这些数据页是频繁被访问的，此时就会触发预读机制，把这个区里的其他数据页都给加载到缓存中去。<br> <img src="/docs/assets/img/pre_read2.b401e816.png" alt="预读机制" title="pre_read2.png"></p> <h3 id="全表扫描-另外一种频繁访问的数据被淘汰的场景"><a href="#全表扫描-另外一种频繁访问的数据被淘汰的场景" class="header-anchor">#</a> 全表扫描（另外一种频繁访问的数据被淘汰的场景）</h3> <p>全表扫描会导致数据库把表里所有的数据页都给加载到Buffer Pool里去。所以有可能链表尾部是频繁被访问的数据，到时候淘汰这些数据就不合适了。</p> <h3 id="冷热数据分离的思想设计lru链表"><a href="#冷热数据分离的思想设计lru链表" class="header-anchor">#</a> 冷热数据分离的思想设计LRU链表</h3> <h4 id="冷热数据分离时-lru被分成两部分"><a href="#冷热数据分离时-lru被分成两部分" class="header-anchor">#</a> 冷热数据分离时，LRU被分成两部分</h4> <p><font color="FF0000" size="4">根据参数innodb_old_blocks_pct来控制冷热数据的比例,默认是37，冷数据占37%</font><br> <img src="/docs/assets/img/LRU_hot_cold.c5b3ad8a.png" alt="LRU冷热数据分离" title="LRU_hot_cold.png"></p> <p><img src="/docs/assets/img/LRU_hot_cold2.7697b6f6.png" alt="LRU冷热数据分离" title="LRU_hot_cold2.png"></p> <h4 id="冷数据区域的缓存页什么时候会被放入热数据区域"><a href="#冷数据区域的缓存页什么时候会被放入热数据区域" class="header-anchor">#</a> 冷数据区域的缓存页什么时候会被放入热数据区域</h4> <p>第一次加载数据的缓存页时，把缓存页放入冷数据区域的链表头部。
但是什么时候放入热数据区域呢，如果第一次访问该缓存页就把数据放入热数据区域，是否可行呢，不可行。如果刚加载进去，你立马（1ms以内）访问了该缓存页，之后再也不访问了。</p> <p>为了应对这种情况MYSQL设定了一个规则有个<font color="FF0000" size="4">参数innodb_old_blocks_time，默认1000ms，也就是说一个数据页被加载到缓存页之后，在1s后，你访问这个缓存页，他才会被挪到热数据区域链表的头部。</font></p> <h4 id="预读机制和全表扫描加载进来的缓存页-能进热数据区域吗"><a href="#预读机制和全表扫描加载进来的缓存页-能进热数据区域吗" class="header-anchor">#</a> 预读机制和全表扫描加载进来的缓存页，能进热数据区域吗？</h4> <p><font color="0000FF" size="4">如果你仅仅是一个全表扫描的查询，此时你肯定是在1s内把一大堆缓存页加载进来，然后就访问这些缓存页一下，通常这些操作在1s内就结束了。</font><br>
所以基于目前的一个机制，可以确定的是，这种情况下，那些缓存页是不会从冷数据区域转移到热数据区域的！</p> <p>陈飞你在冷数据区域里的缓存页，在1s之后还被人访问了，那么此时他们就会判定为未来可能会被频繁访问的缓存页，然后移动到热数据区域的链表的头部！</p> <h4 id="如果此时缓存页不够了-需要淘汰一些缓存-怎么办"><a href="#如果此时缓存页不够了-需要淘汰一些缓存-怎么办" class="header-anchor">#</a> 如果此时缓存页不够了，需要淘汰一些缓存，怎么办？</h4> <p>直接找到LRU链表的冷数据区域尾部的缓存页，他们肯定是之前被加载进来的，而且加载后1s内都没有访问过，说明这个缓存页压根就没人愿意访问它，它就是冷数据。</p> <p>所以此时淘汰冷数据区域尾部的缓存页即可，把它刷入磁盘中。</p> <h4 id="redis中存放了很多的冷热数据-怎么解决"><a href="#redis中存放了很多的冷热数据-怎么解决" class="header-anchor">#</a> redis中存放了很多的冷热数据，怎么解决</h4> <p><img src="/docs/assets/img/redis1.b8c22197.png" alt="redis冷热数据" title="redis1.png"></p> <h3 id="lru链表热数据区域是如何进行优化的"><a href="#lru链表热数据区域是如何进行优化的" class="header-anchor">#</a> LRU链表热数据区域是如何进行优化的</h3> <p><strong>问题</strong>：有一个优化点，就是说如果你访问了人数据区域的一个缓存页，是不是要立马把它移动到热数据区域链表的头部？<br>
其实想想也是有问题的，因为热数据区域的数据本身就是经常访问的数据，访问一次，你移动数据到链表的头部，这样会影响效率的。<br> <strong>解决方案</strong>：只有热数据区域后3/4的数据被访问了，才移动到热数据区域链表的头部，前1/4的数据被访问了，不需要移动数据。<br> <img src="/docs/assets/img/lru_free.5a827cc0.png" alt="redis冷热数据" title="lru_free.png"></p> <h2 id="lru链表冷数据区域和flush链表数据刷入磁盘的三个时机"><a href="#lru链表冷数据区域和flush链表数据刷入磁盘的三个时机" class="header-anchor">#</a> LRU链表冷数据区域和Flush链表数据刷入磁盘的三个时机</h2> <p><font color="FF0000" size="4">定时把LRU链表冷数据区域尾部数据刷入磁盘</font><br>
首先第一个时机，并不是在缓存页满的时候，才会挑选LRU链表冷数据区域尾部的几个缓存页刷入磁盘，而是有一个后台线程，它会运行给定时任务，这个定时任务每隔一段时间就会把LRU链表的冷数据区域尾部的一些缓存页，刷入磁盘，然后清空这些缓存页，把他们放回free链表里去。<br> <img src="/docs/assets/img/quartz1.5472632d.png" alt="定时把LRU刷回磁盘" title="quartz1.png"></p> <p><font color="FF0000" size="4">把flush链表的一些缓存页定时刷入磁盘</font><br> <img src="/docs/assets/img/flush_data2.2cf6e4e3.png" alt="定时把flush刷回磁盘" title="flush_data2.png"></p> <p><font color="FF0000" size="4">实在没有缓存页了，怎么办（被动清理LRU尾部）</font><br>
如果free中实在是没有缓存页了，这个时候你需要加载数据页到缓存页中，那么就需要把LRU冷数据尾部的数据刷入磁盘，并清空缓存页，然后加载数据到缓存页中去。</p> <p><font color="0000FF" size="4">思考题：</font><br> <img src="/docs/assets/img/buffer_pool2.91d5591e.png" alt="扩大Buffer Pool" title="buffer_pool2.png"></p> <h2 id="如何通过多个buffer-pool来优化数据库的性能"><a href="#如何通过多个buffer-pool来优化数据库的性能" class="header-anchor">#</a> 如何通过多个Buffer Pool来优化数据库的性能</h2> <p><strong>多线程并发访问Buffer Pool</strong><br>
下图就是多线程并发访问Buffer Pool的示意图：<br> <img src="/docs/assets/img/buffer_pool3.929edac1.png" alt="Buffer Pool" title="buffer_pool3.png"><br> <img src="/docs/assets/img/buffer_pool4.27a0575b.png" alt="Buffer Pool" title="buffer_pool4.png"></p> <p><font color="FF0000" size="4">MySQL生产优化经验：多个Buffer Pool优化并发能力</font><br>
可以设置多个Buffer Pool提升并发能力。<br>
一般来说，mysql的默认规则是，如果你给Buffer Pool分配的内存小于1G，那么最多会给你一个Buffer Pool。<br>
如果你的机器内存很大，你给Buffer Pool分配了8个G的内存，那么此时你是可以设置多个Buffer Pool的。<br>
这种情况下，mysql服务器端的配置如下：<br> <img src="/docs/assets/img/buffer_pool5.cd3a1e89.png" alt="Buffer Pool" title="buffer_pool5.png"></p> <h3 id="buffer-pool运行期间动态调整大小"><a href="#buffer-pool运行期间动态调整大小" class="header-anchor">#</a> Buffer Pool运行期间动态调整大小</h3> <p>基于前面讲解的规则的话，mysql不支持运行期间动态调整，比如，你就一个1G的Buffer Pool，你给调整成了16G，明显申请不到这么大的内存。<br> <font color="FF0000" size="4">但是可以基于chunk规则进行动态调整Buffer Pool大小。<br>
如何基于chunk机制把buffer pool给拆小呢？</font></p> <h3 id="chunk机制概念"><a href="#chunk机制概念" class="header-anchor">#</a> chunk机制概念</h3> <p>MySQL设计了一个chunk机制，也就是说Buffer Pool是由很多chunk组成，<font color="FF0000" size="4">chunk的大小是由innodb_buffer_pool_chunk_size参数控制的，默认值是128M。</font><br>
我们做个假设，比如现在我们给Buffer Pool设置总大小是8GB，然后有4个Buffer Pool，那么每个Buffer Pool的大小就是2GB，此时可以算出chunk的个数是16个。<br>
每个chunk就是描述数据块和缓存页组成，一个Buffer Pool中的所有chunk共享一套free、flush、lru这些链表。大致示意图如下：<br> <img src="/docs/assets/img/chunck1.605e8179.png" alt="chunck" title="chunck1.png"></p> <h2 id="数据库压测"><a href="#数据库压测" class="header-anchor">#</a> 数据库压测</h2> <h3 id="为什么在不停增加线程数量的时候-要密切关注机器性能"><a href="#为什么在不停增加线程数量的时候-要密切关注机器性能" class="header-anchor">#</a> 为什么在不停增加线程数量的时候，要密切关注机器性能？</h3> <p>首先，假设数据库当前抗下了每秒2000的QPS，同时这个时候机器的CPU负载、内存负载、网络负载、磁盘IO负载，都在正常的范围内，负载相对较高一些，但是还没有达到这些硬件的极限，那么我们可以认为这台数据库在高峰期抗到每秒2000的QPS，是没有问题的。
但是如果你一直不停的在压测过程中增加sysbench的线程数量，然后数据库此时勉强抗到了每秒5000的QPS了，但是这个时候你发现机器的CPU已经满负荷运行了，内存使用率特别高，内存都快要不够了，然后网络带宽几乎被打满了，磁盘IO的等待时间特别长，这个时候说明机器已经到了极致了，再搞下去，机器都快挂了。</p> <p>所以这个时候你压测出来的5000 QPS是没什么代表性的，因为在生产环境根本不可能让数据库抗下这么高的QPS，因为到这么高的QPS就说明你的数据库几乎已经快要挂掉了，这是不现实的。</p> <h3 id="压测时如何观察机器的cpu负载情况"><a href="#压测时如何观察机器的cpu负载情况" class="header-anchor">#</a> 压测时如何观察机器的CPU负载情况？</h3> <p><font color="FF0000" size="4">使用top命令</font><br> <font color="0000FF" size="4">top - 15:52:00 up 42:35, 1 user, load average: 0.15, 0.05, 0.01</font><br>
15:52:00指的是当前时间<br>
up 42:35指的是机器已经运行了多长时间<br>
1 user就是说当前机器有1个用户在使用<br> <font color="0000FF" size="4">最重要的是load average: 0.15, 0.05, 0.01这行信息，他说的是CPU在1分钟、5分钟、15分钟内的负载情况。</font></p> <p>假设我们是一个4核的CPU，此时如果你的CPU负载是0.15，这就说明，4核CPU中连一个核都没用满，4核CPU基本都很空闲，没啥人在用。如果你的CPU负载是1，那说明4核CPU中有一个核已经被使用的比较繁忙了，另外3个核还是比较空闲一些。要是CPU负载是1.5，说明有一个核被使用繁忙，另外一个核也在使用，但是没那么繁忙，还有2个核可能还是空闲的。如果你的CPU负载是4，那说明4核CPU都被跑满了，如果你的CPU负载是6，那说明4核CPU被繁忙的使用还不够处理当前的任务，很多进程可能一直在等待CPU去执行自己的任务。<br> <font color="0000FF" size="4">但是如果你在压测的过程中，发现4核CPU的load average已经基本达到3.5，4了，那么说明几个CPU基本都跑满了，在满负荷运转，那么此时你就不要再继续提高线程的数量和增加数据库的QPS了，否则CPU负载太高是不合理的。</font></p> <h3 id="压测时如何观察机器的内存负载情况"><a href="#压测时如何观察机器的内存负载情况" class="header-anchor">#</a> 压测时如何观察机器的内存负载情况？</h3> <p><font color="0000FF" size="4">Mem: 33554432k total, 20971520k used, 12268339 free, 307200k buffers</font><br>
这里说的就是当前机器的内存使用情况，这个其实很简单，明显可以看出来就是总内存大概有32GB，已经使用了20GB左右的内存，还有10多G的内存是空闲的，然后有大概300MB左右的内存用作OS内核的缓冲区了。<br>
对于内存而言，同样是要在压测的过程中紧密的观察，一般来说，<strong>如果内存的使用率在80%以内，基本都还能接受</strong>，在正常范围内，但是如果你的机器的内存使用率到了70%~80%了，就说明有点危险了，此时就不要继续增加压测的线程数量和QPS了，差不多就可以了。</p> <h3 id="压测时如何观察机器的磁盘io情况"><a href="#压测时如何观察机器的磁盘io情况" class="header-anchor">#</a> 压测时如何观察机器的磁盘IO情况？</h3> <p>如果该命令不存在，使用如下命令安装：<font color="FF0000" size="4">yum install dstat</font><br>
使用<font color="FF0000" size="4">dstat -d</font>命令，会看到如下的东西：</p> <p>-dsk/total -<br>
read writ<br>
103k 211k<br>
0   11k<br>
在上面可以清晰看到，<strong>存储的IO吞吐量是每秒钟读取103kb的数据，每秒写入211kb的数据</strong>，像这个存储IO吞吐量基本上都不算多的，因为普通的机械硬盘都可以做到每秒钟上百MB的读写数据量。</p> <p>使用命令：dstat -r，可以看到如下的信息<br>
--io/total-<br>
read writ<br>
0.25 31.9<br>
0   253<br>
0   39.0</p> <p>他的这个意思就是<font color="FF0000" size="4">读IOPS和写IOPS分别是多少，也就是说随机磁盘读取每秒钟多少次，随机磁盘写入每秒钟执行多少次，</font>大概就是这个意思，<strong>一般来说，随机磁盘读写每秒在两三百次都是可以承受的</strong>。
所以在这里，我们就需要在压测的时候密切观察机器的磁盘IO情况，如果磁盘IO吞吐量已经太高了，都达到极限的每秒上百MB了，或者随机磁盘读写每秒都到极限的两三百次了，此时就不要继续增加线程数量了，否则磁盘IO负载就太高了。</p> <h3 id="压测时观察网卡的流量情况"><a href="#压测时观察网卡的流量情况" class="header-anchor">#</a> 压测时观察网卡的流量情况</h3> <p>接着我们可以使用dstat -n命令，可以看到如下的信息：<br>
-net/total-<br>
recv send<br>
16k  17k<br>
这个说的就是<font color="FF0000" size="4">每秒钟网卡接收到流量有多少kb，每秒钟通过网卡发送出去的流量有多少kb，</font>通常来说，如果你的机器使用的是千兆网卡，那么每秒钟网卡的总流量也就在100MB左右，甚至更低一些。</p> <p>所以我们在压测的时候也得观察好网卡的流量情况，如果网卡传输流量已经到了极限值了，那么此时你再怎么提高<strong>sysbench线程数量</strong>，数据库的QPS也上不去了，因为这台机器每秒钟无法通过网卡传输更多的数据了。</p> <h3 id="压测结果分析"><a href="#压测结果分析" class="header-anchor">#</a> 压测结果分析</h3> <p>thds: 10 tps: 102.50 qps: 1999.20 (r/w/o: 1392.17/402.03/204.99) lat (ms,95%): 167.44 err/s: 0.00 reconn/s: 0.00<br> <strong>thds: 10 有10个线程在压测</strong><br> <strong>tps: 102.50  每秒执行了102.5个事务</strong><br> <strong>qps: 1999.20 每秒执行了1999.2个请求</strong><br> <strong>(r/w/o: 1392.17/402.03/204.99) 1999.2个请求中，有1392.17个是读请求，402.03个是写请求，204.99个是其他请求</strong><br> <strong>lat (ms,95%) 167.44  95%的请求的延迟都在167.44毫秒以下</strong><br> <strong>err/s: 0.00 reconn/s: 0.00  每秒有0个请求是失败的，发生了0次网络重连</strong></p> <p><font color="FF0000" size="4">总的压测报告：</font><br>
SQL statistics:<br>
queries performed:<br>
read:    412832在300s的压测期间执行了41万次的读请求<br>
write:  117952  在300s的压测期间执行了11万次的写请求<br>
other:  58976在300s的压测期间执行了5.8万次的其他请求<br>
total:    589760 总共执行了58万次请求<br>
总共执行了29488个事务，每秒98.26个事务<br>
transactions:  29488  (98.26 per sec.)<br>
总共执行了589760次请求，每秒1965个请求<br>
queries:     589760 (1965.24 per sec.)<br>
ignored errors:                      0      (0.00 per sec.)<br>
reconnects:                          0      (0.00 per sec.)</p> <p>General statistics:<br>
total time:        300.0944s  压测时间<br>
total number of events:   29488 压测的事务</p> <p>Latency (ms):<br>
min:     5.26 最小的请求延迟<br>
avg:     101.75 所有请求的平均延迟<br>
max:     1203.63 最大的请求延迟<br>
95th percentile:   183.21  95%的请求延迟都在183.21秒内<br>
sum:                              3000336.05</p> <p>Threads fairness:<br>
events (avg/stddev):           2948.8000/18.14<br>
execution time (avg/stddev):   300.0336/0.03</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/markdown.html" class="prev">
        前端知识介绍
      </a></span> <span class="next"><a href="/docs/mysql.html">
        MySQL章节1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.54a4cdcf.js" defer></script><script src="/docs/assets/js/5.7c82c2c2.js" defer></script><script src="/docs/assets/js/3.02c95c72.js" defer></script>
  </body>
</html>
