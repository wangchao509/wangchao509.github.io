<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL章节1 | whc的学习笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="主要是java技术类笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.a889b764.css" as="style"><link rel="preload" href="/docs/assets/js/app.324b6e72.js" as="script"><link rel="preload" href="/docs/assets/js/4.99657516.js" as="script"><link rel="preload" href="/docs/assets/js/3.248ad4f9.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.c28a95e5.js"><link rel="prefetch" href="/docs/assets/js/11.f9292992.js"><link rel="prefetch" href="/docs/assets/js/12.d89ded10.js"><link rel="prefetch" href="/docs/assets/js/2.f1da8d51.js"><link rel="prefetch" href="/docs/assets/js/5.0d81c3fa.js"><link rel="prefetch" href="/docs/assets/js/6.4d2e2399.js"><link rel="prefetch" href="/docs/assets/js/7.cfe731d9.js"><link rel="prefetch" href="/docs/assets/js/8.5fe98276.js"><link rel="prefetch" href="/docs/assets/js/9.cf058650.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.a889b764.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">whc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">站点介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>markdown知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/markdown.html" class="sidebar-link">前端知识介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MySQL知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/mysql0.html" class="sidebar-link">MySQL章节0</a></li><li><a href="/docs/mysql.html" aria-current="page" class="active sidebar-link">MySQL章节1</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/mysql.html#mysql物理数据存储格式" class="sidebar-link">MySQL物理数据存储格式</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#变长字段在磁盘是怎么存储的" class="sidebar-link">变长字段在磁盘是怎么存储的</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#null值是怎么存储的" class="sidebar-link">NULL值是怎么存储的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#_40个bit位的数据头" class="sidebar-link">40个bit位的数据头</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#数据在磁盘上是如何存储的" class="sidebar-link">数据在磁盘上是如何存储的</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#行溢出" class="sidebar-link">行溢出</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#mysql数据页结构" class="sidebar-link">mysql数据页结构</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#表空间" class="sidebar-link">表空间</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#表空间的存储结构" class="sidebar-link">表空间的存储结构</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#插入一条数据" class="sidebar-link">插入一条数据</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#磁盘随机读写和数据库日志顺序读写" class="sidebar-link">磁盘随机读写和数据库日志顺序读写</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#linux存储系统架构图" class="sidebar-link">linux存储系统架构图**</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#数据库服务器的raid存储架构初步介绍" class="sidebar-link">数据库服务器的RAID存储架构初步介绍</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#数据库服务器上的raid存储架构的电池充放电原理" class="sidebar-link">数据库服务器上的RAID存储架构的电池充放电原理</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#raid锂电池充放电导致的mysql数据库性能抖动的优化" class="sidebar-link">RAID锂电池充放电导致的MySQL数据库性能抖动的优化</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#生产优化-锂电池充放电导致性能抖动的三种解决方案" class="sidebar-link">生产优化：锂电池充放电导致性能抖动的三种解决方案：</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#生产实战-数据库无法连接故障的定位-too-many-connections" class="sidebar-link">生产实战：数据库无法连接故障的定位，Too many connections**</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#生产实战-如何解决经典的too-many-connections故障" class="sidebar-link">生产实战：如何解决经典的Too many connections故障？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#redo日志对于事务提交后-数据绝对不会丢失的意义" class="sidebar-link">redo日志对于事务提交后，数据绝对不会丢失的意义</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#redo-log日志结构" class="sidebar-link">redo log日志结构</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#redo-log是一条一条写入日志文件的吗-非也" class="sidebar-link">redo log是一条一条写入日志文件的吗，非也</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#redo-log是直接写入磁盘文件吗" class="sidebar-link">redo log是直接写入磁盘文件吗？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#redo-log-buffer中的缓冲日志-到底什么时候可以写入磁盘" class="sidebar-link">redo log buffer中的缓冲日志，到底什么时候可以写入磁盘？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#事务执行到一半要回滚怎么办-再探undo-log回滚日志原理" class="sidebar-link">事务执行到一半要回滚怎么办，再探undo log回滚日志原理！</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#insert语句的undo-log回滚日志长什么样" class="sidebar-link">insert语句的undo log回滚日志长什么样？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#mysql运行时多个事务同时执行是什么场景" class="sidebar-link">MySQL运行时多个事务同时执行是什么场景？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#脏写和脏读" class="sidebar-link">脏写和脏读</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#不可重复读和幻读" class="sidebar-link">不可重复读和幻读</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#数据库四种隔离级别" class="sidebar-link">数据库四种隔离级别</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#mvcc多版本并发控制隔离机制" class="sidebar-link">MVCC多版本并发控制隔离机制</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#undo-log版本链" class="sidebar-link">undo log版本链</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#基于undo-log多版本链条实现的readview机制" class="sidebar-link">基于undo log多版本链条实现的ReadView机制</a></li><li class="sidebar-sub-header"><a href="/docs/mysql.html#read-committed隔离级别是如何基于readview机制实现的" class="sidebar-link">Read Committed隔离级别是如何基于ReadView机制实现的？</a></li></ul></li><li><a href="/docs/mysql2.html" class="sidebar-link">MySQL章节2</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JAVA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/thread.html" class="sidebar-link">多线程知识</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql章节1"><a href="#mysql章节1" class="header-anchor">#</a> MySQL章节1</h1> <h2 id="mysql物理数据存储格式"><a href="#mysql物理数据存储格式" class="header-anchor">#</a> MySQL物理数据存储格式</h2> <p><strong>一行数据在磁盘上是如何存储的？</strong><br>
这里涉及到一个概念，行格式。我们可以对一个表指定它的行存储格式是什么样的，比如COMPACT</p> <div class="language- extra-class"><pre class="language-text"><code>CREATE TABLE table_name(columns) ROW_FORMAT=COMPACT  
ALTER TABLE  table_name ROW_FORMAT=COMPACT  
</code></pre></div><p>你可以在建表的时候就指定行存储的格式，也可以建表后修改行存储的格式</p> <hr> <p><strong>每一行数据实际存储的时候，格式类似这样：</strong></p> <blockquote><p><em>变长字段的长度列表，null值列表，数据头，column01的值，column02的值，column0n的值....</em><br> <strong>行格式:</strong> 对于每行数据，他其实存储的时候都会有一些头字段对这行数据进行一定的描述，然后再放上这行数据每一列的具体的值。除了COMPACT意外，还有其他几种行存储格式，大同小异。</p></blockquote> <h2 id="变长字段在磁盘是怎么存储的"><a href="#变长字段在磁盘是怎么存储的" class="header-anchor">#</a> 变长字段在磁盘是怎么存储的</h2> <p>假设现在有一行数据，它有三个字段，分别是varchar(10),char(1),char(1),所以这行数据可能是hello a a，第一个字段的值是hello，第二和第三个字段都是a<br>
第二行数据，假设这行数据是hi a a，第一个字段是hi，后面两个字段是a<br>
假设把上面两行数据写入了一个磁盘文件里，两行数据是挨在一起的，那么这两行数据在磁盘里可能是hello a a hi a a<br> <strong>为什么变长字段难以读取</strong><br>
因为我们不知道变长字段的实际长度，所以需要引入<strong>变长字段的长度列表</strong><br>
比如你在存储hello a a的时候，需要带上一些额外的附加信息，第一块就是变长字段的长度列表<br>
hello字段长度是5，十六进制是0x05，在磁盘中存储格式是这样的：0x05 null值列表 数据头 hello a a<br>
hi字段长度是2，十六进制是0x02，在磁盘中存储格式是这样的：0x02 null值列表 数据头 hi a a<br> <strong>然后两行数据放在磁盘文件中格式如下：</strong><br>
0x05 null值列表 数据头 hello a a 0x02 null值列表 数据头 hi a a</p> <h3 id="多个变长字段-如何存储他们的长度"><a href="#多个变长字段-如何存储他们的长度" class="header-anchor">#</a> 多个变长字段，如何存储他们的长度</h3> <p>比如一行数据有五个字段，分别是varchar(10),varchar(5),varchar(20),char(1),char(1)<br>
这行数据是:<strong>hello hi hao a a</strong><br>
现在hello hi hao三个字段的长度分别是0x05,0x02,0x03，但是在<strong>实际存放变长字段长度列表的时候，是逆序放的</strong>，所以这行数据可能按下面的方式存放：<br> <em><strong>0x03 0x02 0x05 null值列表 数据头 hello hi hao a a</strong></em></p> <h2 id="null值是怎么存储的"><a href="#null值是怎么存储的" class="header-anchor">#</a> NULL值是怎么存储的？</h2> <p>如果一个字段是null，说明该字段什么都没有。如果存入null字符串的话太浪费空间了，解决方案如下：<br> <strong>NULL值以二进制bit位来存储</strong><br>
接下来看看NULL值列表在磁盘上到底如何存储？<br>
很简单，对于所有的NULL值，不通过字符串在磁盘上存储，而是通过二进制的bit位来存储，一行数据里假设多个字段都是NULL，那么这些字段的NULL是以bit位的形式存到了NULL值列表中。<br>
举个例子，假设有一张表，建表语句如下：</p> <div class="language- extra-class"><pre class="language-text"><code>CREATE TABLE customer(
  name VARCHAR(10) NOT NULL,
  address VARCHAR(20),
  gender CHAR(1),
  job  VARCHAR(30),
  school VARCHAR(50)
)
</code></pre></div><p>客户表有五个字段，分别代表姓名、地址、性别、工作和学校。4个变长字段，1个定长字段，其中name是不能为NULL的。<br>
现在我们假设有如下一行数据，“jack NULL m NULL xx_school”,其中5个字段2个是NULL<br>
针对上面假设的数据，我们有4个变长字段，按照前面说的，变长字段长度列表，我们是不是应该逆序存放name，address、job、school的长度？<br>
说起来是这样，但是我们要注意一个问题，变长字段的值可能是NULL，如果变长字段值为NULL，那么是不需要在变长字段长度列表中存放其长度的。如下所示：<br> <em>0x09 0x04 NULL值列表 头信息 column1=value1 column2=value2 ... columnN=valueN</em><br> <strong>NULL值列表存放的是所有允许为NULL的字段（不是说字段值为NULL，而是允许为NULL）</strong><br>
在NULL值列表中，存放的是二进制bit位，比如bit值是1，说明是NULL，如果bit值是0，说明不是NULL。<br>
比如上面四个字段（address，gender，job，school）都允许为null，“jack NULL m NULL xx_school”中两个字段是NULL，2个字段不是null，所以4个bit位应该是1010，但是<strong>实际存放NULL值列表的时候，是按照逆序存放的</strong>，放入的是0101。所以数据看着像下面所示：<br> <em>0x09 0x04 0101 头信息 column1=value1 column2=value2 ... columnN=valueN</em><br> <strong>另外，NULL值列表存放的时候不仅仅是4个bit位，至少要是8个bit位的倍数，如果不足8个bit位，需要在前面补0（高位补零），实际存放如下所示：</strong><br> <em>0x09 0x04 00000101 头信息 column1=value1 column2=value2 ... columnN=valueN</em></p> <h2 id="_40个bit位的数据头"><a href="#_40个bit位的数据头" class="header-anchor">#</a> 40个bit位的数据头</h2> <p>前两个bit位都是预留的，没有任何含义</p> <hr> <p>接下来一个bit位是<strong>delete_mask</strong>,标识这行数据是否被删除了。所以说mysql删除一条数据的时候，未必是立马把它从磁盘清理掉</p> <hr> <p>下一个bit为是<strong>min_rec_mask</strong>,B+树里每一层的非叶子节点里的最小值都有这个标记</p> <hr> <p>接下来4个bit位是<strong>n_owned</strong>,它记录了一个记录数，具体作用后续会讲</p> <hr> <p>接着有13个bit位是<strong>heap_no</strong>,它代表当前这行数据在记录堆里的位置，后续讲</p> <hr> <p>然后3个bit位是<strong>record_type</strong>,代表的是这行数据的数据类型，0-普通类型 1-B+树非叶子节点 2-最小值数据 3-最大值是数据</p> <hr> <p>最后16个bit位是<strong>next_record</strong>，是指向下一条数据的指针</p> <hr> <h2 id="数据在磁盘上是如何存储的"><a href="#数据在磁盘上是如何存储的" class="header-anchor">#</a> 数据在磁盘上是如何存储的</h2> <p>我们的数据是jack NULL m NULL xx_school，它实际存储格式如下：<br>
0x09 0x04 00000101 0000000000000000000000010000000000011001 jack NULL m NULL xx_school<br>
但是实际上不是怎么存储的，<strong>需要根据数据库指定的字符集编码，进行编码后再存储的</strong>，所以实际数据如下：<br>
0x09 0x04 00000101 0000000000000000000000010000000000011001 616161 636320 6262626262<br> <strong>其实这还不是最终的存储格式，真实数据里还有一些隐藏字段</strong></p> <hr> <p>首先有一个<strong>DB_ROW_ID</strong>字段，它是一个行的唯一标识，是数据库给你搞的一个唯一标识，不是你的主键ID字段。如果我们没有指定主键和unique key唯一索引的时候，它就内存自动加一个ROW_ID作为主键。</p> <hr> <p>接着是<strong>DB_TRX_ID</strong>字段，这是跟事务相关的，它是说这是哪个事务更新的数据，是事务的ID。</p> <hr> <p>最后是<strong>DB_ROLL_PTR</strong>字段，这是回滚指针，是用来进行事务回滚的。</p> <hr> <p>加上隐藏字段后，实际数据看起来可能如下：<br>
0x09 0x04 00000101 0000000000000000000000010000000000011001 00000000094c(DB_ROW_ID) 00000000032D(DB_TRX_ID) EA000010078E(DB_ROLL_PTR) 616161 636320 6262626262</p> <h2 id="行溢出"><a href="#行溢出" class="header-anchor">#</a> 行溢出</h2> <p>实际上我们的每行数据都是放在数据页中的，一个数据页默认大小是16kb，万一一行数据大小超过了16kb怎么办？<br>
比如一个表的字段大小是VARCHAR（65535），就是说最大可以包含65535个字符，也就是65535个字节，这就远远大于16kb的大小了。<br> <img src="/docs/assets/img/big_data.61ed42a5.png" alt="大字段存储" title="big_data.png"><br> <strong>行溢出</strong>：就是说一行数据存储的内容太多了，一个数据页都放不下了，此时只能溢出这个数据页，把数据溢出存放到其他数据页里，那些数据页就叫溢出页。<br> <strong>当我们在数据库里插入一条数据的时候，实际是在内存里插入一个有复杂存储结构的一行数据，然后随着一些条件的发生，这行数据会被刷入到磁盘中去。</strong></p> <h2 id="mysql数据页结构"><a href="#mysql数据页结构" class="header-anchor">#</a> mysql数据页结构</h2> <p><img src="/docs/assets/img/data_page.78ec5d7a.png" alt="数据页结构" title="data_page.png">
其中<strong>文件头</strong>占了38个字节，<strong>数据页头</strong>占了56个字节，<strong>最大记录和最小记录</strong>占了26个字节，<strong>数据行</strong>区域的大小是不固定的，<strong>空闲区域</strong>的大小也是不固定的，<strong>数据页目录</strong>的大小也是不固定的，然后<strong>文件尾部</strong>占了8个字节。<br> <strong>存放了多条数据后的数据页结构图如下：</strong><br>
如果数据页里面<strong>存满了数据，那么空闲区域就没了</strong><br> <img src="/docs/assets/img/data_page2.b7433bc4.png" alt="数据页满了的数据页结构" title="data_page2.png"></p> <h2 id="表空间"><a href="#表空间" class="header-anchor">#</a> 表空间</h2> <p><strong>表空间</strong>:其实我们创建的那些表都有一个表空间的概念，在磁盘上都会对应着“表名.ibd”这样的一个磁盘文件。<br> <em><strong>所以在物理层面，表空间就是对应一些磁盘上的数据文件。表空间对应的文件中是有很多数据页的。</strong></em><br>
一个表空间包含的数据页实在是太多了，不便于管理，所以在表空间中又引入了<strong>数据区</strong>的概念，英文是<strong>extend</strong><br>
一个数据区对应着连续的64个数据页，一个数据页是16kb，所以一个数据区是1MB，然后256个数据区就被划分为一组。<br> <strong>对于表空间而言，它的第一组数据区的的第一个数据区的前3个数据页，都是固定，里面存放了一些描述性的数据。3个数据页存放信息如下：</strong><br> <strong>FSP_HDR</strong>这个数据页，它里面存放了表空间和这一组数据区的一些属性。<br> <strong>IBUF_BITMAP</strong>这个数据页，里面存放的是这一组数据页的所有<strong>insert buffer</strong>信息。<br> <strong>INODE</strong>数据页，里面存放了一些特殊的信息<br> <strong>表空间的其他组数据区的第一个数据区的头两个数据页，也是存放特殊信息的。</strong></p> <h2 id="表空间的存储结构"><a href="#表空间的存储结构" class="header-anchor">#</a> 表空间的存储结构</h2> <p><img src="/docs/assets/img/table_space.8583f528.png" alt="表空间的结构" title="table_space.png"></p> <h2 id="插入一条数据"><a href="#插入一条数据" class="header-anchor">#</a> 插入一条数据</h2> <p>假设此时我们要插入一条数据，那么是选择磁盘文件里的哪个数据页加载到缓存页里去呢？<br>
因为我们知道要往哪个表里插入数据，所以可以得到表空间。找到表空间就可以找到对应的磁盘文件了（磁盘文件名为：表名.ibd）。有了磁盘文件后，可以从里面找一个extend组，找到一个extend，然后从里面找到一个数据页出来，这个数据页可能是空的，也可能已经有了一些数据了，然后就可以把这个数据页从磁盘里完整加载出来，放入Buffer Pool的缓存里。</p> <h2 id="磁盘随机读写和数据库日志顺序读写"><a href="#磁盘随机读写和数据库日志顺序读写" class="header-anchor">#</a> 磁盘随机读写和数据库日志顺序读写</h2> <p>磁盘结构及工作原理：<br> <a href="https://blog.csdn.net/rodbate/article/details/50371855" target="_blank" rel="noopener noreferrer">磁盘工作原理文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>因为你要读取的这个数据页可能在磁盘的任意一个位置，所以你在读取磁盘里的数据页的时候只能是用<strong>随机读</strong>的这种方式。</p> <p>磁盘随机读的性能是比较差的，所以不可能每次更新数据都进行磁盘随机读，必须是读取一个数据页之后放到Buffer Pool的缓存里去，下次要更新的时候直接更新Buffer Pool里的缓存页。</p> <p>对于磁盘随机读来说，主要关注的性能指标是IOPS和响应延迟<br>
所谓<strong>顺序写</strong>，就是说在一个磁盘日志文件里，一直在末尾追加日志</p> <p>磁盘顺序写的性能其实是很高的，某种程度上来说，几乎可以跟内存随机读写的性能差不多，尤其是在数据库里其实也用了os cache机制，就是redo log顺序写入磁盘之前，先是进入os cache，就是操作系统管理的内存缓存里</p> <p>所以对于这个写磁盘日志文件而言，最核心关注的是磁盘每秒读写多少数据量的吞吐量指标，就是说每秒可以写入磁盘100MB数据和每秒可以写入磁盘200MB数据，对数据库的并发能力影响也是极大的。</p> <p>因为数据库的每一次更新SQL语句，都必然涉及到多个磁盘随机读取数据页的操作，也会涉及到一条redo log日志文件顺序写的操作。所以磁盘读写的IOPS指标，就是每秒可以执行多少个随机读写操作，以及每秒可以读写磁盘的数据量的吞吐量指标，就是每秒可以写入多少redo log日志，整体决定了数据库的并发能力和性能。</p> <p>包括你磁盘日志文件的顺序读写的响应延迟，也决定了数据库的性能，因为你写redo log日志文件越快，那么你的SQL语句性能就越高。</p> <h2 id="linux存储系统架构图"><a href="#linux存储系统架构图" class="header-anchor">#</a> linux存储系统架构图**</h2> <p>linux存储系统分为VFS层、文件系统层、Page Cache缓存层、通用Block层、IO调度层、Block设备驱动层、Block设备层</p> <p><img src="/docs/assets/img/linux_file_system.7dfeb846.png" alt="Linux存储系统架构图" title="linux_file_system.png"></p> <p><strong>VFS层的作用</strong>：
根据你对哪个目录中的文件执行的磁盘IO操作，把IO操作交给具体的文件系统。</p> <p>当MySQL发起一次数据页的随机读写，或者是一次redo log日志文件的顺序读写的时候，实际上会把磁盘IO请求交给linux系统的<strong>VFS层</strong>处理。</p> <p>举个例子，在linux系统中，有的目录比如/xx1/xx2里的文件其实是由NFS文件系统管理的，有的目录比如/xx3/xx4里的文件其实是由Ext3文件系统管理的，那么这个时候VFS层会根据你对哪个目录下的文件发起的IO操作，把请求交给对应的文件系统。</p> <p>接着文件系统会在<strong>Page Cache缓存</strong>中查找你要找的数据在不在里面，如果存在，就基于内存缓存进行读写，如果没有就继续往下一层走，此时这个请求就会交给<strong>通用Block层</strong>，在这一层会把你对文件的IO请求转换成Block IO请求。</p> <p>接着会把这个Block IO请求交给<strong>IO调度层</strong>，在这一层默认是采用CFQ公平调度算法的。</p> <p><strong>CFQ公平调度算法</strong>，指的是假设你对数据库发起的多个sql语句同时在执行IO操作。有一个sql非常简单，update xx set xx1=xx2 where id =1;但是另一条sql语句是：select * from xx where xx1 like '%xx%',可能需要读取磁盘上大量的数据。此时基于公平调度算法，可能会导致先执行第二个sql语句，这个操作耗时很久，然后第一个sql语句一直得不到执行的机会。</p> <p><strong>扩展知识</strong>：
NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。<br>
它的用途：网络上与他人共享目录和文件。</p> <h3 id="mysql生产调优经验"><a href="#mysql生产调优经验" class="header-anchor">#</a> <font color="#FF0000" size="4">mysql生产调优经验</font></h3> <p>所以这里，<font color="#0000FF" size="4">建议mysql生产中，需要调整为deadline IO调度算法</font>。他的核心思想是任何一个IO操作都不能一直等待，在指定的时间范围内，都必须让它执行。</p> <p>IO调度完成之后，会决定哪个IO请求先执行，哪个IO请求后执行。此时可以执行的IO请求就会交给<strong>Block设备驱动层</strong>，然后经过驱动把IO请求发送给真正的存储硬件，也就是<strong>Block设备层</strong><br>
然后硬件设备完成了IO读写操作之后，会把响应结果按照上图反向依次返回，最终MySQL可以得到本次IO读写操作的结果。</p> <h2 id="数据库服务器的raid存储架构初步介绍"><a href="#数据库服务器的raid存储架构初步介绍" class="header-anchor">#</a> 数据库服务器的RAID存储架构初步介绍</h2> <p>mysql、linux和硬件（cpu、内存、磁盘、网卡）的关系
<img src="/docs/assets/img/mysql_linux.eb6cdaaa.png" alt="mysql linux 硬件" title="mysql_linux.png"></p> <p>一般来说，很多数据库部署在机器上的时候，存储都是搭建的RAID存储架构。<strong>RAID就是一个磁盘冗余阵列</strong></p> <p>假设我们的服务器里的磁盘就一块，那万一 一块磁盘的容量不够怎么办？此时是不是就可以再搞几块磁盘出来放在服务器里</p> <p>现在多搞了几块磁盘，机器里有很多块磁盘了，不好管理啊，怎么在多块磁盘上存放数据呢？</p> <p>所以就是针对这个问题，在存储层面往往会在机器里搞多块磁盘，然后引入<strong>RAID这个技术，大致理解为用来管理机器里的多块磁盘的一种磁盘阵列技术！</strong> <font color="#0000FF" size="4">有了RAID以后，你在往磁盘里读写数据的时候，他会告诉你应该在哪块磁盘上读写数据</font>
当我们往磁盘里写数据的时候，通过RAID技术可以帮助我们选择一块磁盘写入，在读取数据的时候，我们也知道从哪块磁盘去读取。
<img src="/docs/assets/img/linux_RAID.8eb97e5b.png" alt="RAID架构"></p> <p>RAID技术另一个很重要的一个作用，就是他还可以<strong>实现数据冗余机制</strong></p> <p>所以其实有的RAID磁盘冗余阵列技术里，是可以把你写入的同样一份数据，在两块磁盘上都写入的，这样可以让两块磁盘上的数据一样，作为冗余备份，然后当你一块磁盘坏掉的时候，可以从另外一块磁盘读取冗余数据出来，这一切都是RAID技术自动帮你管理的，不需要你操心，如下图。
<img src="/docs/assets/img/linux_raid2.ded68e4b.png" alt="RAID架构"></p> <h2 id="数据库服务器上的raid存储架构的电池充放电原理"><a href="#数据库服务器上的raid存储架构的电池充放电原理" class="header-anchor">#</a> 数据库服务器上的RAID存储架构的电池充放电原理</h2> <p>服务器使用多块磁盘组成的RAID阵列的时候，一般会有一个RAID卡，这个RAID卡是带有一个缓存的，这个缓存不是我们服务器的主内存那种，而是跟内存类似的SDRAM，其实类似于内存。</p> <p>然后我们可以把RAID的缓存模式设置为write back，这样的话，所有写入到磁盘阵列的数据，会先缓存在RAID卡的缓存里，后续会慢慢写入到磁盘阵列中去，这种写缓冲机制，可以大幅度提升我们数据库磁盘写的性能。
RAID架构-SDRAM缓存架构图：
<img src="/docs/assets/img/Raid_SDRAM.44870179.png" alt="RAID架构-SDRAM缓存" title="Raid_SDRAM.png"></p> <p><strong>假如突然断电了，RAID卡的缓存里的数据会不会突然丢失？</strong>
为了解决这个问题，RAID卡一般都配有自己独立的锂电池或者是电容，如果遇到断电，会由自己的锂电池来供电运行，然后它会赶紧把输入写入到阵列中的磁盘上去。
RAID架构-SDRAM缓存（锂电池）
<img src="/docs/assets/img/Raid_SDRAM2.d75635d7.png" alt="SDRAM缓存和锂电池" title="Raid_SDRAM2.png">
但是锂电池是存在性能衰减问题的，所以一般来说锂电池都是要配置定时充放电的，也就是说每隔30~90天（锂电池厂商来定），就会自动对锂电池充放电一次，这样可以延长锂电池的寿命和校准电池容量。</p> <p>在锂电池充放电的过程中，RAID的缓存级别会从write back变成write throuth，我们通过RAID写数据的时候，IO就直接写磁盘了，如果写内存是0.1ms这个级别，那么写磁盘就会退化10倍，到毫秒级别了。</p> <p><strong>所以一旦RAID自动充放电，往往会导致你的数据库服务器的RAID存储定期的性能出现几十倍的抖动，间接导致你的数据库性能每隔一段时间就会出现几十倍的抖动</strong></p> <h2 id="raid锂电池充放电导致的mysql数据库性能抖动的优化"><a href="#raid锂电池充放电导致的mysql数据库性能抖动的优化" class="header-anchor">#</a> RAID锂电池充放电导致的MySQL数据库性能抖动的优化</h2> <p><strong>RAID 0</strong>指的是所有的数据都是分散写入不同的磁盘，因为有多快磁盘，所以你的磁盘阵列的整体容量就很大，而且同时写入多块磁盘，让你的磁盘读写并发能力很强。
<strong>RAID 0的缺点</strong>：但是这种模式下，最大的问题就是万一你磁盘坏了一块，那么就会丢失一部分数据了。一般如果你要严格保证磁盘数据不丢失的话，就得用RAID 1。</p> <p><strong>RAID 1</strong>指的是两块磁盘为镜像关系，你写的所有数据，在两块磁盘上都有，形成了数据冗余，一块磁盘坏了，另外一块磁盘上还有数据。</p> <p><strong>RAID 10</strong>，就是RAID 0 + RAID 1组合起来，就是说当时生产环境的服务器部署，我们有6块磁盘组成了一个RAID 10的阵列，那么其实就是每2块磁盘组成一个RAID 1互为镜像的架构，存放的数据是冗余一样的，一共有3组RAID 1，然后对于每一组RAID 1写入数据的时候，是用RAID 0的思路，就是不同组的磁盘的数据是不一样的，但是同一组内的两块磁盘的数据是冗余一致的，如下图。</p> <p>RAID10架构图：
<img src="/docs/assets/img/Raid_SDRAM.png3.dae573fe.png" alt="RAID10技术" title="Raid_SDRAM.png3.png"></p> <p>所以对于这样的一个使用了RAID 10架构的服务器，他必然内部是有一个锂电池的，然后这个锂电池的厂商设定的默认是30天进行一次充放电，每次锂电池充放电就会导致RAID写入时不经过缓存，性能会急剧下降，所以我们发现线上数据库每隔30天就会有一次剧烈性能抖动，数据库性能下降了10倍。</p> <h2 id="生产优化-锂电池充放电导致性能抖动的三种解决方案"><a href="#生产优化-锂电池充放电导致性能抖动的三种解决方案" class="header-anchor">#</a> 生产优化：锂电池充放电导致性能抖动的三种解决方案：</h2> <p>给RAID卡把锂电池换成电容，电容是不用频繁充放电的，不会导致充放电的性能抖动，还有就是电容可以支持透明充放电，就是自动检查电量，自动进行充电，不会说在充放电的时候让写IO直接走磁盘，但是更换电容很麻烦，而且电容比较容易老化，这个其实一般不常用</p> <p><strong>手动充放电，这个比较常用</strong>，包括一些大家知道的顶尖互联网大厂的数据库服务器的RAID就是用了这个方案避免性能抖动，<strong>就是关闭RAID自动充放电，然后写一个脚本，脚本每隔一段时间自动在晚上凌晨的业务低峰时期，脚本手动触发充放电</strong>，这样可以避免业务高峰期的时候RAID自动充放电引起性能抖动</p> <p>充放电的时候不要关闭write back，就是设置一下，锂电池充放电的时候不要把缓存级别从write back修改为write through，这个也是可以做到的，可以和第二个策略配合起来使用</p> <h2 id="生产实战-数据库无法连接故障的定位-too-many-connections"><a href="#生产实战-数据库无法连接故障的定位-too-many-connections" class="header-anchor">#</a> 生产实战：数据库无法连接故障的定位，Too many connections**</h2> <p>异常信息是：ERROR 1040(HY000):Too many connections.<br>
含义是说数据库连接池里已经有太多的连接了，不能在跟你建立新的连接了。<br>
我们的数据库部署在64GB的大物理机上，配置很高。然后java系统有两个，分别部署在两个机器上，java系统设置连接池的最大大小是200，那两个机器就是最大400个连接。
<img src="/docs/assets/img/mysql_connection.a1883a28.png" alt="java连接数据库">
但是这个时候mysql报异常说：too many connections，难道mysql400个连接都没有？接着去检查mysql的配置文件，my.cnf,里面有个关键参数max_connections,就是mysql设置的最大连接数，是800.
为什么mysql最大连接数是800，两台机器要建立400个连接都不行呢？
用命令行或者一些管理工具登录到mysql上去，执行下面的命令看看：<br> <strong>show variables like 'max_connections'</strong><br>
此时你可以看到，mysql仅仅建立了214个连接。<br>
这时可以猜想，mysql启动时，根本没管我们设置的那个max_connections，就直接强行把最大连接数设置为214了？于是去检查了一下mysql的启动日志，可以看到如下字样：
<img src="data:image/png;base64,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" alt="mysql启动日志" title="max_connections.png"> <strong>原因</strong>：<font color="FF0000" size="4">底层的linux把进程可以打开的文件句柄数限制为了1024了，导致mysql的最大连接数是214了。</font> <img src="/docs/assets/img/max_connection_reason.c38859d8.png" alt="mysql最大连接数" title="max_connection_reason.png"></p> <h2 id="生产实战-如何解决经典的too-many-connections故障"><a href="#生产实战-如何解决经典的too-many-connections故障" class="header-anchor">#</a> 生产实战：如何解决经典的Too many connections故障？</h2> <p>解决方案：就是下面的一行命令<br> <font color="FF0000" size="4">ulimit -HSn 65535</font><br>
然后使用如下的命令检查最大文件句柄数是否被修改了：<br>
cat /etc/security/limits.conf<br>
cat /etc/rc.local<br>
最后重启mysql即可，里面配置的最大连接数就会生效了。</p> <p>另外再给大家解释一个问题，有人还是疑惑说，为什么linux的最大文件句柄限制为1024的时候，MySQL的最大连接数是214呢？</p> <p>这个其实是MySQL源码内部写死的，他在源码中就是有一个计算公式，算下来就是如此罢了！</p> <p>然后再给大家说一下，这个linux的ulimit命令是干嘛用的，其实说白了，linux的话是默认会限制你每个进程对机器资源的使用的，包括可以打开的文件句柄的限制，可以打开的子进程数的限制，网络缓存的限制，最大可以锁定的内存大小。</p> <p>因为linux操作系统设计的初衷，就是要尽量避免你某个进程一下子耗尽机器上的所有资源，所以他默认都是会做限制的。</p> <p>所以说，往往你在生产环境部署了一个系统，比如数据库系统、消息中间件系统、存储系统、缓存系统之后，都需要调整一下<strong>linux的一些内核参数，这个文件句柄的数量是一定要调整的，通常都得设置为65535</strong></p> <p><font color="FF0000" size="4">可以用ulimit命令来设置每个进程被限制使用的资源量，用ulimit -a就可以看到进程被限制使用的各种资源的量</font></p> <p>比如 core file size 代表的进程崩溃时候的转储文件的大小限制，max locked memory就是最大锁定内存大小，open files就是最大可以打开的文件句柄数量，max user processes就是最多可以拥有的子进程数量。</p> <p>设置之后，我们要确保变更落地到/etc/security/limits.conf文件里，永久性的设置进程的资源限制</p> <p>所以执行ulimit -HSn 65535命令后，要用如下命令检查一下是否落地到配置文件里去了。</p> <p>cat /etc/security/limits.conf<br>
cat /etc/rc.local</p> <h2 id="redo日志对于事务提交后-数据绝对不会丢失的意义"><a href="#redo日志对于事务提交后-数据绝对不会丢失的意义" class="header-anchor">#</a> redo日志对于事务提交后，数据绝对不会丢失的意义</h2> <p><strong>redo log的本质</strong>是保证事务提交之后，修改的数据绝对不会丢失。<br> <img src="/docs/assets/img/buffer_pool_load_data.60854021.png" alt="数据页-&gt;缓存页" title="buffer_pool_load_data.png"></p> <p>其实你更新缓存页的时候，会更新free链表、flush链表、lru链表，然后有专门的后台IO线程，不定时的根据flush链表、lru链表，把你更新的数据刷新到磁盘文件中去。</p> <p><font color="FF0000" size="5">事务提交时把修改过的缓存页都刷入磁盘和你事务提交时把你做的修改的redo log写入日志文件的区别在哪里，他们不都是写入磁盘吗？</font>
实际上如果把你修改过的缓存页都刷入磁盘，<strong>一个缓存页大小是16kb，数据比较大，刷入磁盘比较耗时</strong>，而且可能只修改了缓存页的几个字节的数据，你要把整个缓存页都刷入磁盘吗？<br> <strong>刷入磁盘是随机写入磁盘，性能很差的</strong>，因为一个缓存页对应的位置可能在磁盘文件的一个随机位置，比如偏移量为45336这个地方。<br> <strong>如果是写redo log日志</strong>，<br> <strong>第一点</strong>：redo log可能就占几十个字节，就包含表空间号、数据页号、磁盘文件偏移量、更新值，这个写入磁盘速度很快。<br> <strong>第二点</strong>：redo log写日志，是顺序写入磁盘文件，每次都是追加到磁盘文件末尾去，速度也是很快的。<br> <font color="FF0000" size="4">总结：所以你提交事务的时候，用redo log形式记录下来你所做的修改，性能远远超过刷新缓存页的方式，可以使你的数据库并发能力更强</font></p> <h2 id="redo-log日志结构"><a href="#redo-log日志结构" class="header-anchor">#</a> redo log日志结构</h2> <p>redo log本质上是记录了对某个表空间的某个数据页的某个偏移量的地方修改了几个字节的值，具体修改的值是什么。<br>
他里面需要记录的就是<strong>表空间号+数据页号+偏移量+修改几个字节的值+具体的值</strong></p> <p>所以根据你修改了数据页里的几个字节的值，redo log就划分为了不同的类型，MLOG_1BYTE类型的日志指的就是修改了1个字节的值，MLOG_2BYTE类型的日志指的就是修改了2个字节的值，以此类推，，还有修改了4个字节的值的日志类型，修改了8个字节的值的日志类型。</p> <p>如果你要是一下子修改了一大串的值，类型就是MLOG_WRITE_STRING，就是代表你一下子在那个数据页的某个偏移量的位置插入或者修改了一大串的值。</p> <p><strong>redo log日志大致的结构如下所示</strong>：<br>
日志类型（MLOG_1BYTE等），表空间ID，数据页号，数据页中的偏移量，具体修改的数据</p> <hr> <p><strong>日志类型就告诉了你他这次增删改操作修改了多少字节的数据</strong>，有了上述信息，就可以精准完美的还原出来一次数据增删改操作做的变动了。</p> <p>只不过如果是MLOG_WRITE_STRING类型的日志，因为不知道具体修改了多少字节的数据，所以其实会多一个修改数据长度，就告诉你他这次修改了多少字节的数据，如下所示他的格式：</p> <p><strong>日志类型（MLOG_WRITE_STRING）</strong>，表空间ID，数据页号，数据页中的偏移量，<strong>修改数据长度</strong>，具体修改的数据</p> <h2 id="redo-log是一条一条写入日志文件的吗-非也"><a href="#redo-log是一条一条写入日志文件的吗-非也" class="header-anchor">#</a> redo log是一条一条写入日志文件的吗，非也</h2> <p>其实在mysql内部有另一个数据结构，叫做<strong>redo log block</strong>，它可以存放多个单行日志。<br> <strong>redo log block结构图：</strong><br>
一个redo log block是512个字节，总共分为3部分：<br>
第一部分：12个字节的header（块头）<br>
块头分为四部分：<br>
1, 4个字节的block_no，就是块唯一编号
2，2个字节的data length，就是block里写入了多少字节的数据
3，2个字节的first record group，这个是说每个事务会有多个redo log，是一个redo log group，即一组redo log。那么在这个block里的第一组    redo log的偏移量，就是这2个字节存储的。<br>
4，4个字节的checkpoint on<br>
第二部分：496个字节的body（块体）<br>
第三部分：4个字节的trailer（块尾）<br> <img src="/docs/assets/img/redo-log-block.8b4f5554.png" alt="redo log block结构图" title="redo-log-block.png"></p> <p>细化header的redo log block结构图：<br> <img src="/docs/assets/img/redo-log-block-header.cbdadb33.png" alt="有header的redo log block结构图" title="redo-log-block-header.png"></p> <p>假设你要写第一个redo log了，是不是首先要在内存里把这个redo log给弄到一个redo log block数据结构中去？<br>
然后等你的512个字节的redo log block的数据都满了，再一次性把这个redo log block给写入到磁盘文件中。那么此时redo log文件里就多了一个block。<br> <img src="/docs/assets/img/redo_log_block_file.3145e443.png" alt="redo log日志文件中block结构" title="redo_log_block_file.png"><br> <img src="/docs/assets/img/redo_log_block_modify.4cccb9bd.png" alt="redo log日志文件中block结构" title="redo_log_block_modify.png"></p> <h2 id="redo-log是直接写入磁盘文件吗"><a href="#redo-log是直接写入磁盘文件吗" class="header-anchor">#</a> redo log是直接写入磁盘文件吗？</h2> <p>不是的，需要用到一个组件redo log buffer。它就是MySQL专门设计的，用来缓冲redo log写入的。<br> <strong>redo log buffer是MySQL在启动的时候，申请的一块连续的内存，里面划分出了N多个redo log block，如下图所示</strong>：<br> <img src="/docs/assets/img/redo_log_buffer.d5a0ab43.png" alt="redo log buffer结构" title="redo_log_buffer.png"> <font color="FF0000" size="4">通过设置innodb_log_buffer_size可以指定redo log buffer的大小，默认值是16M，已经很大了，毕竟一个redo log block才512个字节 </font></p> <p>当我们要写一条redo log的时候，就会先从redo log block开始写入，写满一个redo log block，再接着写下一个，当所有的redo log block都写满了，那么此时必然会强制把redo log block刷入到磁盘中去。<br> <img src="/docs/assets/img/redo_log_buffer_file.5a90fb5b.png" alt="redo log buffer刷入磁盘" title="redo_log_buffer_file.png"><br>
需要注意一点，我们平时执行一个事务的过程中，每个事务会有多个增删改查操作，那么就会有多个redo log，这些属于一个事务的redo log就是一组redo log。<br>
其实每次这一组redo log都是在别的地方暂存，都执行完了，才会把这组redo log给写入到redo log buffer 的block中去。<br> <strong>redo log太多一个block放不下的情形：</strong> <img src="/docs/assets/img/redo_log_block_many_log.ddf5c1e5.png" alt="redo log太多一个block放不下的情形" title="redo_log_block_many_log.png"><br> <strong>redo log太小挤到一个block中的情形：</strong><br> <img src="/docs/assets/img/redo_log_block_little_log.c2c8d814.png" alt="redo log太小挤到一个block中的情形" title="redo_log_block_little_log.png"></p> <h2 id="redo-log-buffer中的缓冲日志-到底什么时候可以写入磁盘"><a href="#redo-log-buffer中的缓冲日志-到底什么时候可以写入磁盘" class="header-anchor">#</a> redo log buffer中的缓冲日志，到底什么时候可以写入磁盘？</h2> <p><strong>redo log block刷入到磁盘中的时机有如下几种：</strong><br>
（1）如果写入redo log buffer中的日志已经占据了redo log buffer总容量的一半了，也就是超过了8M的redo log 在缓冲里，此时就会把他们刷入磁盘文件中去<br>
（2）一个事务提交的时候，必须把它的那些redo log所在的redo log block都刷入到磁盘文件里去。因为只有这样，当事务提交的时候，他修改的数据绝对不会丢失，因为redo log里面有重做日志，随时可以恢复事务做的修改。<br> <img src="/docs/assets/img/os_cache.ab88ec0b.png" alt="redo log-os cache" title="os_cache.png">
（3）后台线程定时刷新，有一个后台线程每隔1s就会把redo log buffer里的redo log block刷到磁盘文件里去<br>
（4）MySQL关闭的时候，redo log block都会刷入到磁盘文件中去。<br> <strong>总结：不管怎么说，都是为了保证一个事务执行的时候，redo log都进入redo log buffer，事务提交的时候，事务对应的redo log必须刷入磁盘文件，接着才算是事务提交成功，否则事务提交就是失败。保证这一点，就是保证了事务提交之后，数据不会丢失，有redo log在磁盘文件里就行了。</strong><br>
还得配置一个参数，提交事务把redo log刷入磁盘文件的os cache后，还得强行从os cache刷入物理磁盘。</p> <p><font color="FF0000" size="4">是把所有的redo log日志文件都写入到同一个日志文件中吗？对磁盘占用空间越来越大怎么办？</font><br>
实际上默认情况下，redo log都会写入同一个目录的文件中，这个目录可以通过 <font color="FF0000" size="4">show variables like 'datadir'</font> 来查看,可以通过<font color="FF0000" size="4">innodb_log_group_home_dir</font>参数来设置这个目录，然后redo log文件是有多个的，写满一个，会写下一个redo log文件，通过<font color="FF0000" size="4">innodb_log_file_size</font>可以指定每个redo log文件的大小，默认是48M，通过<font color="FF0000" size="4">innodb_log_files_in_group</font>指定日志文件的数量，默认就2个。</p> <p>所以默认情况下，目录里就两个日志文件，分别是ib_logfile0和ib_logfile1，每个48M，如果两个文件都写满了，那么会重新开始写第一个文件，覆盖原来的内容。所以MySQL最多会保留最近的96M的redo log。一个redo log几个字节到几十个字节不等，96M足够你存储上百万的redo log了。</p> <h2 id="事务执行到一半要回滚怎么办-再探undo-log回滚日志原理"><a href="#事务执行到一半要回滚怎么办-再探undo-log回滚日志原理" class="header-anchor">#</a> 事务执行到一半要回滚怎么办，再探undo log回滚日志原理！</h2> <p>undo log日志，也就是回滚日志，这种日志要应对的场景，就是事务回滚的场景。<br> <strong>一个事务里的一通增删改执行到一半，需要回滚，怎么办？</strong><br> <img src="/docs/assets/img/undo_log.e96af5aa.png" alt="redo log做到一半需要回滚示意图" title="undo_log.png"></p> <p><strong>undo log日志记录的东西</strong>其实非常简单，如果你在缓存页里执行了一个insert语句，那么此时你在undo log日志里需要记录这条记录的主键和一个delete语句，能让你把这次操作给回退了。</p> <p>如果你在缓存页里执行的是delete语句，那么你要把删除的那条数据记录下来，如果要回滚，执行一个insert操作，把那条数据插入回去。</p> <p>如果你在缓存页里执行的是update语句，那么你起码要把更新前的那个值记录下来，回滚的时候重新update一下，把你之前更新前的旧值给更新回去。<br> <img src="/docs/assets/img/undo_log_structure.6195a0dd.png" alt="undo log示意图" title="undo_log_structure.png"></p> <h2 id="insert语句的undo-log回滚日志长什么样"><a href="#insert语句的undo-log回滚日志长什么样" class="header-anchor">#</a> insert语句的undo log回滚日志长什么样？</h2> <p>Insert语句的undo log的类型是<strong>TRX_UNDO_INSERT_REC</strong>,主要包含以下一些东西：</p> <blockquote><p>. 这条日志的开始位置<br>
. 主键的各列长度和值<br>
. 表ID<br>
. undo log日志编号<br>
. undo log日志类型<br>
. 这条日志的结束位置</p></blockquote> <p>主键的各列长度和值：主键可能是联合主键，有多个字段，比如&quot;id+name+type&quot;组成，记录了各列的长度和对应的值。即使你没有设置主键，MySQL也会弄一个db_row_id隐藏字段，作为你的主键。</p> <p>表ID：你往表里插入数据，必须要有一个表ID，记录下来是在哪个表里插入的数据。</p> <p>undo log日志编号：就是说每个undo log都有自己的编号。<br>
一个事务中会有多个SQL语句，就会有多个undo log日志，在每个事务里undo log日志的编号都是从0开始的，然后依次递增。</p> <p>undo log日志类型：INSERT语句的undo log类型就是TRX_UNDO_INSERT_REC。<br>
undo log结构:<br> <img src="/docs/assets/img/undo_log_structure2.f9da4ac8.png" alt="undo log结构" title="undo_log_structure2.png"></p> <p>然后在undo log里就知道在哪个表插入的数据，主键是什么，直接定位到那个表和主键对应的缓存页，从里面删除之前insert语句插入进去的数据就行了，这样就可以是先数据回滚的效果了。</p> <h2 id="mysql运行时多个事务同时执行是什么场景"><a href="#mysql运行时多个事务同时执行是什么场景" class="header-anchor">#</a> MySQL运行时多个事务同时执行是什么场景？</h2> <p><font color="FF0000" size="4">多个事务并发执行的时候可能同时会对缓存页里的一行数据进行更新，这个冲突怎么处理？是否要加锁？</font><br> <font color="FF0000" size="4">可能有的事务在对一行数据做更新，有的事务在查询这行数据，这里的冲突怎么处理？</font></p> <h2 id="脏写和脏读"><a href="#脏写和脏读" class="header-anchor">#</a> 脏写和脏读</h2> <p><strong>多个事务并发更新以及查询数据，为什么会有脏写和脏读的问题？</strong>
如果多个事务要对缓存页里的同一条数据进行更新或者查询，此时会产生哪些问题呢？<br>
会导致<strong>脏写、脏读、不可重复读、幻读</strong></p> <h3 id="脏写"><a href="#脏写" class="header-anchor">#</a> 脏写</h3> <p>脏写：如果有两个事务，事务A和事务B同时在更新一条数据，事务A先把它的值更新为A值，然后事务B紧接着把它的值更新为了B，如下图所示：<br> <img src="/docs/assets/img/zang_write.f65430f9.png" alt="脏写场景" title="zang_write.png"><br>
事务A更新之后会记录一条undo log日志，在事务A更新之前，这条数据的字段值是NULL，是吧？<br>
所以事务A的undo log日志大概是：更新之前字段值为NULL，主键为XX。</p> <p>然后事务B把字段的值更新为了B，结果此时事务A突然回滚了，那么他就会用他的undo log去回滚。</p> <p>此时事务A一回滚，直接就把该行数据的字段值更新为了NULL！A回滚后，看起来这行数据的值就是NULL，如下图所示:<br> <img src="/docs/assets/img/undo_log_rollback.c4831cdb.png" alt="脏写回滚示意图" title="undo_log_rollback.png"><br>
事务B一看，我擦，我更新的数据呢，为什么没了？难道就因为你事务A回滚了搞的我更新的B值也没了，这也太坑爹了吧！<br>
所以对于事务B看到的场景，就是自己明明更新了，结果值却没了，<strong>这就是脏写</strong>。</p> <h3 id="脏读"><a href="#脏读" class="header-anchor">#</a> 脏读</h3> <p>假设事务A更新了一行数据的值为A值，此时事务B去查询了一下这行数据的值，此时B看到的是事务A更新的A值。此时如下图所示：<br> <img src="/docs/assets/img/undo_log_zang_du.fa602df1.png" alt="更新后正常读的场景图" title="undo_log_zang_du.png"><br>
现在事务B拿着刚才查询到的A值去做各种业务处理，但是接着坑爹的事情发生了，事务A突然回滚了事务，导致他刚才更新的A值没了，此时那行数据的值回滚为NULL值。<br>
然后事务B紧接着再次查询那行数据的值，看到的居然是NULL值？B真的是欲哭无泪，看下图：<br> <img src="/docs/assets/img/undo_log_read_rollback.7b96f40c.png" alt="读未提交" title="undo_log_read_rollback.png"></p> <p><strong>脏读：他的本质就是事务B去查询了事务A修改过的数据，但是事务A还未提交，如果事务A回滚了，那么事务B再次查询就查不到刚才事务A修改的数据了！</strong></p> <h2 id="不可重复读和幻读"><a href="#不可重复读和幻读" class="header-anchor">#</a> 不可重复读和幻读</h2> <h3 id="不可重复读"><a href="#不可重复读" class="header-anchor">#</a> 不可重复读</h3> <p>在不会发生脏读的情况下，有可能会发送不可重复读的问题。<br>
假设缓存页里一条数据原来的值是A，此时事务A开启之后，第一次查询这条数据，读取到的就是A值。<br>
接着事务B更新了那行数据的值为B，同时事务B立马提交了，注意此时事务A还没有提交。</p> <p>事务A在事务执行期间第二次查询数据，查询到的是事务B修改后的数据，因为事务B已经提交了事务，所以事务A可以读到事务B更新后的值。</p> <p>紧接着事务C再次更新数据为C值，事务C立马提交了，此时事务A在未提交的情况下，第三次查询数据，查询到的是C值。
不可重复读的示意图如下：<br> <img src="/docs/assets/img/cannot_repeat_read.a0876db9.png" alt="不可重复读" title="cannot_repeat_read.png"></p> <p>要说上面的步骤没有问题，也可以说没问题，因为B和C提交了之后，A读取到修改后的值，是没问题的。<br>
要说有问题，也是有问题的。就是事务A在事务执行期间，希望多次查询查到都是相同的值。就是说他希望这行数据的值是可以重复读的。</p> <h3 id="幻读"><a href="#幻读" class="header-anchor">#</a> 幻读</h3> <p>幻读：简单来说，你一个事务A发送了一条sql语句查询数据，比如“select * from xx where id&gt;10”,第一次查询的时候，查出来10条数据；
接着这个时候另一个事务B向表里插入了2条数据，而且事务B还提交了事务。接着事务A第二次查询，用同样的sql查到了12条数据。事务A开始怀疑人生了，为什么第一次查询出来的是10条，第二次查询出来的是12条？难道出现了幻觉，这就是幻读名次的由来。</p> <p><strong>幻读</strong>：指的是在一个事务中多次查询，你查询到了之前查询没有看到的数据！</p> <p>总结：脏写、脏读、不可重复读、幻读，都是因为业务系统会多线程并发执行导致的，因为每个线程都可能会开启一个事务，每个事务都会执行增删改查操作。</p> <p>然后数据库会并发执行多个事务，多个事务可能会并发的对缓存页里的同一批数据进行增删改查操作，然后这个并发的增删改查同一批数据，就会导致前面说的脏写、脏读、不可重复读和幻读的问题。</p> <p><strong>所以这些问题的本质就是多事务并发执行的问题，那么为了解决多事务并发执行问题，数据库才设计了事务隔离机制、MVCC多版本隔离机制、锁机制，用一整套机制来解决多事务并发问题。</strong></p> <h2 id="数据库四种隔离级别"><a href="#数据库四种隔离级别" class="header-anchor">#</a> 数据库四种隔离级别</h2> <p>四个隔离级别包括：
read uncommitted（读未提交）、read committed（读已提交）、repeatable read（可重复读）、serializable（串行化）<br>
不同的隔离级别可以避免不同的事务并发问题。</p> <p>第一个级别，读未提交，是不允许发生脏写的。
因为读未提交保证了，不会有两个事务在没提交的情况下去更新同一行数据的值。但是可能会导致脏读、不可重复读、幻读问题。</p> <p>第二个级别是读已提交，是不允许脏写和脏读的。<br>
它保证了你一定不会读到别人未提交情况下修改的值。可能会导致不可重复读、幻读问题。</p> <p>第三个级别是可重复读，是不允许脏写、脏读、不可重复读。
因为这个级别保证了，你一个事务多次查询同一个数据的值，哪怕别的事务修改了这个数据的值并提交了，你也不会读到他修改后的值，每次都会读取到同一个值。</p> <p>第四个隔离级别是串行化，不会发生任何并发问题，因为是串行执行，不存在并发问题。但是也不会有人把数据库设置为这个级别的。</p> <p><font color="FF0000" size="4">MySQL的默认事务隔离级别是RR（可重复读），而且MySQL的RR级别可以避免幻读发生。</font></p> <h2 id="mvcc多版本并发控制隔离机制"><a href="#mvcc多版本并发控制隔离机制" class="header-anchor">#</a> MVCC多版本并发控制隔离机制</h2> <p>MySQL的RR（可重复读）级别之所以可以避免脏写、脏读、可重复读和幻读，是因为它采用了MVCC多版本并发控制隔离机制。<br> <strong>如何修改MySQL默认的事务隔离级别？</strong><br>
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level3<br>
level3的值为：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE</p> <p><strong>spring的@Transactional注解调整事务隔离级别</strong><br>
@Transactional(isolation=Isolation.DEFAULT)，然后你可以改成其它值， 比如Isolation.READ_UNCOMMITTED、Isolation.READ_COMMITTED等</p> <h2 id="undo-log版本链"><a href="#undo-log版本链" class="header-anchor">#</a> undo log版本链</h2> <p>我们的每条数据都有两个隐藏字段，一个是trx_id,一个是roll_pointer,这个trx_id就是最近更新这条数据的事务ID，roll_pointer指向了你更新这条数据之前生成的undo log。<br>
举个例子：现在假设有个事务A（id=50），这个事务插入一条数据，插入的这条数据的值是A，因为事务A的id是50，所以rtx_id=50，roll_pointer指向一个空的undo log，因为这条数据之前是没有的。这条数据的隐藏字段及roller_pointer如下图所示：<br> <img src="/docs/assets/img/trx_id_roll_pointer.164686ba.png" alt="插入数据的隐藏字段示意图" title="trx_id_roll_pointer.png"></p> <p>接着假设有一个事务B跑来更新了一下这个数据，把值改为了B，事务B的id是58，那么更新之前会生成一个undo log记录之前的值，然后让roll_pointer指向这个实际的undo log回滚日志，如下图所示：
<img src="/docs/assets/img/trx_id_update.e8432a3f.png" alt="更新数据的隐藏字段示意图" title="trx_id_update.png"></p> <p>接着假设事务C又来修改了一下值为C，它的事务id是69，此时会把数据行的trx_id修改为69，然后生成一条undo log，记录之前事务B修改的那个值B，如下图：
<img src="/docs/assets/img/trx_id_update_c.c6f684b3.png" alt="更新数据的隐藏字段示意图" title="trx_id_update_c.png"></p> <p><strong>大家先不管多个事务并发执行是如何执行的，起码要先搞清楚一点，就是多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏字段trx_id和roll_pointer，同时之前多个数据快照对应的undo log，会通过roll_pointer指针串联起来，形成一个重要的版本链。</strong></p> <h2 id="基于undo-log多版本链条实现的readview机制"><a href="#基于undo-log多版本链条实现的readview机制" class="header-anchor">#</a> 基于undo log多版本链条实现的ReadView机制</h2> <p>readView就是你执行一个事务的时候，就给你生成一个ReadView，它里面有4个关键的东西：<br>
1，m_ids，表示有哪些事务在MySQL里执行还没有提交的<br>
2，min_trx_id,就是m_ids里面最小的值<br>
3，max_trx_id，表示MySQL将要生成的下一个事务的id，就是最大事务id<br>
4，creator_trx_id，就是当前事务的id</p> <p><img src="/docs/assets/img/readview1.7efeeddc.png" alt="readview" title="readview1.png"></p> <p>现在事务A直接开启一个ReadView，这个ReadView里面的m_ids就包含了事务A和事务B的id，45和59，然后min_trx_id就是45，max_trx_id就是60，creator_trx_id就是45，也就是事务A自己的id。</p> <p>事务A第一次查询这行数据的时候，会走一个判断，就是<strong>判断一下当前这行数据的trx_id是否小于ReadView中的min_trx_id</strong>,发现此时trx_id=32，是小于min_trx_id也就是45的，说明你事务开启之前，修改这行数据的事务早就提交了，所以此时可以查到这行数据，如下图所示：<br> <img src="/docs/assets/img/readview2.60cd2510.png" alt="readview" title="readview2.png"></p> <p>这个时候A再次查询，此时查询的时候会发现一个问题，那就是此时数据行里的trx_id=59,trx_id大于ReadView里的min_trx_id(45),同时小于ReadView中的max_trx_id(60)的，说明更新这条数据的事务很有可能跟自己差不多同时开启的，于是会看一下这个trx_id=59是否在ReadView的m_ids列表里？</p> <p>果然，在ReadView的m_ids列表里有45和59，直接证实了，这个修改数据的事务是跟自己同一时段并发执行然后提交的，所以这行数据是不能查询的！<br> <img src="/docs/assets/img/readview3.3e79536c.png" alt="readview" title="readview3.png"></p> <p>既然这条数据不让查，那查什么呢？<br>
顺着这条数据的roll_pointer指针往下找，就会找到最近的一个undo log，trx_id是32，是小于ReadView里的min_trx_id（45）的，说明这个undo log版本必然是在事务A开启之前就执行且提交的。那么读取这个undo log里面的值返回就可以了。</p> <p>这就是undo log多版本链条的作用，它可以保存一个快照链条，让你可以读取到之前的快照值。如下图：
<img src="/docs/assets/img/readview4.45d7106c.png" alt="readview" title="readview4.png"></p> <p>接着假设事务A自己更新了这行数据的值，改成值A，trx_id改为了45，同时保存事务B修改的值的快照，如下图：
<img src="/docs/assets/img/readview5.111797c8.png" alt="readview" title="readview5.png"><br>
此时事务A来查询这行数据的值，发现trx_id=45,居然跟自己的ReadView中的creator_trx_id(45)一样，说明了这行数据就是自己修改的啊！<strong>自己修改的数据当然可以查看</strong>。如下图所示：
<img src="/docs/assets/img/readview6.ddeef666.png" alt="readview" title="readview6.png"></p> <p>接着在事务A执行的过程中，突然来了一个事务C，这个事务的id是78，然后它更新了那行数据的值为C，还提交了事务，如下图所示：
<img src="/docs/assets/img/readview7.138a012b.png" alt="readview" title="readview7.png"></p> <p>这个时候事务A再去查询这行数据，发现这行数据的trx_id=78，大于ReadView中的max_trx_id(60),说明了事务A开启之后，事务C才开启的，并且事务C更新数据。如下图所示：
<img src="/docs/assets/img/readview8.ef324fd2.png" alt="readview" title="readview8.png"></p> <p>然后顺着roll_pointer的指向沿着undo log多版本链条往下找，先找到A之前修改的那个版本，因为这个undo log里的trx_id=45和自己的ReadView里的creator_trx_id=45是一样的，所以直接读取自己之前修改的那个版本的值即可。如下图所示：
<img src="/docs/assets/img/readview9.14815544.png" alt="readview" title="readview9.png"></p> <p><strong>总结：通过undo log多版本链条和ReadView的判断机制，可以保证你只能读取到你事务开启之前，别的事务更新并提交的值，还有就是你自己事务更新的值。假设你事务开启之前，别的事务正在运行，你的事务开启之后，别的事务更新了值，你是绝对读不到的。或者你事务开启之后，比你晚的事务更新了值，你也是读取不到的</strong>。</p> <h2 id="read-committed隔离级别是如何基于readview机制实现的"><a href="#read-committed隔离级别是如何基于readview机制实现的" class="header-anchor">#</a> Read Committed隔离级别是如何基于ReadView机制实现的？</h2> <p><strong>核心要点：当你设置一个事务处于RC隔离级别的时候，每次发起查询，都重新生成一个ReadView。</strong><br>
下面开始画图演示RC隔离级别是怎么一步一步做到的：<br>
首先，假设我们数据库里有一行数据，是之前的事务（id=50）插入的，然后现在活跃着两个事务，一个是事务A（id=60),一个是事务B(id=70),此时这行数据如下图所示：
<img src="/docs/assets/img/read_committed1.e45b41cd.png" alt="read committed演示" title="read_committed1.png"></p> <p>现在事务B发起了一次update操作，把这条数据的值改为了B，所以此时这行数据的trx_id=70，同时会生成一个undo log，由roll_pointer来指向，如下图所示：
<img src="/docs/assets/img/read_committed2.0594054b.png" alt="read committed演示" title="read_committed2.png"><br>
此时事务A会发起一次查询操作，它一发起查询操作就会生成一个ReadView，此时ReadView里的min_trx_id=60,max_trx_id=71,creator_trx_id=60,如下图所示：
<img src="/docs/assets/img/read_committed3.2e034334.png" alt="read committed演示" title="read_committed3.png"><br>
查询时发现trx_id=70，也就是说，属于ReadView的事务id范围之间，说明是他生成ReadView之前就有这个活跃的事务，是这个事务修改这条数据的值，但是这个事务B还没有提交，所以ReadView的m_ids活跃事务列表里，是有[60,70]两个id的，所以此时根据ReadView的机制，事务A是无法查看到事务B修改的值B的。</p> <p>接着就顺着undo log版本链条往下找，找到最近的undo log，它的trx_id=50,trx_id小于ReadView的min_trx_id=60，说明是在生成ReadView之前就有事务插入了这个值并提交了，因此是可以查询这个undo log里面的原始值。如下图：
<img src="/docs/assets/img/read_committed4.0fac6649.png" alt="read committed演示" title="read_committed4.png"></p> <p>接着假设事务B提交了，提交后，事务B不会活跃在数据库里了。到底怎么处理才能让A读取到B提交的值呢？</p> <p>很简单，就是让事务A下次发起查询，重新生成ReadView。此时再次生成ReadView，数据库内活跃的事务只有事务A了，因此此时min_trx_id=60,max_trx_id=71,creator_trx_id=60,m_ids这个活跃事务列表里就只有事务A（id=60）了，如下图：
<img src="/docs/assets/img/read_committed5.6ef0e9f8.png" alt="read committed演示" title="read_committed5.png"></p> <p>此时事务A基于新生成的ReadView,trx_id=70,在min_trx_id=60和max_trx_id=71之间，但是此时不在m_ids列表里，说明事务B在生成本次ReadView之前就已经提交了。</p> <p>那么既然在生成ReadView之前，事务B就已经提交了，根据前面说的，事务A查询就可以查询事务B修改后的值了。如下图所示：
<img src="/docs/assets/img/read_committed6.d3ebd767.png" alt="read committed演示" title="read_committed6.png"></p> <p><strong>总结：它的关键点是每次查询都会生成新的ReadView，那么在你这次查询之前，有事务修改了数据还提交了，你这次查询生成的ReadView里，那个m_ids活跃事务列表里当然不包括已经提交的事务了，那么当然可以读到别人修改过的值了。</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/mysql0.html" class="prev">
        MySQL章节0
      </a></span> <span class="next"><a href="/docs/mysql2.html">
        MySQL章节2
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.324b6e72.js" defer></script><script src="/docs/assets/js/4.99657516.js" defer></script><script src="/docs/assets/js/3.248ad4f9.js" defer></script>
  </body>
</html>
