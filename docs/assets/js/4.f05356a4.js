(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{405:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed1.6be60190.png"},406:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed2.78f34439.png"},407:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed3.410b15e2.png"},408:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed4.441d2604.png"},409:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed5.2a07af31.png"},410:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed6.2287f40b.png"},411:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed7.244d09a1.png"},412:function(t,e,a){t.exports=a.p+"assets/img/repeatable_committed8.3e7049dd.png"},423:function(t,e,a){"use strict";a.r(e);var r=a(42),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"mysql章节2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql章节2"}},[t._v("#")]),t._v(" MySQL章节2")]),t._v(" "),r("h2",{attrs:{id:"mysql最牛的rr隔离级别-是如何基于readview机制实现的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql最牛的rr隔离级别-是如何基于readview机制实现的"}},[t._v("#")]),t._v(" MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？")]),t._v(" "),r("h3",{attrs:{id:"rr级别下如何解决不可重复读问题的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rr级别下如何解决不可重复读问题的"}},[t._v("#")]),t._v(" RR级别下如何解决不可重复读问题的")]),t._v(" "),r("p",[t._v("RR(可重复读)级别下，你这个事务读取一条数据，无论读多少次，都是一个值，别的事务哪怕修改数据之后提交了事务，你也是看不到人家修改的值的。这就避免了不可重复读的问题。别的事务插入一条数据，你也是看不到的，这就避免了幻读的问题。")]),t._v(" "),r("p",[t._v("那到底是如何实现的呢？"),r("br"),t._v("\n首先，我们还是假设数据库里有一条数据，这个数据是事务id=5的插入的。此时有事务A（id=60）和事务B（id=70）在同时运行，如下图所示：\n"),r("img",{attrs:{src:a(405),alt:"可重复读与ReadView",title:"repeatable_committed1.png"}})]),t._v(" "),r("p",[t._v("接着事务A发起了一次查询，因为是第一次查询，所以生成了ReadView，此时min_trx_id=60，max_trx_id=71,creator_trx_id=60,m_ids=[60,70],此时如下图：\n"),r("img",{attrs:{src:a(406),alt:"可重复读与ReadView",title:"repeatable_committed2.png"}})]),t._v(" "),r("p",[t._v("这个时候事务A基于这个ReadView去查询数据，此时trx_id=50，是小于min_trx_id=60，说它发起事务之前就已经有事务修改了数据并提交了事务，所以可以查到这条数据的原始值。如下图所示：\n"),r("img",{attrs:{src:a(407),alt:"可重复读与ReadView",title:"repeatable_committed3.png"}})]),t._v(" "),r("p",[t._v("接着事务B就更新了这行数据的值为B，此时会把trx_id修改为70，同时会生成undo log，关键是事务B提交了，也就是说此时事务B已经结束了，如下图：\n"),r("img",{attrs:{src:a(408),alt:"可重复读与ReadView",title:"repeatable_committed4.png"}})]),t._v(" "),r("p",[t._v("这个时候大家思考一个问题，ReadView中的m_ids还是[60,70]吗？")]),t._v(" "),r("p",[t._v("那必然是的，因为ReadView一旦生成了就不会改变了，这个时候事务B虽然已经结束了，但是事务A的ReadView里m_ids还是[60,70]。"),r("br"),t._v("\n它的意思是事务A开启的时候，事务B当时是在运行的。")]),t._v(" "),r("p",[t._v("那么此时事务A去查询这条数据的值，他会惊讶的发现此时数据的trx_id=70,70在min_trx_id和max_trx_id之间，同时还在m_ids=[60,70]列表中。"),r("br"),t._v("\n这说明事务A开启查询的时候，id=70的事务B还是在运行的，然后事务B更新了这条数据，所以此时事务A是不能查询到事务B更新的值，因此此时会顺着undo log版本链条往下找，如下图所示：\n"),r("img",{attrs:{src:a(409),alt:"可重复读与ReadView",title:"repeatable_committed5.png"}}),r("br"),t._v("\n事务A顺着roll_pointer找最近的undo log，发现最近的undo log的trx_id=50,它是小于min_trx_id=60的，说明它是在事务A开启之前就已经提交这个事务了，所以事务A是可以查询到这个值的，此时事务A查到的是原始值。"),r("br"),t._v(" "),r("img",{attrs:{src:a(410),alt:"可重复读与ReadView",title:"repeatable_committed6.png"}})]),t._v(" "),r("p",[t._v("可以看到两次查询查到的结果是一样的，都是原始值。不管别的事务如何修改数据，事务A的ReadView始终是不变的，基于这个ReadView看到的值始终是一样的。")]),t._v(" "),r("h3",{attrs:{id:"rr级别下如何解决幻读问题的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rr级别下如何解决幻读问题的"}},[t._v("#")]),t._v(" RR级别下如何解决幻读问题的")]),t._v(" "),r("p",[r("img",{attrs:{src:a(411),alt:"可重复读与ReadView",title:"repeatable_committed7.png"}}),r("br"),t._v(" "),r("img",{attrs:{src:a(412),alt:"可重复读与ReadView",title:"repeatable_committed8.png"}})])])}),[],!1,null,null,null);e.default=i.exports}}]);