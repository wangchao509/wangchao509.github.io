(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{362:function(_,v,r){"use strict";r.r(v);var a=r(42),t=Object(a.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"mysql章节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql章节"}},[_._v("#")]),_._v(" mysql章节")]),_._v(" "),r("h2",{attrs:{id:"mysql物理数据存储格式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mysql物理数据存储格式"}},[_._v("#")]),_._v(" MySQL物理数据存储格式")]),_._v(" "),r("p",[r("strong",[_._v("一行数据在磁盘上是如何存储的？")]),r("br"),_._v("\n这里涉及到一个概念，行格式。我们可以对一个表指定它的行存储格式是什么样的，比如COMPACT")]),_._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[_._v("CREATE TABLE table_name(columns) ROW_FORMAT=COMPACT  \nALTER TABLE  table_name ROW_FORMAT=COMPACT  \n")])])]),r("p",[_._v("你可以在建表的时候就指定行存储的格式，也可以建表后修改行存储的格式")]),_._v(" "),r("hr"),_._v(" "),r("p",[r("strong",[_._v("每一行数据实际存储的时候，格式类似这样：")])]),_._v(" "),r("blockquote",[r("p",[r("em",[_._v("变长字段的长度列表，null值列表，数据头，column01的值，column02的值，column0n的值....")]),r("br"),_._v(" "),r("strong",[_._v("行格式:")]),_._v(" 对于每行数据，他其实存储的时候都会有一些头字段对这行数据进行一定的描述，然后再放上这行数据每一列的具体的值。除了COMPACT意外，还有其他几种行存储格式，大同小异。")])]),_._v(" "),r("h2",{attrs:{id:"变长字段在磁盘是怎么存储的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#变长字段在磁盘是怎么存储的"}},[_._v("#")]),_._v(" 变长字段在磁盘是怎么存储的")]),_._v(" "),r("p",[_._v("假设现在有一行数据，它有三个字段，分别是varchar(10),char(1),char(1),所以这行数据可能是hello a a，第一个字段的值是hello，第二和第三个字段都是a"),r("br"),_._v("\n第二行数据，假设这行数据是hi a a，第一个字段是hi，后面两个字段是a"),r("br"),_._v("\n假设把上面两行数据写入了一个磁盘文件里，两行数据是挨在一起的，那么这两行数据在磁盘里可能是hello a a hi a a"),r("br"),_._v(" "),r("strong",[_._v("为什么变长字段难以读取")]),r("br"),_._v("\n因为我们不知道变长字段的实际长度，所以需要引入"),r("strong",[_._v("变长字段的长度列表")]),r("br"),_._v("\n比如你在存储hello a a的时候，需要带上一些额外的附加信息，第一块就是变长字段的长度列表"),r("br"),_._v("\nhello字段长度是5，十六进制是0x05，在磁盘中存储格式是这样的：0x05 null值列表 数据头 hello a a"),r("br"),_._v("\nhi字段长度是2，十六进制是0x02，在磁盘中存储格式是这样的：0x02 null值列表 数据头 hi a a"),r("br"),_._v(" "),r("strong",[_._v("然后两行数据放在磁盘文件中格式如下：")]),r("br"),_._v("\n0x05 null值列表 数据头 hello a a 0x02 null值列表 数据头 hi a a")]),_._v(" "),r("h3",{attrs:{id:"多个变长字段-如何存储他们的长度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多个变长字段-如何存储他们的长度"}},[_._v("#")]),_._v(" 多个变长字段，如何存储他们的长度")]),_._v(" "),r("p",[_._v("比如一行数据有五个字段，分别是varchar(10),varchar(5),varchar(20),char(1),char(1)"),r("br"),_._v("\n这行数据是:"),r("strong",[_._v("hello hi hao a a")]),r("br"),_._v("\n现在hello hi hao三个字段的长度分别是0x05,0x02,0x03，但是在"),r("strong",[_._v("实际存放变长字段长度列表的时候，是逆序放的")]),_._v("，所以这行数据可能按下面的方式存放："),r("br"),_._v(" "),r("em",[r("strong",[_._v("0x03 0x02 0x05 null值列表 数据头 hello hi hao a a")])])]),_._v(" "),r("h2",{attrs:{id:"null值是怎么存储的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#null值是怎么存储的"}},[_._v("#")]),_._v(" NULL值是怎么存储的？")]),_._v(" "),r("p",[_._v("如果一个字段是null，说明该字段什么都没有。如果存入null字符串的话太浪费空间了，解决方案如下："),r("br"),_._v(" "),r("strong",[_._v("NULL值以二进制bit位来存储")]),r("br"),_._v("\n接下来看看NULL值列表在磁盘上到底如何存储？"),r("br"),_._v("\n很简单，对于所有的NULL值，不通过字符串在磁盘上存储，而是通过二进制的bit位来存储，一行数据里假设多个字段都是NULL，那么这些字段的NULL是以bit位的形式存到了NULL值列表中。"),r("br"),_._v("\n举个例子，假设有一张表，建表语句如下：")]),_._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[_._v("CREATE TABLE customer(\n  name VARCHAR(10) NOT NULL,\n  address VARCHAR(20),\n  gender CHAR(1),\n  job  VARCHAR(30),\n  school VARCHAR(50)\n)\n")])])]),r("p",[_._v("客户表有五个字段，分别代表姓名、地址、性别、工作和学校。4个变长字段，1个定长字段，其中name是不能为NULL的。"),r("br"),_._v("\n现在我们假设有如下一行数据，“jack NULL m NULL xx_school”,其中5个字段2个是NULL"),r("br"),_._v("\n针对上面假设的数据，我们有4个变长字段，按照前面说的，变长字段长度列表，我们是不是应该逆序存放name，address、job、school的长度？"),r("br"),_._v("\n说起来是这样，但是我们要注意一个问题，变长字段的值可能是NULL，如果变长字段值为NULL，那么是不需要在变长字段长度列表中存放其长度的。如下所示："),r("br"),_._v(" "),r("em",[_._v("0x09 0x04 NULL值列表 头信息 column1=value1 column2=value2 ... columnN=valueN")]),r("br"),_._v(" "),r("strong",[_._v("NULL值列表存放的是所有允许为NULL的字段（不是说字段值为NULL，而是允许为NULL）")]),r("br"),_._v("\n在NULL值列表中，存放的是二进制bit位，比如bit值是1，说明是NULL，如果bit值是0，说明不是NULL。"),r("br"),_._v("\n比如上面四个字段（address，gender，job，school）都允许为null，“jack NULL m NULL xx_school”中两个字段是NULL，2个字段不是null，所以4个bit位应该是1010，但是"),r("strong",[_._v("实际存放NULL值列表的时候，是按照逆序存放的")]),_._v("，放入的是0101。所以数据看着像下面所示："),r("br"),_._v(" "),r("em",[_._v("0x09 0x04 0101 头信息 column1=value1 column2=value2 ... columnN=valueN")]),r("br"),_._v(" "),r("strong",[_._v("另外，NULL值列表存放的时候不仅仅是4个bit位，至少要是8个bit位的倍数，如果不足8个bit位，需要在前面补0（高位补零），实际存放如下所示：")]),r("br"),_._v(" "),r("em",[_._v("0x09 0x04 00000101 头信息 column1=value1 column2=value2 ... columnN=valueN")])]),_._v(" "),r("h2",{attrs:{id:"_40个bit位的数据头"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_40个bit位的数据头"}},[_._v("#")]),_._v(" 40个bit位的数据头")]),_._v(" "),r("p",[_._v("前两个bit位都是预留的，没有任何含义")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("接下来一个bit位是"),r("strong",[_._v("delete_mask")]),_._v(",标识这行数据是否被删除了。所以说mysql删除一条数据的时候，未必是立马把它从磁盘清理掉")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("下一个bit为是"),r("strong",[_._v("min_rec_mask")]),_._v(",B+树里每一层的非叶子节点里的最小值都有这个标记")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("接下来4个bit位是"),r("strong",[_._v("n_owned")]),_._v(",它记录了一个记录数，具体作用后续会讲")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("接着有13个bit位是"),r("strong",[_._v("heap_no")]),_._v(",它代表当前这行数据在记录堆里的位置，后续讲")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("然后3个bit位是"),r("strong",[_._v("record_type")]),_._v(",代表的是这行数据的数据类型，0-普通类型 1-B+树非叶子节点 2-最小值数据 3-最大值是数据")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("最后16个bit位是"),r("strong",[_._v("next_record")]),_._v("，是指向下一条数据的指针")]),_._v(" "),r("hr"),_._v(" "),r("h2",{attrs:{id:"数据在磁盘上是如何存储的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据在磁盘上是如何存储的"}},[_._v("#")]),_._v(" 数据在磁盘上是如何存储的")]),_._v(" "),r("p",[_._v("我们的数据是jack NULL m NULL xx_school，它实际存储格式如下："),r("br"),_._v("\n0x09 0x04 00000101 0000000000000000000000010000000000011001 jack NULL m NULL xx_school"),r("br"),_._v("\n但是实际上不是怎么存储的，"),r("strong",[_._v("需要根据数据库指定的字符集编码，进行编码后再存储的")]),_._v("，所以实际数据如下："),r("br"),_._v("\n0x09 0x04 00000101 0000000000000000000000010000000000011001 616161 636320 6262626262"),r("br"),_._v(" "),r("strong",[_._v("其实这还不是最终的存储格式，真实数据里还有一些隐藏字段")])]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("首先有一个"),r("strong",[_._v("DB_ROW_ID")]),_._v("字段，它是一个行的唯一标识，是数据库给你搞的一个唯一标识，不是你的主键ID字段。如果我们没有指定主键和unique key唯一索引的时候，它就内存自动加一个ROW_ID作为主键。")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("接着是"),r("strong",[_._v("DB_TRX_ID")]),_._v("字段，这是跟事务相关的，它是说这是哪个事务更新的数据，是事务的ID。")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("最后是"),r("strong",[_._v("DB_ROLL_PTR")]),_._v("字段，这是回滚指针，是用来进行事务回滚的。")]),_._v(" "),r("hr"),_._v(" "),r("p",[_._v("加上隐藏字段后，实际数据看起来可能如下："),r("br"),_._v("\n0x09 0x04 00000101 0000000000000000000000010000000000011001 00000000094c(DB_ROW_ID) 00000000032D(DB_TRX_ID) EA000010078E(DB_ROLL_PTR) 616161 636320 6262626262")]),_._v(" "),r("h2",{attrs:{id:"行溢出"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#行溢出"}},[_._v("#")]),_._v(" 行溢出")]),_._v(" "),r("p",[_._v("实际上我们的每行数据都是放在数据页中的，一个数据页默认大小是16kb，万一一行数据大小超过了16kb怎么办？"),r("br"),_._v("\n比如一个表的字段大小是VARCHAR（65535），就是说最大可以包含65535个字符，也就是65535个字节，这就远远大于16kb的大小了。"),r("br"),_._v(" "),r("img",{attrs:{src:"/docs/css/big_data.png",alt:"大字段存储"}})])])}),[],!1,null,null,null);v.default=t.exports}}]);