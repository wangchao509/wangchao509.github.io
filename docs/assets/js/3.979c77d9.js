(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{355:function(_,v,r){_.exports=r.p+"assets/img/big_data.61ed42a5.png"},356:function(_,v,r){_.exports=r.p+"assets/img/data_page.78ec5d7a.png"},357:function(_,v,r){_.exports=r.p+"assets/img/data_page2.b7433bc4.png"},358:function(_,v,r){_.exports=r.p+"assets/img/table_space.8583f528.png"},359:function(_,v,r){_.exports=r.p+"assets/img/linux_file_system.7dfeb846.png"},368:function(_,v,r){"use strict";r.r(v);var t=r(42),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"mysql章节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql章节"}},[_._v("#")]),_._v(" mysql章节")]),_._v(" "),t("h2",{attrs:{id:"mysql物理数据存储格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql物理数据存储格式"}},[_._v("#")]),_._v(" MySQL物理数据存储格式")]),_._v(" "),t("p",[t("strong",[_._v("一行数据在磁盘上是如何存储的？")]),t("br"),_._v("\n这里涉及到一个概念，行格式。我们可以对一个表指定它的行存储格式是什么样的，比如COMPACT")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("CREATE TABLE table_name(columns) ROW_FORMAT=COMPACT  \nALTER TABLE  table_name ROW_FORMAT=COMPACT  \n")])])]),t("p",[_._v("你可以在建表的时候就指定行存储的格式，也可以建表后修改行存储的格式")]),_._v(" "),t("hr"),_._v(" "),t("p",[t("strong",[_._v("每一行数据实际存储的时候，格式类似这样：")])]),_._v(" "),t("blockquote",[t("p",[t("em",[_._v("变长字段的长度列表，null值列表，数据头，column01的值，column02的值，column0n的值....")]),t("br"),_._v(" "),t("strong",[_._v("行格式:")]),_._v(" 对于每行数据，他其实存储的时候都会有一些头字段对这行数据进行一定的描述，然后再放上这行数据每一列的具体的值。除了COMPACT意外，还有其他几种行存储格式，大同小异。")])]),_._v(" "),t("h2",{attrs:{id:"变长字段在磁盘是怎么存储的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变长字段在磁盘是怎么存储的"}},[_._v("#")]),_._v(" 变长字段在磁盘是怎么存储的")]),_._v(" "),t("p",[_._v("假设现在有一行数据，它有三个字段，分别是varchar(10),char(1),char(1),所以这行数据可能是hello a a，第一个字段的值是hello，第二和第三个字段都是a"),t("br"),_._v("\n第二行数据，假设这行数据是hi a a，第一个字段是hi，后面两个字段是a"),t("br"),_._v("\n假设把上面两行数据写入了一个磁盘文件里，两行数据是挨在一起的，那么这两行数据在磁盘里可能是hello a a hi a a"),t("br"),_._v(" "),t("strong",[_._v("为什么变长字段难以读取")]),t("br"),_._v("\n因为我们不知道变长字段的实际长度，所以需要引入"),t("strong",[_._v("变长字段的长度列表")]),t("br"),_._v("\n比如你在存储hello a a的时候，需要带上一些额外的附加信息，第一块就是变长字段的长度列表"),t("br"),_._v("\nhello字段长度是5，十六进制是0x05，在磁盘中存储格式是这样的：0x05 null值列表 数据头 hello a a"),t("br"),_._v("\nhi字段长度是2，十六进制是0x02，在磁盘中存储格式是这样的：0x02 null值列表 数据头 hi a a"),t("br"),_._v(" "),t("strong",[_._v("然后两行数据放在磁盘文件中格式如下：")]),t("br"),_._v("\n0x05 null值列表 数据头 hello a a 0x02 null值列表 数据头 hi a a")]),_._v(" "),t("h3",{attrs:{id:"多个变长字段-如何存储他们的长度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多个变长字段-如何存储他们的长度"}},[_._v("#")]),_._v(" 多个变长字段，如何存储他们的长度")]),_._v(" "),t("p",[_._v("比如一行数据有五个字段，分别是varchar(10),varchar(5),varchar(20),char(1),char(1)"),t("br"),_._v("\n这行数据是:"),t("strong",[_._v("hello hi hao a a")]),t("br"),_._v("\n现在hello hi hao三个字段的长度分别是0x05,0x02,0x03，但是在"),t("strong",[_._v("实际存放变长字段长度列表的时候，是逆序放的")]),_._v("，所以这行数据可能按下面的方式存放："),t("br"),_._v(" "),t("em",[t("strong",[_._v("0x03 0x02 0x05 null值列表 数据头 hello hi hao a a")])])]),_._v(" "),t("h2",{attrs:{id:"null值是怎么存储的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null值是怎么存储的"}},[_._v("#")]),_._v(" NULL值是怎么存储的？")]),_._v(" "),t("p",[_._v("如果一个字段是null，说明该字段什么都没有。如果存入null字符串的话太浪费空间了，解决方案如下："),t("br"),_._v(" "),t("strong",[_._v("NULL值以二进制bit位来存储")]),t("br"),_._v("\n接下来看看NULL值列表在磁盘上到底如何存储？"),t("br"),_._v("\n很简单，对于所有的NULL值，不通过字符串在磁盘上存储，而是通过二进制的bit位来存储，一行数据里假设多个字段都是NULL，那么这些字段的NULL是以bit位的形式存到了NULL值列表中。"),t("br"),_._v("\n举个例子，假设有一张表，建表语句如下：")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("CREATE TABLE customer(\n  name VARCHAR(10) NOT NULL,\n  address VARCHAR(20),\n  gender CHAR(1),\n  job  VARCHAR(30),\n  school VARCHAR(50)\n)\n")])])]),t("p",[_._v("客户表有五个字段，分别代表姓名、地址、性别、工作和学校。4个变长字段，1个定长字段，其中name是不能为NULL的。"),t("br"),_._v("\n现在我们假设有如下一行数据，“jack NULL m NULL xx_school”,其中5个字段2个是NULL"),t("br"),_._v("\n针对上面假设的数据，我们有4个变长字段，按照前面说的，变长字段长度列表，我们是不是应该逆序存放name，address、job、school的长度？"),t("br"),_._v("\n说起来是这样，但是我们要注意一个问题，变长字段的值可能是NULL，如果变长字段值为NULL，那么是不需要在变长字段长度列表中存放其长度的。如下所示："),t("br"),_._v(" "),t("em",[_._v("0x09 0x04 NULL值列表 头信息 column1=value1 column2=value2 ... columnN=valueN")]),t("br"),_._v(" "),t("strong",[_._v("NULL值列表存放的是所有允许为NULL的字段（不是说字段值为NULL，而是允许为NULL）")]),t("br"),_._v("\n在NULL值列表中，存放的是二进制bit位，比如bit值是1，说明是NULL，如果bit值是0，说明不是NULL。"),t("br"),_._v("\n比如上面四个字段（address，gender，job，school）都允许为null，“jack NULL m NULL xx_school”中两个字段是NULL，2个字段不是null，所以4个bit位应该是1010，但是"),t("strong",[_._v("实际存放NULL值列表的时候，是按照逆序存放的")]),_._v("，放入的是0101。所以数据看着像下面所示："),t("br"),_._v(" "),t("em",[_._v("0x09 0x04 0101 头信息 column1=value1 column2=value2 ... columnN=valueN")]),t("br"),_._v(" "),t("strong",[_._v("另外，NULL值列表存放的时候不仅仅是4个bit位，至少要是8个bit位的倍数，如果不足8个bit位，需要在前面补0（高位补零），实际存放如下所示：")]),t("br"),_._v(" "),t("em",[_._v("0x09 0x04 00000101 头信息 column1=value1 column2=value2 ... columnN=valueN")])]),_._v(" "),t("h2",{attrs:{id:"_40个bit位的数据头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_40个bit位的数据头"}},[_._v("#")]),_._v(" 40个bit位的数据头")]),_._v(" "),t("p",[_._v("前两个bit位都是预留的，没有任何含义")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("接下来一个bit位是"),t("strong",[_._v("delete_mask")]),_._v(",标识这行数据是否被删除了。所以说mysql删除一条数据的时候，未必是立马把它从磁盘清理掉")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("下一个bit为是"),t("strong",[_._v("min_rec_mask")]),_._v(",B+树里每一层的非叶子节点里的最小值都有这个标记")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("接下来4个bit位是"),t("strong",[_._v("n_owned")]),_._v(",它记录了一个记录数，具体作用后续会讲")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("接着有13个bit位是"),t("strong",[_._v("heap_no")]),_._v(",它代表当前这行数据在记录堆里的位置，后续讲")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("然后3个bit位是"),t("strong",[_._v("record_type")]),_._v(",代表的是这行数据的数据类型，0-普通类型 1-B+树非叶子节点 2-最小值数据 3-最大值是数据")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("最后16个bit位是"),t("strong",[_._v("next_record")]),_._v("，是指向下一条数据的指针")]),_._v(" "),t("hr"),_._v(" "),t("h2",{attrs:{id:"数据在磁盘上是如何存储的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据在磁盘上是如何存储的"}},[_._v("#")]),_._v(" 数据在磁盘上是如何存储的")]),_._v(" "),t("p",[_._v("我们的数据是jack NULL m NULL xx_school，它实际存储格式如下："),t("br"),_._v("\n0x09 0x04 00000101 0000000000000000000000010000000000011001 jack NULL m NULL xx_school"),t("br"),_._v("\n但是实际上不是怎么存储的，"),t("strong",[_._v("需要根据数据库指定的字符集编码，进行编码后再存储的")]),_._v("，所以实际数据如下："),t("br"),_._v("\n0x09 0x04 00000101 0000000000000000000000010000000000011001 616161 636320 6262626262"),t("br"),_._v(" "),t("strong",[_._v("其实这还不是最终的存储格式，真实数据里还有一些隐藏字段")])]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("首先有一个"),t("strong",[_._v("DB_ROW_ID")]),_._v("字段，它是一个行的唯一标识，是数据库给你搞的一个唯一标识，不是你的主键ID字段。如果我们没有指定主键和unique key唯一索引的时候，它就内存自动加一个ROW_ID作为主键。")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("接着是"),t("strong",[_._v("DB_TRX_ID")]),_._v("字段，这是跟事务相关的，它是说这是哪个事务更新的数据，是事务的ID。")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("最后是"),t("strong",[_._v("DB_ROLL_PTR")]),_._v("字段，这是回滚指针，是用来进行事务回滚的。")]),_._v(" "),t("hr"),_._v(" "),t("p",[_._v("加上隐藏字段后，实际数据看起来可能如下："),t("br"),_._v("\n0x09 0x04 00000101 0000000000000000000000010000000000011001 00000000094c(DB_ROW_ID) 00000000032D(DB_TRX_ID) EA000010078E(DB_ROLL_PTR) 616161 636320 6262626262")]),_._v(" "),t("h2",{attrs:{id:"行溢出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行溢出"}},[_._v("#")]),_._v(" 行溢出")]),_._v(" "),t("p",[_._v("实际上我们的每行数据都是放在数据页中的，一个数据页默认大小是16kb，万一一行数据大小超过了16kb怎么办？"),t("br"),_._v("\n比如一个表的字段大小是VARCHAR（65535），就是说最大可以包含65535个字符，也就是65535个字节，这就远远大于16kb的大小了。"),t("br"),_._v(" "),t("img",{attrs:{src:r(355),alt:"大字段存储"}}),t("br"),_._v(" "),t("strong",[_._v("行溢出")]),_._v("：就是说一行数据存储的内容太多了，一个数据页都放不下了，此时只能溢出这个数据页，把数据溢出存放到其他数据页里，那些数据页就叫溢出页。"),t("br"),_._v(" "),t("strong",[_._v("当我们在数据库里插入一条数据的时候，实际是在内存里插入一个有复杂存储结构的一行数据，然后随着一些条件的发生，这行数据会被刷入到磁盘中去。")])]),_._v(" "),t("h2",{attrs:{id:"mysql数据页结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql数据页结构"}},[_._v("#")]),_._v(" mysql数据页结构")]),_._v(" "),t("p",[t("img",{attrs:{src:r(356),alt:"数据页结构",title:"mysql数据页结构图"}}),_._v("\n其中"),t("strong",[_._v("文件头")]),_._v("占了38个字节，"),t("strong",[_._v("数据页头")]),_._v("占了56个字节，"),t("strong",[_._v("最大记录和最小记录")]),_._v("占了26个字节，"),t("strong",[_._v("数据行")]),_._v("区域的大小是不固定的，"),t("strong",[_._v("空闲区域")]),_._v("的大小也是不固定的，"),t("strong",[_._v("数据页目录")]),_._v("的大小也是不固定的，然后"),t("strong",[_._v("文件尾部")]),_._v("占了8个字节。"),t("br"),_._v(" "),t("strong",[_._v("存放了多条数据后的数据页结构图如下：")]),t("br"),_._v("\n如果数据页里面"),t("strong",[_._v("存满了数据，那么空闲区域就没了")]),t("br"),_._v(" "),t("img",{attrs:{src:r(357),alt:"数据页满了的数据页结构",title:"mysql数据页结构图"}})]),_._v(" "),t("h2",{attrs:{id:"表空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表空间"}},[_._v("#")]),_._v(" 表空间")]),_._v(" "),t("p",[t("strong",[_._v("表空间")]),_._v(":其实我们创建的那些表都有一个表空间的概念，在磁盘上都会对应着“表名.ibd”这样的一个磁盘文件。"),t("br"),_._v(" "),t("em",[t("strong",[_._v("所以在物理层面，表空间就是对应一些磁盘上的数据文件。表空间对应的文件中是有很多数据页的。")])]),t("br"),_._v("\n一个表空间包含的数据页实在是太多了，不便于管理，所以在表空间中又引入了"),t("strong",[_._v("数据区")]),_._v("的概念，英文是"),t("strong",[_._v("extend")]),t("br"),_._v("\n一个数据区对应着连续的64个数据页，一个数据页是16kb，所以一个数据区是1MB，然后256个数据区就被划分为一组。"),t("br"),_._v(" "),t("strong",[_._v("对于表空间而言，它的第一组数据区的的第一个数据区的前3个数据页，都是固定，里面存放了一些描述性的数据。3个数据页存放信息如下：")]),t("br"),_._v(" "),t("strong",[_._v("FSP_HDR")]),_._v("这个数据页，它里面存放了表空间和这一组数据区的一些属性。"),t("br"),_._v(" "),t("strong",[_._v("IBUF_BITMAP")]),_._v("这个数据页，里面存放的是这一组数据页的所有"),t("strong",[_._v("insert buffer")]),_._v("信息。"),t("br"),_._v(" "),t("strong",[_._v("INODE")]),_._v("数据页，里面存放了一些特殊的信息"),t("br"),_._v(" "),t("strong",[_._v("表空间的其他组数据区的第一个数据区的头两个数据页，也是存放特殊信息的。")])]),_._v(" "),t("h2",{attrs:{id:"表空间的存储结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#表空间的存储结构"}},[_._v("#")]),_._v(" 表空间的存储结构")]),_._v(" "),t("p",[t("img",{attrs:{src:r(358),alt:"表空间的结构",title:"牢记表空间结构"}})]),_._v(" "),t("h2",{attrs:{id:"插入一条数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#插入一条数据"}},[_._v("#")]),_._v(" 插入一条数据")]),_._v(" "),t("p",[_._v("假设此时我们要插入一条数据，那么是选择磁盘文件里的哪个数据页加载到缓存页里去呢？"),t("br"),_._v("\n因为我们知道要往哪个表里插入数据，所以可以得到表空间。找到表空间就可以找到对应的磁盘文件了（磁盘文件名为：表名.ibd）。有了磁盘文件后，可以从里面找一个extend组，找到一个extend，然后从里面找到一个数据页出来，这个数据页可能是空的，也可能已经有了一些数据了，然后就可以把这个数据页从磁盘里完整加载出来，放入Buffer Pool的缓存里。")]),_._v(" "),t("h2",{attrs:{id:"磁盘随机读写和数据库日志顺序读写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#磁盘随机读写和数据库日志顺序读写"}},[_._v("#")]),_._v(" 磁盘随机读写和数据库日志顺序读写")]),_._v(" "),t("p",[_._v("因为你要读取的这个数据页可能在磁盘的任意一个位置，所以你在读取磁盘里的数据页的时候只能是用"),t("strong",[_._v("随机读")]),_._v("的这种方式。")]),_._v(" "),t("p",[_._v("磁盘随机读的性能是比较差的，所以不可能每次更新数据都进行磁盘随机读，必须是读取一个数据页之后放到Buffer Pool的缓存里去，下次要更新的时候直接更新Buffer Pool里的缓存页。")]),_._v(" "),t("p",[_._v("对于磁盘随机读来说，主要关注的性能指标是IOPS和响应延迟"),t("br"),_._v("\n所谓"),t("strong",[_._v("顺序写")]),_._v("，就是说在一个磁盘日志文件里，一直在末尾追加日志")]),_._v(" "),t("p",[_._v("磁盘顺序写的性能其实是很高的，某种程度上来说，几乎可以跟内存随机读写的性能差不多，尤其是在数据库里其实也用了os cache机制，就是redo log顺序写入磁盘之前，先是进入os cache，就是操作系统管理的内存缓存里")]),_._v(" "),t("p",[_._v("所以对于这个写磁盘日志文件而言，最核心关注的是磁盘每秒读写多少数据量的吞吐量指标，就是说每秒可以写入磁盘100MB数据和每秒可以写入磁盘200MB数据，对数据库的并发能力影响也是极大的。")]),_._v(" "),t("p",[_._v("因为数据库的每一次更新SQL语句，都必然涉及到多个磁盘随机读取数据页的操作，也会涉及到一条redo log日志文件顺序写的操作。所以磁盘读写的IOPS指标，就是每秒可以执行多少个随机读写操作，以及每秒可以读写磁盘的数据量的吞吐量指标，就是每秒可以写入多少redo log日志，整体决定了数据库的并发能力和性能。")]),_._v(" "),t("p",[_._v("包括你磁盘日志文件的顺序读写的响应延迟，也决定了数据库的性能，因为你写redo log日志文件越快，那么你的SQL语句性能就越高。")]),_._v(" "),t("h2",{attrs:{id:"linux存储系统架构图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linux存储系统架构图"}},[_._v("#")]),_._v(" linux存储系统架构图")]),_._v(" "),t("p",[_._v("linux存储系统分为VFS层、文件系统层、Page Cache缓存层、通用Block层、IO调度层、Block设备驱动层、Block设备层")]),_._v(" "),t("p",[t("img",{attrs:{src:r(359),alt:"Linux存储系统架构图",title:"linux架构图"}})]),_._v(" "),t("p",[t("strong",[_._v("VFS层的作用")]),_._v("：\n根据你对哪个目录中的文件执行的磁盘IO操作，把IO操作交给具体的文件系统。")]),_._v(" "),t("p",[_._v("当MySQL发起一次数据页的随机读写，或者是一次redo log日志文件的顺序读写的时候，实际上会把磁盘IO请求交给linux系统的"),t("strong",[_._v("VFS层")]),_._v("处理。")]),_._v(" "),t("p",[_._v("举个例子，在linux系统中，有的目录比如/xx1/xx2里的文件其实是由NFS文件系统管理的，有的目录比如/xx3/xx4里的文件其实是由Ext3文件系统管理的，那么这个时候VFS层会根据你对哪个目录下的文件发起的IO操作，把请求交给对应的文件系统。")]),_._v(" "),t("p",[_._v("接着文件系统会在"),t("strong",[_._v("Page Cache缓存")]),_._v("中查找你要找的数据在不在里面，如果存在，就基于内存缓存进行读写，如果没有就继续往下一层走，此时这个请求就会交给"),t("strong",[_._v("通用Block层")]),_._v("，在这一层会把你对文件的IO请求转换成Block IO请求。")]),_._v(" "),t("p",[_._v("接着会把这个Block IO请求交给"),t("strong",[_._v("IO调度层")]),_._v("，在这一层默认是采用CFQ公平调度算法的。")]),_._v(" "),t("p",[t("strong",[_._v("CFQ公平调度算法")]),_._v("，指的是假设你对数据库发起的多个sql语句同时在执行IO操作。有一个sql非常简单，update xx set xx1=xx2 where id =1;但是另一条sql语句是：select * from xx where xx1 like '%xx%',可能需要读取磁盘上大量的数据。此时基于公平调度算法，可能会导致先执行第二个sql语句，这个操作耗时很久，然后第一个sql语句一直得不到执行的机会。")]),_._v(" "),t("h3",{attrs:{id:"mysql生产调优经验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql生产调优经验"}},[_._v("#")]),_._v(" "),t("font",{attrs:{color:"#FF0000",size:"4"}},[_._v("mysql生产调优经验")])],1),_._v(" "),t("p",[_._v("所以这里，"),t("font",{attrs:{color:"#0000FF",size:"4"}},[_._v("建议mysql生产中，需要调整为deadline IO调度算法")]),_._v("。他的核心思想是任何一个IO操作都不能一直等待，在指定的时间范围内，都必须让它执行。")],1),_._v(" "),t("p",[_._v("IO调度完成之后，会决定哪个IO请求先执行，哪个IO请求后执行。此时可以执行的IO请求就会交给"),t("strong",[_._v("Block设备驱动层")]),_._v("，然后经过驱动把IO请求发送给真正的存储硬件，也就是"),t("strong",[_._v("Block设备层")]),t("br"),_._v("\n然后硬件设备完成了IO读写操作之后，会把响应结果按照上图反向依次返回，最终MySQL可以得到本次IO读写操作的结果。")])])}),[],!1,null,null,null);v.default=s.exports}}]);