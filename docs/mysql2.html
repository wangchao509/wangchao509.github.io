<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL章节2 | whc的学习笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="主要是java技术类笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.2753b5fc.css" as="style"><link rel="preload" href="/docs/assets/js/app.29562e48.js" as="script"><link rel="preload" href="/docs/assets/js/5.2be00dd9.js" as="script"><link rel="preload" href="/docs/assets/js/2.b17def1c.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.d39eef98.js"><link rel="prefetch" href="/docs/assets/js/11.503720a4.js"><link rel="prefetch" href="/docs/assets/js/12.a69a580a.js"><link rel="prefetch" href="/docs/assets/js/13.fb827fa0.js"><link rel="prefetch" href="/docs/assets/js/14.44fa23c4.js"><link rel="prefetch" href="/docs/assets/js/15.7f144ec9.js"><link rel="prefetch" href="/docs/assets/js/3.54ff3cd5.js"><link rel="prefetch" href="/docs/assets/js/4.a6059a55.js"><link rel="prefetch" href="/docs/assets/js/6.c5b65b2a.js"><link rel="prefetch" href="/docs/assets/js/7.20fe6f54.js"><link rel="prefetch" href="/docs/assets/js/8.9f0f0100.js"><link rel="prefetch" href="/docs/assets/js/9.89035113.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.2753b5fc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">whc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">站点介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>markdown知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/markdown.html" class="sidebar-link">前端知识介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MySQL知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/mysql0.html" class="sidebar-link">MySQL章节0</a></li><li><a href="/docs/mysql.html" class="sidebar-link">MySQL章节1</a></li><li><a href="/docs/mysql2.html" aria-current="page" class="active sidebar-link">MySQL章节2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="sidebar-link">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#多个事务更新同一行数据时-是如何加锁避免脏写的" class="sidebar-link">多个事务更新同一行数据时，是如何加锁避免脏写的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#共享锁和独占锁到底是什么" class="sidebar-link">共享锁和独占锁到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#哪些操作会导致在表级别加锁呢" class="sidebar-link">哪些操作会导致在表级别加锁呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="sidebar-link">表锁和行锁互相之间的关系以及互斥规则是什么呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#线上数据库不确定性的性能抖动优化实践" class="sidebar-link">线上数据库不确定性的性能抖动优化实践**</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#上述问题导致数据库性能抖动的优化方案" class="sidebar-link">上述问题导致数据库性能抖动的优化方案</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#磁盘数据页的存储结构" class="sidebar-link">磁盘数据页的存储结构</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#数据库是如何根据查询语句搜索数据的" class="sidebar-link">数据库是如何根据查询语句搜索数据的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#不断在表中插入数据时-物理存储是如何进行页分裂的" class="sidebar-link">不断在表中插入数据时，物理存储是如何进行页分裂的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#基于主键的索引是如何设计的" class="sidebar-link">基于主键的索引是如何设计的</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#索引的页存储物理结构-是如何用b-树来实现的" class="sidebar-link">索引的页存储物理结构，是如何用B+树来实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#更新数据的时候-自动维护的聚簇索引到底是什么" class="sidebar-link">更新数据的时候，自动维护的聚簇索引到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#主键之外的字段建立的二级索引-又是如何运作的" class="sidebar-link">主键之外的字段建立的二级索引，又是如何运作的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#插入数据时到底是如何维护好不同索引的b-树的" class="sidebar-link">插入数据时到底是如何维护好不同索引的B+树的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#一个表里是不是索引搞的越多越好" class="sidebar-link">一个表里是不是索引搞的越多越好？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#通过一步一图来深入理解联合索引查询原理以及全值匹配规则" class="sidebar-link">通过一步一图来深入理解联合索引查询原理以及全值匹配规则</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#最常见和最基本的索引使用规则" class="sidebar-link">最常见和最基本的索引使用规则</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#当我们在sql里进行排序的时候-如何才能使用索引" class="sidebar-link">当我们在SQL里进行排序的时候，如何才能使用索引？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#在sql里进行分组的时候-如何才能使用索引" class="sidebar-link">在SQL里进行分组的时候，如何才能使用索引？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#回表查询对性能的损害以及覆盖索引是什么" class="sidebar-link">回表查询对性能的损害以及覆盖索引是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#设计索引的时候-我们一般要考虑哪些因素呢" class="sidebar-link">设计索引的时候，我们一般要考虑哪些因素呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#案例实战-陌生人社交app的mysql索引设计实战" class="sidebar-link">案例实战：陌生人社交APP的MySQL索引设计实战</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#sql语句的执行计划和性能优化有什么关系" class="sidebar-link">SQL语句的执行计划和性能优化有什么关系</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#以mysql单表查询来举例-看看执行计划包含哪些内容-const-ref-index-all" class="sidebar-link">以MySQL单表查询来举例，看看执行计划包含哪些内容(const,ref,index,all)</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#深入探索多表关联的sql语句到底是如何执行的" class="sidebar-link">深入探索多表关联的SQL语句到底是如何执行的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql是如何根据成本优化选择执行计划的" class="sidebar-link">MySQL是如何根据成本优化选择执行计划的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql是如何基于各种规则去优化执行计划的" class="sidebar-link">MySQL是如何基于各种规则去优化执行计划的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#透彻研究通过explain命令得到的sql执行计划" class="sidebar-link">透彻研究通过explain命令得到的SQL执行计划</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#案例实战-千万级用户场景下的运营系统sql调优" class="sidebar-link">案例实战：千万级用户场景下的运营系统SQL调优</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#案例实战-数十亿数量级评论系统的sql调优实战" class="sidebar-link">案例实战：数十亿数量级评论系统的SQL调优实战</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#案例实战-千万级数据删除导致的慢查询优化实践" class="sidebar-link">案例实战：千万级数据删除导致的慢查询优化实践</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#我们为什么要搭建一套mysql的主从复制架构" class="sidebar-link">我们为什么要搭建一套MySQL的主从复制架构？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#如何为mysql搭建一套主从复制架构" class="sidebar-link">如何为MySQL搭建一套主从复制架构？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#gtid方式的主从复制" class="sidebar-link">GTID方式的主从复制</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#主从复制架构中的数据延迟问题-应该如何解决" class="sidebar-link">主从复制架构中的数据延迟问题，应该如何解决？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#数据库高可用-基于主从复制实现故障转移" class="sidebar-link">数据库高可用：基于主从复制实现故障转移</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JAVA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/thread.html" class="sidebar-link">多线程知识</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>IDEA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/idea.html" class="sidebar-link">在idea上怎么部署web项目</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>线上故障快速排查</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/analyzeQuestion.html" class="sidebar-link">线上故障快速排查</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>apache ant打包</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/ant.html" class="sidebar-link">Apache Ant</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql章节2"><a href="#mysql章节2" class="header-anchor">#</a> MySQL章节2</h1> <h2 id="mysql最牛的rr隔离级别-是如何基于readview机制实现的"><a href="#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="header-anchor">#</a> MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</h2> <h3 id="rr级别下如何解决不可重复读问题的"><a href="#rr级别下如何解决不可重复读问题的" class="header-anchor">#</a> RR级别下如何解决不可重复读问题的</h3> <p>RR(可重复读)级别下，你这个事务读取一条数据，无论读多少次，都是一个值，别的事务哪怕修改数据之后提交了事务，你也是看不到人家修改的值的。这就避免了不可重复读的问题。别的事务插入一条数据，你也是看不到的，这就避免了幻读的问题。</p> <p>那到底是如何实现的呢？<br> <strong>核心地方在于RR隔离级别下，每次查询都是同一个ReadView</strong>
首先，我们还是假设数据库里有一条数据，这个数据是事务id=50的插入的。此时有事务A（id=60）和事务B（id=70）在同时运行，如下图所示：
<img src="/docs/assets/img/repeatable_committed1.d7e3decb.png" alt="可重复读与ReadView" title="repeatable_committed1.png"></p> <p>接着事务A发起了一次查询，因为是第一次查询，所以生成了ReadView，此时min_trx_id=60，max_trx_id=71,creator_trx_id=60,m_ids=[60,70],此时如下图：
<img src="/docs/assets/img/repeatable_committed2.91d36dfa.png" alt="可重复读与ReadView" title="repeatable_committed2.png"></p> <p>这个时候事务A基于这个ReadView去查询数据，此时trx_id=50，是小于min_trx_id=60，说它发起事务之前就已经有事务修改了数据并提交了事务，所以可以查到这条数据的原始值。如下图所示：
<img src="/docs/assets/img/repeatable_committed3.f04afef5.png" alt="可重复读与ReadView" title="repeatable_committed3.png"></p> <p>接着事务B就更新了这行数据的值为B，此时会把trx_id修改为70，同时会生成undo log，关键是事务B提交了，也就是说此时事务B已经结束了，如下图：
<img src="/docs/assets/img/repeatable_committed4.8e5343ba.png" alt="可重复读与ReadView" title="repeatable_committed4.png"></p> <p>这个时候大家思考一个问题，ReadView中的m_ids还是[60,70]吗？</p> <p>那必然是的，因为ReadView一旦生成了就不会改变了，这个时候事务B虽然已经结束了，但是事务A的ReadView里m_ids还是[60,70]。<br>
它的意思是事务A开启的时候，事务B当时是在运行的。</p> <p>那么此时事务A去查询这条数据的值，他会惊讶的发现此时数据的trx_id=70,70在min_trx_id和max_trx_id之间，同时还在m_ids=[60,70]列表中。<br>
这说明事务A开启查询的时候，id=70的事务B还是在运行的，然后事务B更新了这条数据，所以此时事务A是不能查询到事务B更新的值，因此此时会顺着undo log版本链条往下找，如下图所示：
<img src="/docs/assets/img/repeatable_committed5.dc738b79.png" alt="可重复读与ReadView" title="repeatable_committed5.png"><br>
事务A顺着roll_pointer找最近的undo log，发现最近的undo log的trx_id=50,它是小于min_trx_id=60的，说明它是在事务A开启之前就已经提交这个事务了，所以事务A是可以查询到这个值的，此时事务A查到的是原始值。<br> <img src="/docs/assets/img/repeatable_committed6.2caa39b4.png" alt="可重复读与ReadView" title="repeatable_committed6.png"></p> <p>可以看到两次查询查到的结果是一样的，都是原始值。不管别的事务如何修改数据，事务A的ReadView始终是不变的，基于这个ReadView看到的值始终是一样的。</p> <h3 id="rr级别下如何解决幻读问题的"><a href="#rr级别下如何解决幻读问题的" class="header-anchor">#</a> RR级别下如何解决幻读问题的</h3> <p><img src="/docs/assets/img/repeatable_committed7.244d09a1.png" alt="可重复读与ReadView" title="repeatable_committed7.png"><br> <img src="/docs/assets/img/repeatable_committed8.3e7049dd.png" alt="可重复读与ReadView" title="repeatable_committed8.png"></p> <p>MVCC是Multi-Version concurrent control,就是多版本并发控制机制。专门控制多个事务并发运行的时候，互相之间会如何影响。<br>
MySQL实现MVCC机制的时候，是基于<strong>undo log多版本链条+ReadView</strong>机制来做的，默认的RR隔离级别就是基于这套机制实现的。</p> <h2 id="多个事务更新同一行数据时-是如何加锁避免脏写的"><a href="#多个事务更新同一行数据时-是如何加锁避免脏写的" class="header-anchor">#</a> 多个事务更新同一行数据时，是如何加锁避免脏写的？</h2> <p>靠锁机制，依靠锁机制让多个事务更新同一行数据的时候串行化，避免同时更新一条数据。</p> <p>假设MySQL里有一行数据，此时来了一个事务要更新它，更新之前需要先检查这行数据有没有锁，如果没有锁，这个事务就会创建一个锁，里面包含了自己的trx_id和等待状态，然后把锁跟这行数据关联在一起。</p> <p><img src="/docs/assets/img/synchronized1.4d94aafe.png" alt="加锁避免脏写" title="synchronized1.png"></p> <p><strong>注意看上图，因为事务A已经给那行数据加了锁，所以此时就可以说那行数据已经被加锁了。</strong><br> <strong>此时另外一个事务B过来了，它也想更新那行数据，更新前先检查这行数据有没有锁，如果已经有锁，B也给这行数据加个锁，然后排队等着。这个时候事务B也生成了一个锁数据结构，里面有它的trx_id和等待状态，但是因为它是排队等待，所以它的等待状态是true</strong>。如下图所示：
<img src="/docs/assets/img/synchronized2.0e179d60.png" alt="加锁避免脏写" title="synchronized2.png"></p> <p>接着事务A更新完数据就把锁给释放了。锁一旦释放了，他就会去找，此时还有没有别人也对这行数据加锁了呢？他就会发现事务B也对该行数据加锁了，于是这个时候，就会把事务B的锁里的等待状态给修改为false，然后唤醒事务B继续执行，此时事务B就获取到锁了，如下图所示：
<img src="/docs/assets/img/synchronized3.2569590d.png" alt="加锁避免脏写" title="synchronized3.png"></p> <h2 id="共享锁和独占锁到底是什么"><a href="#共享锁和独占锁到底是什么" class="header-anchor">#</a> 共享锁和独占锁到底是什么？</h2> <h3 id="独占锁"><a href="#独占锁" class="header-anchor">#</a> 独占锁</h3> <p>前面讲过，多个事务同时更新一行数据，此时都会加锁，然后都会排队等待，必须一个事务执行完了，提交了，释放了锁，才能唤醒别的事务继续执行。<br>
那么多个事务运行时加的是什么类型的锁呢？<br> <strong>其实是X锁，也就是Exclude独占锁</strong>，当有一个事务加了独占锁之后，此时其他事务再要更新这行数据，都是要加独占锁的，但是智能生成独占锁在后面等待。</p> <p>当有人在更新数据的时候，其他的事务可以读取这行数据吗？默认情况下，需要加锁吗？<br>
答案是：不需要。</p> <p>原因：因为默认情况下，有人在更新数据的时候，你要去读取这行数据，直接默认就是开启MVCC机制的。<br>
也就是说此时对一行数据的读和写两个操作，默认是不会加锁互斥的，因为MySQL设计MVCC机制就是为了解决这个问题的，避免频繁加锁互斥。<br> <font color="#0000FF" size="4">查询操作加互斥锁的方法： select * from table for update</font></p> <h3 id="共享锁"><a href="#共享锁" class="header-anchor">#</a> 共享锁</h3> <p>万一执行查询操作时，就是想要加锁呢？<br>
MySQL也是Ok的，他提供了一种共享锁，就是S锁。<br> <font color="#0000FF" size="4">共享锁的语法如下：select * from table lock in share mode   </font><br>
你在一个查询语句后面加上 lock in share mode，就表示查询时对这行数据加了共享锁。</p> <p><font color="FF0000" size="4">如果此时有别的事务在更新这行数据，已经加了独占锁了，此时你的共享锁还能加吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你这个查询就只能等着了。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人再来更新要加独占锁，行吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你的更新只能等待。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人也来加共享锁，行吗？</font><br>
可以，共享锁和共享锁不会互斥。<br> <img src="/docs/assets/img/share_or_exclude_lock.9039512f.png" alt="共享锁和互斥锁关系图" title="share_or_exclude_lock.png"></p> <h2 id="哪些操作会导致在表级别加锁呢"><a href="#哪些操作会导致在表级别加锁呢" class="header-anchor">#</a> 哪些操作会导致在表级别加锁呢？</h2> <p>在多个事务并发更新数据的时候，都是要在行级别加独占锁的，这就是行锁，独占锁都是互斥的，所以不可能发生脏写问题，一个事务提交了才会释放自己的独占锁，唤醒下一个事务执行。</p> <p>如果你此时去读取别的事务在更新的数据，有两种可能：</p> <p>第一种可能是基于mvcc机制进行事务隔离，读取快照版本，这是比较常见的；<br>
第二种可能是查询的同时基于特殊语法去加独占锁或者共享锁。</p> <p>太建议在数据库粒度去通过行锁实现复杂的业务锁机制，而更加建议通过redis、zookeeper来用分布式锁实现复杂业务下的锁机制，其实更为合适一些。</p> <p>为什么呢？因为如果你把分布式系统里的复杂业务的一些锁机制依托数据库查询的时候，在SQL语句里加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的不好维护的，所以一般是不建议这么做的。</p> <p><strong>比较正常的情况而言，其实还是多个事务并发运行更新一条数据，默认加独占锁互斥，同时其他事务读取基于mvcc机制进行快照版本读，实现事务隔离。</strong></p> <p>有些人可能会以为当你执行增删改的时候默认加行锁，然后执行DDL语句的时候，比如alter table之类的语句，会默认在表级别加表锁。这么说也不太正确，但是也有一定的道理，因为确实你执行DDL的时候，会阻塞所有增删改操作；执行增删改的时候，会阻塞DDL操作。</p> <p>但这是通过MySQL通用的<strong>元数据锁实现的，也就是Metadata Locks，但这还不是表锁的概念</strong>。因为<strong>表锁其实是InnoDB存储引擎的概念</strong>，InnoDB存储引擎提供了自己的表级锁，跟这里DDL语句用的元数据锁还不是一个概念。</p> <p>只不过DDL语句和增删改操作，确实是互斥的，大家要知道这一点。</p> <h2 id="表锁和行锁互相之间的关系以及互斥规则是什么呢"><a href="#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="header-anchor">#</a> 表锁和行锁互相之间的关系以及互斥规则是什么呢？</h2> <p>MySQL的表锁其实非常鸡肋的东西，几乎不会有人用。表锁分为两种，一种是表锁，一种是表级的意向锁。</p> <p><font color="#0000FF" size="4">表锁加锁语法：<br>
LOCK TABLES XXX READ  这是加表级共享锁<br>
LOCK TABLES XXX WRITE 这是加表级独占锁<br></font></p> <p><font color="#0000FF" size="4">我们平时操作数据库，两种常见的表锁：<br>
更新时加的意向独占锁<br>
查询时加的意向共享锁  </font><br>
可以当这两种锁是透明的，因为意向独占锁和意向共享锁是不互斥的。<br> <img src="/docs/assets/img/table_lock.d40f61b5.png" alt="表锁" title="table_lock.png"><br> <img src="/docs/assets/img/lock_relation.c432bee4.png" alt="表锁关系" title="lock_relation.png"></p> <h2 id="线上数据库不确定性的性能抖动优化实践"><a href="#线上数据库不确定性的性能抖动优化实践" class="header-anchor">#</a> 线上数据库不确定性的性能抖动优化实践**</h2> <p>大家都知道，我们平时执行更新语句的时候，实际上都是从磁盘加载数据页到数据库内存的缓存页中，接着就直接更新内存里的缓存页，同时更新对应的redo log并写入一个buffer中，如下图所示：
<img src="/docs/assets/img/redo_log1.33a93a02.png" alt="redo log" title="redo_log1.png"></p> <p>既然我们更新了Buffer Pool里的缓存页，缓存页就变成了脏页，之所以说他是脏页，是因为缓存页里的数据目前跟磁盘文件里的数据页的数据是不一致的，所以此时的缓存页也叫作脏页。</p> <p><strong>既然是脏页就必然要有一个合适的时机把脏页给刷回磁盘文件，脏页刷回磁盘是通过LRU链表实现的，通过LRU链表，就可以知道哪些缓存页是最近经常被使用的。</strong></p> <p>如果后续你要加载磁盘里的数据页到Buffer Pool中去，但是此时并没有空闲的缓存页了，此时就必须把部分脏页给刷回磁盘，根据LRU链表找到最近最少被访问的缓存页刷回磁盘。</p> <p><img src="/docs/assets/img/redo_log2.d17eea1b.png" alt="redo log" title="redo_log2.png"></p> <p><font color="#FF0000" size="4">生产案例：假设你执行的查询语句，需要查询大量的数据到缓存页里去，此时可能会导致大量的脏页需要刷回磁盘，才能腾出足够的内存空间来执行这条查询语句。在这种情况下，可能你会发现，突然莫名其妙的执行某个查询语句慢了很多，平时只要几十毫秒的查询，这次花了几秒，因为你要等待大量脏页刷回磁盘，然后语句才能执行</font></p> <p>还有另外一种脏页刷磁盘的契机，我们知道redo log buffer中的redo log本身也会随着各种条件刷入磁盘，比如redo log buffer里的数据超过容量的一定比例了，或者是事务提交的时候，都会强制把buffer里的redo log刷回磁盘。<br>
然后我们也知道，磁盘上是有多个日志文件的，他会不停的写，如果所有的日志文件都写满了，他会回到第一个日志文件再次写入，这些日志文件是不停的循环写入的。所以<font color="#FF0000" size="4">其实在日志文件都被写满的情况下，也会触发一次脏页刷新。</font></p> <p>主要原因是假如第一个日志文件的redo log对应的缓存页的数据一直没有被刷入磁盘，一旦你往里面写入了别的日志，此时万一数据库崩溃，你之前更新过的数据是不是就丢失了？<br> <font color="#0000FF" size="4">所以一旦你把所有的日志文件都写满了，重新开始从第一个日志文件开始写的时候，他会判断一下，如果是你第一个日志文件里的一些redo log对应的缓存页，迄今为止都没有刷入磁盘，那么此时必然要把那些马上要被覆盖的redo log更新的缓存页都刷入到磁盘</font>，如下图所示：<br> <img src="/docs/assets/img/redo_log_flush_disk.e9b123b3.png" alt="redo log刷入磁盘的特殊时机" title="redo_log_flush_disk.png"></p> <p><strong>尤其是在这种刷脏页的情况下，因为redo log所有日志文件都写满了，此时会导致数据库直接hang死，无法处理任何更新请求，因为执行任何一个更新请求都必须要写redo log，此时你需要刷新一些脏页到磁盘，然后才能继续执行更新语句，把更新语句生成的redo log从第一个日志文件开始覆盖写入</strong>。</p> <p>综上所述：到线上数据库的查询和更新语句莫名其妙出现性能抖动，很有可能就是上述两种情况导致的大量脏页刷入磁盘，你要等刷入磁盘后，才能继续执行。<br> <img src="/docs/assets/img/redo_log_flush_disk2.ca42aeb5.png" alt="redo log刷入磁盘的特殊时机" title="redo_log_flush_disk2.png"></p> <h2 id="上述问题导致数据库性能抖动的优化方案"><a href="#上述问题导致数据库性能抖动的优化方案" class="header-anchor">#</a> 上述问题导致数据库性能抖动的优化方案</h2> <p>上述两个场景导致大量的缓存页flush到磁盘，就会导致莫名其妙的出现SQL语句性能抖动了。<br>
优化的核心思路就两个：<br>
第一种：减少刷磁盘的频率<br>
第二种：加快刷入磁盘的速度<br>
第一种方案可以抛弃，因为你的缓存页正常被使用时，总有被填满的时候，我们没法控制，一旦缓存页被填满就会导致大量缓存页flush到磁盘。除非你给机器加大内存，给buffer pool分配的空间大一些。<br> <font color="#FF0000" size="4">第二种方案的关键是尽可能减少flush缓存页到磁盘的时间。建议可以采用SSD固态硬盘，然后设置一个参数，innodb_io_capacity,这个参数就是告诉数据库采用多大的IO速率把缓存页flush到磁盘里去。</font></p> <p><strong>fio是linux上一种用于测试磁盘最大随机io速率的工具</strong>。</p> <p><font color="#0000FF" size="4">实际在刷入磁盘的时候，它会根据innodb_io_capacity乘以一个百分比进行刷磁盘，这个百分比就是脏页的比例，是由innodb_max_dirty_pct参数控制的，默认是75%，这个参数一般不用动。</font></p> <p><font color="#FF0000" size="4">还有一个参数：innodb_flush_neighbors,它的意思是flush缓存页到磁盘的时候可能会把缓存页临近的其他缓存页也刷入磁盘。可以把这个参数值设置为0，禁止刷临近缓存页到磁盘。</font></p> <h2 id="磁盘数据页的存储结构"><a href="#磁盘数据页的存储结构" class="header-anchor">#</a> 磁盘数据页的存储结构</h2> <h3 id="数据库的索引原理及查询原理"><a href="#数据库的索引原理及查询原理" class="header-anchor">#</a> 数据库的索引原理及查询原理</h3> <p>数据库最终所有的数据（包括我们建的各种表以及表里的数据）都是要存放在磁盘上的文件里的，然后在文件里存储的数据格式就是数据页，那么大量的数据页在磁盘文件里是怎么存储的呢？<br>
首先要明白一点，大量的数据页是按照顺序一页一页存放的，然后相邻数据页之间会采用双向链表的格式相互引用，如下图：
<img src="/docs/assets/img/data_page_list.eb2667d1.png" alt="文件中数据页存放规则" title="data_page_list.png"></p> <p>其实一个数据页在磁盘里就是一段数据，数据页里包含两个指针，一个指向自己上一个数据页的物理地址，一个指针指向自己下一个数据页的物理地址，大概可以认为类似下面这样：<br> <img src="/docs/assets/img/data_page_list2.c8e6c3f2.png" alt="文件中数据页存放规则" title="data_page_list2.png"><br>
每个数据页里可以认为就是DataPage开头一直到||符号之间的一段连续的数据，可以认为就是数据页。<br>
然后数据页内部会存储一行一行的数据，也就是平时我们在表里插入的一行一行的数据就会存储在数据页里，然后数据页里每行数据都会按照主键大小进行排序存储，同时每行数据都有一个指针指向下一行数据的位置，组成单项链表，如下图：
<img src="/docs/assets/img/data_page_list3.abe9cb7c.png" alt="文件中数据页存放规则" title="data_page_list3.png"></p> <h2 id="数据库是如何根据查询语句搜索数据的"><a href="#数据库是如何根据查询语句搜索数据的" class="header-anchor">#</a> 数据库是如何根据查询语句搜索数据的？</h2> <p>没有索引的情况下，数据库是如何根据查询语句搜索数据的？<br> <font color="#FF0000" size="4">我们应该知道数据页之间是组成双向链表的，然后数据页内部的数据行是组成单向链表的，而且数据行是根据主键从小到大排序的。</font><br>
然后每个<strong>数据页里都会有一个页目录，里面存的是主键跟所在槽位的映射关系，如下图所示</strong>：<br> <img src="/docs/assets/img/data_page_list4.6dbd717a.png" alt="文件中数据页存放规则" title="data_page_list4.png"></p> <p>假设你要根据主键查找一条数据，并且假设这个表里没有几条数据，只存了一个数据页。首先会到数据页的页目录里根据主键进行二分查找，找到主键对应的数据在哪个槽位里，然后到那个槽位里去，遍历槽里的每一行数据，就能快速找到那个主键对应的数据了。</p> <p><strong>每个槽位里都有一组数据行</strong>。</p> <p>假设根据非主键查找呢？<br>
那就尴尬了，此时你没法使用主键的那种二分查找方式，只能进入到数据页里，根据单向链表依次遍历查找数据了，这样的性能就很差了。</p> <p>下面来说说有很多数据页的情况：<br>
假设你没有建立任何索引，那么无论你根据主键查询还是根据其他字段为条件查询，都没有什么取巧的办法。<br>
因为表里的所有数据页都是组成双向链表的，查找的时候，要先把第一个数据页给加载到Buffer Pool的缓存页中，然后如果你是根据主键查找的话，就在数据页内使用二分查找的方式；如果是根据非主键查询的话，就只能根据数据行的单向链表来遍历查找，如下图：<br> <img src="/docs/assets/img/data_page_list5.abfe1fa7.png" alt="文件中数据页存放规则" title="data_page_list5.png"><br>
假设第一个数据页没有找到你要的数据，怎么办呢？<br>
没办法，只能根据数据页组成的双向链表，找到下一个数据页，然后加载到Buffer Pool的缓存页里去，然后按照上述的方法在缓存页查找数据。<br>
如果还是查不到呢？<br>
那就只能根据双向链表加载下一个数据页到Buffer Pool的缓存页里去，依次类推，循环往复。</p> <p>其实上面的过程就是<strong>全表扫描</strong>。</p> <h2 id="不断在表中插入数据时-物理存储是如何进行页分裂的"><a href="#不断在表中插入数据时-物理存储是如何进行页分裂的" class="header-anchor">#</a> 不断在表中插入数据时，物理存储是如何进行页分裂的？</h2> <p>往表里不断插入 数据时，会涉及到一个<font color="#FF0000" size="4">页分裂的过程</font>，也就是说，表里是如何出现一个又一个的数据页的。</p> <p>数据页内部的数据行会组成一个单向链表，如下图所示：<br> <img src="/docs/assets/img/data_page_list6.69e4fbc5.png" alt="文件中数据页存放规则" title="data_page_list6.png"><br>
上图中是一行一行的数据，刚开始<font color="#FF0000" size="4">第一行是起始行，它的行类型是2，是最小的一行</font>，然后它有一个指针指向了下一行数据，每一行数据都存字段的值，然后每一行通过指针指向下一行数据，<font color="#FF0000" size="4">普通数据行的类型都是0，最后一行 的行类型是3，代表最大的一行。</font></p> <p>假设你不断的往表里插入数据，如果第一个数据页满了，那么就需要在搞一个数据页，如下图：<br> <img src="/docs/assets/img/data_page_list7.ee1df72a.png" alt="文件中数据页存放规则" title="data_page_list7.png"><br>
但是此时会遇到一个问题，后续我们会讲到索引的机制，<font color="#FF0000" size="4">索引运作的一个核心基础就是要求你后一个数据页里的主键值都必须大于前一个数据页里的主键值。</font></p> <p>如果你的主键是自增的，还可以 保证这一点；但是如果你的主键不是自增长的，可能会出现后一个数据页里的主键值，有的小于前一个数据页里的主键值。</p> <p>所以此时会出现一个过程，叫<strong>页分裂</strong>，就是万一你的主键值都是你自己设置的，那么在增加一个新的数据页的时候，可能会把前一个数据页里主键值较大的挪到后一个数据页里去，然后把你插入的较小的数据挪到上一个数据页里去，保证新数据页里的主键值都比上一个数据页里的主键值大。<br> <img src="/docs/assets/img/data_page_list8.fa12e30a.png" alt="文件中数据页存放规则" title="data_page_list8.png"><br>
如上图所示，第一个数据页里有1，5,6三条数据，第二个数据页里有，2,3,4三条数据，明显第二个数据页里的主键值比第一个数据页里的主键值要小，这是不允许的。<br>
此时会出现页分裂的过程，把新数据页的两条数据挪到上一个数据页，上一个数据页挪两条数据到新数据页中去，如下图：<br> <img src="/docs/assets/img/data_page_list9.1994787d.png" alt="文件中数据页存放规则" title="data_page_list9.png"></p> <p>有了页分裂这个过程，保证了每个数据页里的主键值的规则，就能为后续的索引打下基础。</p> <h2 id="基于主键的索引是如何设计的"><a href="#基于主键的索引是如何设计的" class="header-anchor">#</a> 基于主键的索引是如何设计的</h2> <p>假设我们有多个数据页，我们想根据主键来查询数据，那么直接查询也是不行的，因为我们不知道主键到底在哪里？<br> <img src="/docs/assets/img/data_page_list10.b26d1517.png" alt="文件中数据页存放规则" title="data_page_list10.png"><br>
比如上图，你想查找id=4的数据，你怎么知道在哪个数据页里？<br>
所以假设是这个样子的话，你还是只能走全表扫描了。<br>
所以此时就需要针对主键设计一个索引了，针对主键的索引其实就是<font color="#FF0000" size="4">主键目录，就是把每个数据页的页号，还有数据页里最小的主键值放在一起，组成一个索引目录。</font> 如下图所示：<br> <img src="/docs/assets/img/data_page_list11.6f8d69dd.png" alt="文件中数据页存放规则" title="data_page_list11.png"><br>
现在有了上图的主键目录就方便了，可以直接到主键目录去搜索，比如你要找id=3的数据，此时就会根据每个数据页的最小主键来比，首先id=3大于了数据页2里的最小主键值1，接着小于了数据页8里的最小主键值4。</p> <p>所以既然如此，你直接就可以定位到id=3的数据一定是在数据页2里的！</p> <p><strong>使用二分查找查找数据页：假设你有很多的数据页，在主键目录里就会有很多的数据页和最小主键值，此时你完全可以根据二分查找的方式来找你要找的id到底在哪个数据页里</strong>！</p> <p>所以这个效率是非常之高的，而类似上图的主键目录，就可以认为是主键索引。</p> <p>而大家都知道我们的数据页都是一坨一坨的连续数据放在很多磁盘文件里的，所以只要你能够根据主键索引定位到数据所在的数据页，此时假设我们有别的方式存储了数据页跟磁盘文件的对应关系，此时你就可以找到一个磁盘文件。</p> <p>而且我们假设<strong>数据页在磁盘文件里的位置也就是offset偏移量</strong>，你也是可以知道的，此时就可以直接通过随机读的方式定位到磁盘文件的某个offset偏移量的位置，然后就可以读取连续的 一大坨数据页了！</p> <h2 id="索引的页存储物理结构-是如何用b-树来实现的"><a href="#索引的页存储物理结构-是如何用b-树来实现的" class="header-anchor">#</a> 索引的页存储物理结构，是如何用B+树来实现的？</h2> <p>只要在一个主键索引里包含每个数据页跟它的最小主键值，就可以组成一个索引目录，然后后续你根据主键值查找，就可以在索引目录里二分查找直接定位到那条数据所在的数据页，接着到数据页里二分查找定位那条数据就可以了，如下图：<br> <img src="/docs/assets/img/data_page_list11.6f8d69dd.png" alt="文件中数据页存放规则" title="data_page_list11.png"><br>
但是现在问题来了，假设你的数据很多很多，有上千万的数据，甚至单表几亿数据都是有可能的，此时可能会有大量的数据页，然后你的索引目录里就要存储大量的数据页和最小主键值，这也是有问题的。</p> <p>所以在考虑这个问题的时候，实际上是采取了一种把索引数据存储在数据页里的方式来做的。<br>
也就是说，表数据是存在数据页里，然后表的索引其实也是存在数据页里的，索引放到页里之后，就会有索引页，假设你有很多很多的数据页，那么此时你就会有很多的索引页，如下图所示：<br> <img src="/docs/assets/img/data_page_list12.5398c2a4.png" alt="文件中数据页存放规则" title="data_page_list12.png"><br>
但是现在又有问题了，因为你有太多的索引页，因为你需要知道，应该在哪个索引页里去找你的主键数据，这也是个大问题？</p> <p>于是接下来我们把索引页多加一个层级出来，在更高的索引层级里，保存了每个索引页和索引页里的最小主键值，如下图所示：<br> <img src="/docs/assets/img/data_page_list13.5d335786.png" alt="文件中数据页存放规则" title="data_page_list13.png"></p> <p>现在就好了，假设我们要查询id=46的，直接先到最顶层的索引页35里面去找，直接通过二分查找就可以定位到下一步应该到索引页20（里面存了数据页的页号和最小主键值）里面去找，接下来在索引页20里二分查找，可以定位到数据应该在数据页8里，在进入数据页8里，就可以找到id=46的那行数据了。</p> <p>那么问题又来了，假设最顶层的索引页里存放的下层索引页的页号也非常多，怎么办呢？<br>
此时可以再次分裂，再加一层索引页，比如下图：<br> <img src="/docs/assets/img/data_page_list14.08a5fe72.png" alt="文件中数据页存放规则" title="data_page_list14.png"></p> <p>上图想不想一棵树？<br>
没错，这就是一棵<strong>B+树</strong>，MySQL的索引就是用B+树实现的。<br>
这就是索引最真实的物理存储结构，采用跟数据页一样的数据结构来存储，一个索引就是很多数据页组成的B+树。</p> <h2 id="更新数据的时候-自动维护的聚簇索引到底是什么"><a href="#更新数据的时候-自动维护的聚簇索引到底是什么" class="header-anchor">#</a> 更新数据的时候，自动维护的聚簇索引到底是什么？</h2> <p><strong>聚簇索引：如果一颗大的B+树索引数据结构里，叶子节点就是数据页本身，那么我们可以称这个B+树索引为聚簇索引</strong>。<br>
在innoDB的存储引擎里，对数据增删改的时候，就是直接把你的数据页放在聚簇索引里的。比如你插入数据就是在数据页里插入数据。<br>
如果你的数据页开始分裂了，此时会自动调整数据页内部的行数据，保证数据页内的主键值都是有顺序的，下一个数据页里的主键值大于上一个数据页里的所有主键值。<br>
一般索引页里可以放很多索引条目，<strong>即使你是亿级的大表，所建的索引的层级也就三四层而已</strong>。</p> <h2 id="主键之外的字段建立的二级索引-又是如何运作的"><a href="#主键之外的字段建立的二级索引-又是如何运作的" class="header-anchor">#</a> 主键之外的字段建立的二级索引，又是如何运作的？</h2> <p>主键外的其它字段建立索引的原理：<br>
假设你要基于其他字段建立索引，比如name，age之类的字段，都是同一个原理。比如你插入数据的时候，一方面会把完整数据插入到聚簇索引的叶子结点的数据页里去，同时维护好聚簇索引，另一方面，会为其他字段建立的索引，再建立一棵B+树。<br>
比如你以name字段建立一个索引，那么此时你插入数据的时候，就会从新搞一个B+树，B+树的叶子节点也是数据页，但是这个数据页里仅仅存放主键字段和name字段，如下图：<br> <img src="/docs/assets/img/data_page_list15.5023eacd.png" alt="文件中数据页存放规则" title="data_page_list15.png"><br>
聚簇索引和name字段的B+树是相互独立的两棵树。<br>
name字段的B+树里，<strong>叶子节点的数据页中name的值都是按照大小排序的，同时下一个数据页里的name字段值都大于上一个数据页里的name字段值</strong>，这个整体的排序规则跟聚簇索引里按照主键的排序规则是一样的。<br> <img src="/docs/assets/img/data_page_list16.80a0036d.png" alt="文件中数据页存放规则" title="data_page_list16.png"></p> <p><font color="#FF0000" size="4">根据name字段搜索数据的过程：</font>从name字段的B+树的根节点开始找，一层层往下找，一直找到叶子节点的数据页里，定位到name字段对应的主键值。<br>
此时针对select * from table where name='xxx'这样的语句，你先根据name字段在name字段的B+树索引找，找到叶子节点，也仅仅是能找到对应的主键值，而找不到这行完整的数据。<br>
所以此时需要<strong>回表</strong>，就是说还需要根据主键值，再到聚簇索引里从根节点开始，一路找到叶子节点的数据页，定位到主键对应的完整数据行，此时才能把select *对应的所有字段值拿出来。</p> <p>因为我们根据name字段的索引B+树找到主键后，还需要根据主键去聚簇索引里找，所以一般name字段这种普通字段的索引称为<strong>二级索引</strong>，把聚簇索引称为<strong>一级索引</strong>，这就是普通字段的索引的运行原理。</p> <p>多个字段建立联合索引，比如name+age<br>
联合索引的运行原理也是一样的，只不过在这颗独立的B+树索引里，叶子节点的数据页存放的是id+name+age，然后默认按照name排序，name一样就按照age排序，不同的数据页之间的name+age值的排序也是如此。<br>
然后这个name+age的联合索引的B+树索引页里，放的是下层节点的页号和最小的name+age的值，以此类推，当你根据name+age搜索的时候，就会走name+age联合索引的这棵B+树了，搜索到了主键后，再根据主键到聚簇索引里去搜索。</p> <h2 id="插入数据时到底是如何维护好不同索引的b-树的"><a href="#插入数据时到底是如何维护好不同索引的b-树的" class="header-anchor">#</a> 插入数据时到底是如何维护好不同索引的B+树的？</h2> <p>插入数据时是如何维护不同索引的B+树的？<br>
首先，表刚建的时候，它就是一个数据页，这个数据页属于聚簇索引的一部分，而且目前还是空的。<br>
此时如果你插入数据，就是直接在这个数据页里插入就可以了，也没必要给它弄索引页，如下图：<br> <img src="/docs/assets/img/page_index1.02c27ac1.png" alt="索引页结构" title="page_index1.png"></p> <p>这个初始的数据页其实就是根页，每个数据页内部默认就有一个基于主键的页目录，所以此时你根据主键来搜索都是没问题的，直接在唯一一个数据页里</p> <p>当表里的数据越来越多的时候，如果第一个数据页满了，会再弄一个数据页，根据主键值的大小进行移动，让两个数据页的数据根据主键值排序，并且保证第二个数据页的主键值都大于第一个数据页里的主键值，如下图:<br> <img src="/docs/assets/img/page_index2.67e5c4e4.png" alt="索引页结构" title="page_index2.png"></p> <p>那么此时根页在哪呢？<br>
此时根页就升级为索引页了，这个根页里存放的就是两个数据页的页号和他们里面的最小主键值，所以此时看起来如下图：<br> <img src="/docs/assets/img/page_index3.83743862.png" alt="索引页结构" title="page_index3.png"></p> <p>接着你肯定会不停的往表里插入数据，然后数据页不停的进行页分裂，分裂出越来越多的数据页。<br>
此时你唯一的一个索引页，也就是根页里存放的数据页索引条目越来越多，连你的索引页都放不下了，那你就让一个索引页分裂为两个索引页，然后根页继续往上走一个层级引用两个索引页。如下图：<br> <img src="/docs/assets/img/page_index4.a39b0b81.png" alt="索引页结构" title="page_index4.png"><br>
接着就是以此类推了，你的数据页越来越多，那么根页指向的索引页也不停的分裂，分裂出更多的索引页，当你下层的索引页数量太多的时候，会导致你的根页指向的索引页太多了，此时根页继续分裂为多个索引页，根页再次往上提上去一个层级。<br>
这其实就是增删改时，整个聚簇索引维护的一个过程，其实其他二级索引也是类似的一个原理。<br> <img src="/docs/assets/img/page_index5.5d283ba6.png" alt="索引页结构" title="page_index5.png"></p> <h2 id="一个表里是不是索引搞的越多越好"><a href="#一个表里是不是索引搞的越多越好" class="header-anchor">#</a> 一个表里是不是索引搞的越多越好？</h2> <p>那就大错特错了。<br> <font color="#FF0000" size="4">B+树的特性：那就是数据页/索引页里的记录组成一个单向链表，而且是按照数据大小有序排列的；然后数据页/索引页之间组成双向链表，而且也是按照数据大小有序排列的，所以B+树索引是一个完全有序的数据结构，无论是页内还是页之间。</font><br> <strong>索引的缺点：</strong> 一个是空间上，一个是时间上。<br>
空间上，如果你给很多字段创建索引，那么就会创建很多棵B+树，每一颗B+树都要占用很多的磁盘空间。<br>
时间上，你要是搞了很多索引，那么在你进行增删改的时候，每次都需要维护各个索引的数据的有序性。<br>
所以你不停的增删改，必然会导致各个数据页之间的值可能会没有顺序，比如数据页里插入了一个比较小的值，居然比上一个数据页的值还要小！此时就没有办法了，只能进行数据页的挪动，维护页之间的顺序。</p> <p>或者是你不停的插入，数据页不停的分裂，不停的增加新的索引页，这个过程也是耗费时间的。</p> <h2 id="通过一步一图来深入理解联合索引查询原理以及全值匹配规则"><a href="#通过一步一图来深入理解联合索引查询原理以及全值匹配规则" class="header-anchor">#</a> 通过一步一图来深入理解联合索引查询原理以及全值匹配规则</h2> <p>我们设计系统的时候<strong>一般是设计联合索引，原因是尽可能让索引数量小一些，避免磁盘占用太多，增删改性能太差</strong>。</p> <p>假设我们有一个学生成绩表，这个表有个id字段，是自增长的主键，默认就会基于它做一个聚簇索引。<br>
成绩表包含学生班级、学生姓名、科目名称、分数四个字段，平时可能查的最多的就是找某个班的某个学生某科的成绩。<br>
所以我们基于班级、学生姓名和科目名称建立一个联合索引。<br> <img src="/docs/assets/img/union_index1.1bc4b9e3.png" alt="联合索引结构图" title="union_index1.png"></p> <p>图中有两个数据页，第一个数据页有3条数据，每条数据都包含了联合索引的3个字段值和主键值，数据页内部是按照顺序排序的。<br>
首先按照班级字段的值来排序，如果一样则按照学生姓名排序，如果还一样，则按照科目名称来排序，所以数据页内部是按照三个字段的值来排序的，而且还组成了单向链表。</p> <p>然后数据页之间也是有顺序的，第二个数据页里的三个字段的值一定都大于上一个数据页里三个字段的值，比较方法也是按照班级名称、学生名称、科目名称依次来比较的，数据页之间组成双向链表。</p> <p>索引页里就两条数据，分别指向两个数据页，索引里存放的是数据页里最小的那个数据的值。</p> <p>索引页内部的数据页组成单向链表并且是有序的，如果你有多个索引页，那么索引页之间也是有序的，组成了双向链表。</p> <p>假设我们想搜索：一班+张小强+数学的成绩，此时可能会写类似下面的sql，select * from student_score where class_name='一班' and student_name='张小强' and subject_name='数学'。<br>
此时就涉及到了一个索引的使用规则，那就是你发起的sql语句里，where条件里几个字段都是基于等值来查询，都是用的等于号。而且where条件里的几个字段的名称和顺序也跟你联合索引里一模一样。此时就是<font color="#FF0000" size="4">等值匹配规则</font>，上面的sql语句是百分之百可以使用联合索引来查询。</p> <p>查询的过程：首先到索引页里去找，因为索引页里有多个数据页的最小值记录，此时直接在索引页里基于二分查找就可以了。先根据班级名称来找1班这个值对应的数据页，直接可以定位到他所在的数据页，如下图：<br> <img src="/docs/assets/img/page_index6.a02618c5.png" alt="联合索引结构图" title="page_index6.png"><br>
然后你直接找到索引页中索引指向的数据页，数据页内部是单向链表，你也是根据二分查找来找，先按1班这个值来找，你会发现几条数据都是1班，然后可以按照张小强这个姓名来二分查找，此时你会发现多条数据是张小强，最后按照科目名称进行二分查找。很快就可以定位到下图中的一条数据，1班的张小强的数学成绩对应的主键id=127，如下图所示：<br> <img src="/docs/assets/img/page_index7.ed0e2f2c.png" alt="联合索引结构图" title="page_index7.png"><br>
然后根据主键id=127到聚簇索引里按照一样的思路，从索引根节点开始二分查找迅速定位到下层的索引页，在不停的找，很快就可以找到id=127那条数据，然后从里面提取所有的字段，包括分数就可以了。</p> <h2 id="最常见和最基本的索引使用规则"><a href="#最常见和最基本的索引使用规则" class="header-anchor">#</a> 最常见和最基本的索引使用规则</h2> <p><strong>如果你使用了联合索引的所有字段了，但是顺序和联合索引中字段的顺序有差异，也没关系，MySQL自动优化为按联合索引的字段顺序去找</strong>。<br>
第二个规则，就是<font color="#FF0000" size="4">最左侧列匹配</font>，意思是假设我们的联合索引是KEY(class_name,student_name,subject_name),那么不一定必须要在where语句里根据三个字段来查，其实只要根据最左侧的部分字段来查，也是可以的。</p> <p>比如你的sql如下：select * from student_score where class_name='' and student_name=''，就是查某个班级某个学生的所有科目的成绩是ok的。</p> <p>假设你的sql是：select * from student_score where subject_name=''，这样是不行的，<strong>因为联合索引的B+树里，是必须先按照class_name查，再按student_name查，不能跳过前面两个字段，直接按最后一个字段subject_name来查</strong>。</p> <p>假设你的sql是：select * from student_score where class_name='' and subject_name=''，那么只有class_name可以在索引里搜索，剩下的subject_name是没法在索引里搜索的，道理同上。</p> <p><strong>所以在建立索引的过程中，必须考虑好联合字段索引的顺序，以及平时写sql的时候要按照哪几个字段来查</strong>。</p> <p>第三个规则，<font color="#FF0000" size="4">最左前缀匹配原则（模糊符号必须在右侧）</font>，即如果你要按照like语法来查，比如select * from student_score where class_name like '1%',查找所有1开头的班级的分数，这也是可以用到索引的。</p> <p>但是如果你写class_name like '%班级'，在左侧用一个模糊匹配符，那就没法使用索引了，因为不知道你最左前缀是什么，怎么去索引里找？</p> <p>第四个规则，就是<font color="#FF0000" size="4">范围查找规则</font>，意思是说我们可以使用select * from student_score where class_name &gt;'1班' and class_name&lt;'5班' 这样的语句范围内查找几个班级的分数，这个时候也是走索引的。</p> <p>因为我们的索引的最下层的数据页都是按照顺序组成双向链表的，所以完全可以先找到‘1班’对应的数据页，再找到‘5班’对应的数据页，两个数据页中间的那些数据页，就全都是在你范围内的数据了！</p> <p>但是如果你要写select * from student_score where class_name &gt;'1班' and class_name&lt;'5班' and studeng_name&gt;'xxx'，这里只有class_name是可以基于索引来找，student_name的范围查询是没法用到索引的！</p> <p><font color="#FF0000" size="4">这也是一条规则，就是你的where语句里有范围查询，那只有对联合索引里最左侧的列进行范围查询才会走索引。</font></p> <p>第五个规则，<font color="#FF0000" size="4">等值匹配+范围匹配的规则</font>，如果你要用select * from student_score where class_name ='1班' and student_name&gt;'' and subject_name&lt;'',那么你首先可以根据class_name在索引里精确定位到一波数据，接着这波数据里的student_name都是按照顺序排列的，所以student_name&gt;''也会基于索引来找，但是接下来的subject_name是不能用索引的。</p> <h2 id="当我们在sql里进行排序的时候-如何才能使用索引"><a href="#当我们在sql里进行排序的时候-如何才能使用索引" class="header-anchor">#</a> 当我们在SQL里进行排序的时候，如何才能使用索引？</h2> <p>假设我们建立了一个INDEX(xx1,xx2,xx3)这样的一个联合索引，这个时候默认情况下，索引树里本身就是依次按照xx1，xx2、xx3三个字段的值进行排序的，那么此时你在运行select * from table order by xx1,xx2,xx3 limit 100这样的语句，你觉得还需要再进行排序吗？</p> <p>显然是不用了。直接按照索引树里的顺序把xx1，xx2，xx3三个字段按照从小到大的值获取前面100条就可以了。<br>
然后拿到100条数据的主键，再去聚簇索引里回表查询剩余的所有字段。</p> <p><font color="#0000FF" size="4">所以说，在你的sql语句里，应该尽量按照联合索引的字段顺序进行order by排序，这样就可以直接利用联合索引里数据的有序性，到索引树里直接按照字段值的顺序去获取你需要的数据。</font><br> <font color="#FF0000" size="4">但是直接利用联合索引字段的顺序排序有一定的限制：就是你要么按照联合索引的字段升序查询，要么按照联合索引的字段降序查询</font>，有的升序有的降序的话，就不会再走联合索引了。</p> <p>如果都是升序排列，直接就从索引树里最小的开始读取一定的条数就可以了；如果都是降序排列，那就从索引树里最大的数据开始读取一定的条数就可以了。</p> <h2 id="在sql里进行分组的时候-如何才能使用索引"><a href="#在sql里进行分组的时候-如何才能使用索引" class="header-anchor">#</a> 在SQL里进行分组的时候，如何才能使用索引？</h2> <p>假设你的sql语句如下：<br>
select count(*) from table group by xx,似乎看起来你需要把所有的数据放到一个临时磁盘文件里还有加上部分内存，去搞一个分组，按照指定字段的值分成一组一组的，接着对每一组都执行一个聚合函数，这个性能是极差的，因为毕竟涉及到了大量的磁盘交互。</p> <p>因为在我们的索引树里默认都是按照指定的一些字段排序好的，其实字段相同的值都是在一起的，假设要走索引去执行分组后再聚合，那性能一定是比磁盘文件里自行要快很多了。<br> <strong>所以通常而言，对于group by后的字段，最好也是按照联合索引里最左侧的字段开始，按照顺序排列开来，这样的话，其实就可以完美应用索引来提取一组一组的数据，然后针对每一组的数据执行聚合函数就好了</strong>。<br> <img src="/docs/assets/img/page_index8.a8369efb.png" alt="group by和order by如何走联合索引" title="page_index8.png"><br> <img src="/docs/assets/img/page_index9.2794d53e.png" alt="group by和order by如何走联合索引" title="page_index9.png"></p> <h2 id="回表查询对性能的损害以及覆盖索引是什么"><a href="#回表查询对性能的损害以及覆盖索引是什么" class="header-anchor">#</a> 回表查询对性能的损害以及覆盖索引是什么？</h2> <p><img src="/docs/assets/img/page_index10.23fa0d62.png" alt="走联合索引还是全表扫描" title="page_index10.png"><br> <strong>覆盖索引</strong>：它不是一种索引，它是指基于索引查询的一种方式。<br>
意思是针对类似于select xx1,xx2,xx3 from table order by xx1,xx2,xx3这样的语句，你仅仅需要联合索引里的几个字段的值，那么其实只要扫描联合索引的索引树就可以了，不需要回表查询聚簇索引里的其他字段了。</p> <p>即使你真的要回表到聚簇索引，那你要尽可能的用limit、where之类的语句，限定一下回表到聚簇索引的次数，从联合索引里筛选少量数据，这样回表的次数也会减少，进而提升性能。</p> <h2 id="设计索引的时候-我们一般要考虑哪些因素呢"><a href="#设计索引的时候-我们一般要考虑哪些因素呢" class="header-anchor">#</a> 设计索引的时候，我们一般要考虑哪些因素呢？</h2> <p><img src="/docs/assets/img/design_index1.ad52ff44.png" alt="电商平台表设计" title="design_index1.png"></p> <p>设计好表结构之后，接下来要做的就是设计表的索引，这个设计索引的时候，我们要考虑的第一点，就是未来我们对表进行查询的时候，大概会如何进行查询？</p> <p>如果不知道没关系，在我们系统开发完，功能都跑通后，此时我们已经写完所有的SQL，这个时候稳定知道对表发起了什么样的查询语句了吧？</p> <p><font color="#FF0000" size="4">第一个索引设计原则：</font>针对你sql语句里的where、order by条件以及group by条件去设计索引。<br> <img src="/docs/assets/img/design_index2.240123c4.png" alt="电商平台表设计" title="design_index2.png"></p> <p>在设计索引的时候还得考虑其他因素，首先一个就是<font color="#FF0000" size="4">字段基数问题，</font> 举个例子，假设有10万行数据，但是字段A只有两个值，要么是0，要么是1，那么它的基数就是2。<br>
假设你要针对上面说的这种字段建立索引的话，还不如走全表扫描，因为你的索引数据仅仅包含了0和1两种值，根本没法进行快速的二分查找，所以这个时候选这种基数很低的字段建立索引意义就不大了。</p> <p><font color="#FF0000" size="4">第二个索引设计原则：</font><strong>一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那样才能发挥出B+树二分查找的优势来</strong>。</p> <p><font color="#FF0000" size="4">第三个索引设计原则：</font>尽量对那些<strong>字段类型比较小的列来设计索引</strong>，因为字段类型小的话，占用的磁盘空间也小，此时你搜索时，性能也会好一些。</p> <p><strong>前缀索引（<font color="#FF0000" size="4">第四个索引设计原则</font>）</strong>：<br> <img src="/docs/assets/img/design_index3.575bccf7.png" alt="前缀索引设计" title="design_index3.png"><br> <font color="#FF0000" size="4">第五个索引设计原则：</font>不要在索引列上嵌套函数。<br>
比如where function(a)=xx,这种是不会走索引的。</p> <p>你不停的增删改数据，就会不停的更新你的索引树。<br>
因为你插入的数据值可能不是按照顺序来的，很可能会导致索引树里的某个页会自动分裂，这个页分裂的过程就很耗费时间，<strong>因此一般让大家设计索引别太多，建议两三个联合索引就应该覆盖掉你这个表的全部查询了</strong>。</p> <p>否则索引太多，必然会导致你增删改的时候，要更新多个索引树。</p> <p><font color="#FF0000" size="4">另外关键一点，建议大家主键一定是自增的，别用UUID之类的</font>，因为主键自增，那么起码你的聚簇索引不会频繁的分裂，主键值都是有序的，就会自然的新增一个页而已，但是如果你使用的是UUID，那么会导致聚簇索引频繁的页分裂。</p> <h2 id="案例实战-陌生人社交app的mysql索引设计实战"><a href="#案例实战-陌生人社交app的mysql索引设计实战" class="header-anchor">#</a> 案例实战：陌生人社交APP的MySQL索引设计实战</h2> <p>我们通过一些条件去筛选一些好友，社交app，筛选的话一般是针对用户表进行筛选，假设用户表叫user_info.<br> <img src="/docs/assets/img/momo1.a70e045f.png" alt="陌生人用户表的信息" title="momo1.png"></p> <p>针对这个用户表进行搜索，科不仅仅是筛选那么简单，除了where条件，你肯定得<strong>支持分页</strong>吧，还有一点你稳定不是随便胡乱排序的吧，总得根据一定的规则对筛选出来的结果进行一个排序，把最符合你的期望的用户排在最上面，各位想想是不是？</p> <p>那么你的sql会类似这样：select xx from user_info where xx=xxx order by xx limit 1,10  。<br>
这样会出现一个难题，根据使用索引的规则，where条件语句必须是使用联合索引里最左侧开始的连续多个字段进行筛选，然后排序的时候也必须使用联合索引里最左侧开始的连续多个字段进行筛选。</p> <p>那问题就来了，假设你的sql需要按照年龄范围进行筛选，同时按照用户的评分进行排序，类似下面select xx from user_info where age between 20 and 25 order byscore，那就有问题了。</p> <p><strong>针对这个场景，你要明白的一个问题就是，往往类似这种SQL里，你的where条件和order by实际上大部分情况下是没法用到索引的</strong>！</p> <p><font color="#0000FF" size="4">根据前面的场景可知，在where和order by出现索引设计冲突，鱼与熊掌不可兼得的时候，到底是针对where去设计索引，还是针对order by去设计索引？</font></p> <p>一般这个时候往往是让where条件去使用索引来快速筛选出少部分数据，接着在进行排序，这样代价要小很多。</p> <p>确定根据where语句设计索引的时候，又犯难了，你要考虑用户在搜索潜在好友的时候，<strong>一般会用上哪些条件呢？我们要把哪些字段包含到联合索引里，这些字段按照上面顺序排列呢</strong>？</p> <p>我们首先要在联合索引里包含三个字段，省份、城市、性别。</p> <p>因为你搜索潜在好友，必定会搜索跟你在同一个地方的，然后搜索某个性别的其他用户。</p> <p>之前不是说过，基数太低的字段最好别放到索引中去，那省份、城市、性别都是基数非常小的几个字段，可选的值就那么几个，为什么要放到索引里去？</p> <p>规则是死的，但是人是活的。<br>
你想想，假设你就因为省份、城市、性别几个字段的基数太小了，此时<strong>不把他们几个包含到联合索引里去</strong>，那么你实际查询的时候都要基于这几个字段去搜索，此时你只能<strong>把这几个条件放到where语句的最后</strong>，那么每次查询都必须要先用联合索引查询出来一部分数据，接着加载到内存中去，然后再根据省份、城市、性别几个字段记性筛选，每次查询都得经过这么一个步骤，是不是很麻烦。</p> <p>所以与其如此，还不如把省份、城市、性别三个字段放在联合索引的最左侧，这样跟其他字段组成联合索引后，让大部分的查询都可以直接通过索引树就可以把where条件指定的数据筛选出来了。</p> <p>从前面可知，联合索引中已经确定了三个字段(province，city，sex)，因为他们三个是几乎每次查询都会用到的条件，使用频率高，先把他们放入联合索引的左侧，然后接着分析这个联合索引还需要放哪些字段？</p> <p>假设我们查询的时候不指定性别，而是指定了省份、城市，还加了一个年龄，也就是where province=xx and city=xx and age between 10 and 30，那此时怎么办呢，age不在索引里，age这块不会走索引。</p> <p>那如果把索引设计成（province，city，sex，age），此时你的语句写成where province=xx and city=xx and age between 10 and 30，也是没法让age用上索引，因为中间隔了个sex，所以此时是不符合<strong>最左侧连续多个字段的原则</strong>了。</p> <p><em>其实针对这个问题，完全不用担心，因为不限定性别，我们把语句写成where province=xx and city=xx and sex in('femail','mail') and age between 10 and 30，这样的话，就匹配最左连续多个字段的原则了。</em></p> <p>假设我们的查询语句里还有一些频繁使用的条件，通常都是兴趣爱好和性格特点，他们往往都有一些固定的枚举值。<br>
比如兴趣爱好可以有下面的可选值：运动、电影、旅游、烹饪，性格特点可以有：温柔、霸气、御姐、体贴、善良。</p> <p><font color="#0000FF" size="4">那么针对这样一些频繁使用的包含枚举值范围的一些字段，也完全可以加入到联合索引里去。</font>可以设计成（province，city，sex，hobby，character，age），假设有这么一个查询，按照省份、城市、性格和年龄进行搜索，此时SQL怎么写？</p> <p>还是按照之前的策略和思路：写成where province=xx and city=xx and sex in(xx,xx) and hobby in (xx,xx,xxx,xx,xx) and character in(xx,xx,xxx) and age between 10 and 30</p> <p><strong>也就是说即使你不需要按性别和爱好进行筛选，但是在SQL语句里你可以对这两个字段用in语句，把他们所有的枚举值都放进去。这样的话，就可以顺利的让province、city、character和age四个真正需要筛选的字段用上索引</strong>。</p> <p><font color="#FF0000" size="4">那么为什么一直强调age字段必须放到联合索引的最后一个呢？</font></p> <p>很简单，前面讲索引规则的时候说过，<strong>假设你where语句里有等值匹配，还有范围匹配，此时必须先让联合索引最左侧开始的多个字段使用等值匹配，接着最后一个字段是范围匹配</strong>。<br>
比如上面的语句：where province=xx and city=xx and sex in(xx,xx) and hobby in (xx,xx,xxx,xx,xx) and character in(xx,xx,xxx) and age between 10 and 30，完全是按照联合索引最左侧开始的连续四个字段（province、city、sex、hobby）进行等值匹配查询，然后最后一个字段使用的是范围匹配，这种就可以完全使用上面的索引。</p> <p>但是假设你要把age放在联合索引的中间位置，比如（province，city，sex，age，hobby，character），接着SQL写成where province=xx and city=xx and sex in(xx,xx) and age between 10 and 30 and hobby in (xx,xx,xxx,xx,xx) and character in(xx,xx,xxx) 的话，那么不好意思，只有province，city，sex，age几个字段可以使用上索引。</p> <p><font color="#FF0000" size="4">因为在SQL里，一旦你的一个字段做范围查询用到了索引，那么这个字段接下来的条件都不能使用索引了，这就是规则。<br>
所以说，实际设计索引的时候，必须把经常做范围查询的字段放在联合索引的最后一个，才能保证你的SQL里每个字段都能基于索引去查询。</font></p> <p>假设查询时还有一个条件，要根据用户登录时间在7天内来进行筛选，筛选最近7天登录过app的用户，表里有一个字段：latest_login_time.</p> <p>你要是在where条件里加上latest_login_time&lt;7天的语句，这个肯定是没法用上索引了。因为此处必定会用上一些计算或者函数，才能进行一些时间上的比对。</p> <p>而且假设你的查询里还有age进行范围查询，那么前面说过，范围查询的时候，也就只有第一个范围查询可以使用上索引，第一个范围查询之后的其他范围查询是用不上索引的。</p> <p>也就是说，即使你的索引设计成（province，city，sex，hobby，character，age，latest_login_time），然后你的where语句写成where xx xxx and age&gt;=xx and age&lt;=xxx and latest_login_time&gt;=xx,虽然age和latest_login_time都在联合索引里，但是按照规则，只有age范围查询可以用到索引，lastest_login_time是始终用不到索引的。</p> <p><font color="#FF0000" size="4">所以在设计表的时候，你就要考虑这个问题，此时你完全可以设计一个字段为：does_login_in_7_days,也就是说这个人7天内是否登陆过app。<br>
假设7天内登陆过app，这个值就是1，没有登陆过，就是0！这样就把一个时间字段转换为了一个枚举值的字段。</font></p> <p>接下来设计方案就简单了，可以设计这样一个联合索引（province，city，sex，hobby，character，does_login_in_7_days,age）,然后搜索的时候where语句里带上does_login_in_7_days=1即可，最后再跟上age范围查询，这样就可以让where语句里的字段都走索引来筛选。</p> <p>但有时候又怕另外一个问题，就是说万一你仅仅用联合索引里一些基数特别小的字段来筛选呢？</p> <p>比如说你要基于性别来筛选，筛选出所有的女性，可能会有上百万的数据，接着还要再磁盘中进行分页再排序？那会导致性能非常差。</p> <p>所以针对上述问题，可以针对那种基数很低的字段再加上排序字段单独额外设计一个辅助索引，专门用于解决where条件里都是基数很低的字段，然后还要排序后分页的问题，比如说可以设计一个联合索引：（sex,score）</p> <p>此时万一你写出如下sql：select xx from user_info where sex='femail' order by score limit xx and xxx,假设还用以前的那个联合索引，那就完蛋了，没法使用，不满足最左侧连续字段原则。</p> <p>但是使用我们设计的辅助索引（sex,score）呢？</p> <p>此时因为where条件里的字段是等值匹配，而且还是等于某个常量值，所以虽然order by后跟的score字段是（sex，score）索引里的第二个字段，没有从索引最左侧字段排列，但是它也可以使用索引来排序。原因如下：</p> <p>它会先根据where条件里sex=‘femail’在索引树里筛选出这部分数据，你可以想一下，这部分数据实际在索引树里也是按顺序排列在一起的，因为在索引里，会先按照sex排序，然后再按照score排序，所以可以想象，sex=‘femail’的数据都是在一块的。</p> <p>这部分字段本身就是按照score排序的，直接按照顺序取就对了，取的条数按照limit指定的数字就可以。</p> <p><strong>本章核心就是：尽量利用一两个复杂的多字段联合索引，抗下你80%以上的查询，然后利用一两个辅助索引抗下那20%的非典型查询，保证你90%以上的查询都能充分利用索引，就能保证你的查询速度和性能</strong></p> <h2 id="sql语句的执行计划和性能优化有什么关系"><a href="#sql语句的执行计划和性能优化有什么关系" class="header-anchor">#</a> SQL语句的执行计划和性能优化有什么关系</h2> <p>根据查询语句设计良好的索引，让所有的查询尽可能的都用上索引，这本身就是SQL优化的一个技巧，并不是说掌握了这个就掌握了所有的SQL优化技巧。这仅仅是其中的一个技巧罢了。</p> <p>实际上有时候往往你会发现数据库里有很多表，每个表的数据量也不小，然后写出来的SQL也比较复杂，各种关联和嵌套子查询，看得人眼晕，然后表面看起来这个SQL部分用上了索引，但是性能还是很差，这是为什么呢？</p> <p>针对复杂表结构和大数据量的上百行复杂SQL的优化，必须得建立在你先懂得这个复杂SQL是怎么执行的。</p> <p>这个SQL语句（不管简单还是复杂），在实际的MySQL底层，针对磁盘上的大量数据表、聚簇索引和二级索引，如何检索查询，如何筛选过滤，如何使用函数，如何进行排序，如何进行分组，到底怎么能把你想要的东西查出来，这个过程就是：<strong>执行计划</strong>！</p> <p><font color="#FF0000" size="4">也就是说，每次你提交一个SQL到MySQL，他内核里的查询优化器，都会针对这个SQL语句的语义去生成一个执行计划，这个执行计划就代表了，它会怎么查各个表，用哪些索引，如何做排序和分组，看懂了这个执行计划，你就学会了真正SQL优化的一半了。</font></p> <p><font color="#FF0000" size="4">当你看懂执行计划后，还能根据它的实际情况去想各种办法改写你的SQL语句，改良你的索引设计，进而优化SQL语句的执行计划，最终让SQL的性能得到提升，这个就是所谓的SQL调优。</font></p> <h2 id="以mysql单表查询来举例-看看执行计划包含哪些内容-const-ref-index-all"><a href="#以mysql单表查询来举例-看看执行计划包含哪些内容-const-ref-index-all" class="header-anchor">#</a> 以MySQL单表查询来举例，看看执行计划包含哪些内容(const,ref,index,all)</h2> <p>我们之前都知道，假设你写一个select * from table where id=xx，或者select * from table where name=xx的语句，直接可以通过聚簇索引或者二级索引+聚簇索引回表，轻松查到你想要的数据，<strong>这种根据索引快速查找数据的过程，在执行计划里称之为<font color="#FF0000" size="5">const</font>，意思是性能很高的常量级的</strong>。</p> <p>所以你以后再执行计划里看到const的时候，就知道他是直接通过索引定位到数据，速度极快，这就是const的意思。</p> <p><strong>但是这里有一个要点，你的二级索引必须是唯一的，才是属于const方式的，也就是说你必须建立unique key唯一索引，保证一个二级索引的每一个值都是唯一的，才可以</strong>。</p> <p>那么你是一个普通的二级索引呢？就是普通的key索引，这个时候如果写一个select * from table where name=xx的语句，name是个普通的二级索引，不是唯一索引，那么此时这种查询速度也是很快的，他在执行计划里叫做<font color="#FF0000" size="5">ref</font>。</p> <p><img src="/docs/assets/img/const_ref1.513a5eb2.png" alt="执行计划中的const和ref" title="const_ref1.png"></p> <p><strong>我们换个角度来看，假设我们以后在分析执行计划的时候看到了const，那是什么？对，肯定是通过主键或者唯一索引的访问，速度超高</strong>。</p> <p><strong>如果你看到了ref是什么意思？对，就是用了普通索引，或者用主键/唯一索引搞了一个IS NULL/IS NOT NULL</strong></p> <p>执行计划里的<font color="#FF0000" size="5">range</font>，顾名思义，就是说你SQL有范围查询的时候就会走这个方式。</p> <p>比如你写了sql，select * from table where age&gt;=x and age&lt;=x,假设age就是一个普通索引，此时就必然会利用索引来进行范围查询，一旦利用索引做了范围筛选，那么这种方式就是range。</p> <p><font color="#FF0000" size="4">假设我们有一个表，联合索引是KEY（x1，x2，x3），我们写的sql语句是：select x1，x2，x3 from table where x2=xx，</font>相信很多人看到这里就觉得完蛋了，x2不是联合索引最左侧的字段，不会走索引！</p> <p>对，这个sql确实没办法直接从联合索引的索引树的根节点开始进行二分查找，快速一层一层跳转的，那么他会怎么执行呢？不知道大家有没有发现，这个sql里要查的几个字段，就是联合索引里的几个字段，巧了。</p> <p>所以针对这种sql，在实际查询的时候，就会直接遍历KEY（x1，x2，x3）这个联合索引的索引树的叶子节点，因为联合索引的叶子节点存放的也是页，但是页里每一行都是x1，x2，x3和主键的值。</p> <p><strong>所以针对这个sql，会直接遍历KEY（x1，x2，x3）索引树的叶子节点的那些页，一个接一个的遍历，然后找到x2=xx的那个数据，就把里面的x1，x2，x3三个字段的值直接提取出来就可以了</strong>！这个遍历二级索引的过程，要比遍历聚簇索引要快多了，毕竟二级索引的叶子节点只包含几个字段的值，比聚簇索引叶子节点小多了，所以速度也快多了。</p> <p>也就是说只要遍历一个KEY（x1，x2，x3）索引就可以了，不需要回源到聚簇索引里去！<strong>针对这种只要遍历二级索引就可以拿到你想要的数据，而不需要回源到聚簇索引的访问方式，叫做<font color="#FF0000" size="5">index</font>访问方式</strong>！</p> <p><strong>总结</strong>：之前说的const、ref、range，本质都是基于索引树的二分查找和多层跳转来查询，所以性能都是很高的。然后index查询方式，速度比上面三种要差一些，因为它是走遍历二级索引树的叶子节点的方式来执行的，那肯定是比基于索引树的二分查找要慢多了，但是比全表扫描要好很多。</p> <p>执行计划里最次的一种就是<font color="#FF0000" size="5">all</font>，all的意思是直接全表扫描，扫描你的聚簇索引的所有叶子节点，也就是一个表里一行一行的去扫描，如果表里只有几百条数据还好，如果有几万，几百万的数据，那全表扫描就得跪了！</p> <p><font color="#FF0000" size="5">***************************************************************************</font>
下面开始分析具体的sql，会走什么样的执行计划。</p> <p>首先大家看一个sql语句：select * from table where x1=xx and x2&gt;=xxx，此时可能有人会说，对x1和x2建立一个联合索引，那不就可以通过索引去扫描了？<br>
但是万一你建的索引是两个呢？比如（x1，x3），（x2，x4），此时你这个sql只能选择其中一个索引去使用，此时会选择哪个呢？<strong>MySQL负责生成执行计划的查询优化器，一般会选择在索引里扫描行数比较少的那个条件</strong>。</p> <p>比如说x1=xx，在索引里只要做等值比较，扫描数据比较少，那么就可能会挑选x1的索引，做一个索引的查找，在执行计划里，其实就是一个ref的方式，找到数据后，接着做一个回表，回到聚簇索引里找出完整的数据，接着加载到内存里，根据x2的值，做一个x2&gt;=xx的筛选即可。</p> <p>这就是面对两个字段都能用索引的时候如何选择，以及如何进行处理的方式。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>接下来我没再考虑另外一种情况，就是：select * from table where x1=xx and c1=xxx and c2&gt;=xxx and c3 IS NOT NULL</p> <p>其实我们平时经常会写出类似这样的SQL语句，就是这个SQL的筛选语句里，就一个x1是有索引的，其他字段都是没有索引的。</p> <p>所以这种情况，必然很多SQL语句里，可能where后的条件有好几个，<strong>结果就一个字段可以用到索引</strong>，此时查询优化器生成的执行计划，就会仅仅针对x1字段走一个ref访问，直接通过x1字段的索引树快速定位到一波数据。</p> <p><strong>接着根据这波数据对应的主键值，回表，回到聚簇索引中查询完整的数据行，然后都加载到内存中去。接着就可以针对这些数据的c1、c2和c3条件过滤，最后拿到的就是符合条件的数据了</strong>。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>一般一个sql只能用到一个二级索引，但是有些sql可能会用到多个二级索引，这是怎么回事呢？</p> <p><strong>比如有这么一个sql：select * from table where x1=xx and x2=xx,然后x1和x2分别各有一个索引，其实也有一定的可能让查询优化器生成一个执行计划，执行计划里，先对x1的索引树查找，查出一波数据，接着对x2的索引树，查出一波数据，然后对两拨数据，按照主键值做一个交集</strong>。</p> <p>这个交集就是符合两个条件的数据了，接着回表到聚簇索引去查完整的数据就可以了。</p> <p>但是其实之前我们对这种情况一直说的是，选择x1或x2其中一个字段走索引，找出数据后，再回表到聚簇索引里查出完整的数据，再根据另外一个字段的值进行过滤就行了。</p> <p><img src="/docs/assets/img/union_index2.c93f2da0.png" alt="走多个二级索引的情况" title="union_index2.png"><br> <img src="/docs/assets/img/union_index3.3da91a6f.png" alt="走多个二级索引的情况" title="union_index3.png"></p> <p><font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>如果你在SQL里写了类似x1=xx or x2=xx的语句，也可能会用多个索引，只不过查多个大索引树之后，会取一个并集。<br> <img src="/docs/assets/img/union_index4.64b89e18.png" alt="走多个二级索引的情况" title="union_index4.png"></p> <h2 id="深入探索多表关联的sql语句到底是如何执行的"><a href="#深入探索多表关联的sql语句到底是如何执行的" class="header-anchor">#</a> 深入探索多表关联的SQL语句到底是如何执行的？</h2> <p>假设我们有个sql语句：select * from t1,t2 where t1.x1=xx and t1.x2=t2.x2 and t2.x3=xxx</p> <p>其实这个sql的执行过程可能是这样的，首先根据x1=xx这个筛选条件，去t1表里查出一批数据，此时可能是const或者ref，也可能是index或者all，都有可能，具体看你的索引是如何建的，他会挑选一种执行计划访问方式。</p> <p>然后假设从t1表里按照t1.x1=xxx条件筛选出两条数据，接着对这两条数据，根据每条数据的x2字段的值，以及t2.x3=xxx这个条件，去t2表里查找x2字段值和x3字段值都匹配的数据，比如说t1表第一条数据的x2字段的值是265，此时就可以根据t2.x2=265和x3=xxx这两个条件，来找出一波数据，比如找出2条吧。</p> <p>此时就把t1表里x2=265的那条数据跟t2表里t2.x2=265 和 t2.x3=xxx的两条数据，关联起来就可以了，t1表里的另外一条数据也是如法炮制而已，这就是<strong>多表关联最最基础的原理</strong>。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p><strong>嵌套循环关联（nested-loop join）</strong>,它其实就是前面我们给大家讲的最初的关联执行原理。</p> <p>简单来说，假设有两个表要一起执行关联，此时会现在一个<strong>驱动表</strong>(关联表中左侧的表) 里根据它的where筛选条件找出一波数据，比如说10条吧。<br>
接着就对着10条数据走一个循环，用每条数据都到另外一个<strong>被驱动表</strong>（关联表中右侧的表）去根据ON连接条件和WHERE里的被驱动表筛选条件去查找数据，找出的数据就进行关联。</p> <p>依次类推，驱动表有10条数据，那么就要到被驱动表里去查询10次。</p> <p>那么如果是3个表进行关联呢？那就更夸张了，你从表1里查出10条数据，接着去表2查10次，假设每次都查出3条数据，然后关联起来，此时你会得到一个30条数据的结果集，接着再去表3里继续查询30次。相当于进行了3次for循环，效率不低才怪呢。</p> <p>所以有时候为什么多表关联很慢呢？原因就是两个表都没有走索引。<br>
所以通常而言，<strong>针对多表查询的语句，我们要尽量给两个表都加上索引</strong>，<strong>索引要确保从驱动表里查询是通过索引的方式，接着对被动表的查询也是通过索引去查找</strong>。这样多表关联查询的效率才会很高。</p> <h2 id="mysql是如何根据成本优化选择执行计划的"><a href="#mysql是如何根据成本优化选择执行计划的" class="header-anchor">#</a> MySQL是如何根据成本优化选择执行计划的？</h2> <p>无论我们是执行单表查询还是多表关联查询，似乎都有多种执行计划可以选择，比如有的表可以全表扫描，也可以用索引A，也可以用索引B，那么到底用哪种执行计划呢？</p> <p><strong>MySQL是如何对一个查询语句的多个执行计划评估它的成本的？如果根据成本评估选择一个成本最低的执行计划，保证最佳的查询速度</strong>   ？<br> <img src="/docs/assets/img/explain1.677d2995.png" alt="执行计划的成本" title="explain1.png"></p> <p>假设有如下sql语句：select * from table where x1=xx and x2=xx,此时你有两个索引，分别是针对x1和x2建立的MySQL就会先看看这个sql可以用到哪几个索引，此时发现x1和x2的索引都能用到，他们两个的索引就是<strong>possible keys</strong>。</p> <p><font color="#FF0000" size="4">接着会针对这个sql计算一下全表扫描的成本，这个全表扫描就比较坑了，因为他需要先磁盘IO把聚簇索引里的叶子节点上的数据页一页一页都读到内存里，有多少数据页就得耗费多少IO成本，接着对内存里的每条数据都判断是否符合条件，这有多少条数据，就得耗费多少CPU成本。</font></p> <p>怎么上述的成本呢，需要一个命令：<br> <font color="#FF0000" size="5">show table status like '表名'</font><br>
这个命令可以拿到表的统计信息，你在对表进行增删改的时候，MySQL会帮你维护这个表的一些统计信息，比如可以看到<font color="#FF0000" size="5">rows和data_length</font>两个信息，不过对于innodb来说，rows是估计值。</p> <p>rows就是表里的记录数，data_length就是表的聚簇索引的字节数大小，数据页数量=data_length/1024/16，因为data_length/1024可以得到kb，一个数据页大小是16kb，再除以16,就可以得到数据页的个数了。</p> <p><font color="#0000FF" size="4">IO的成本就是：数据页数量<em>1.0+微调值，CPU成本就是：行记录数</em>0.2+微调值，他们两个相加，就是总的成本值。</font><br>
比如你有数据页100个，记录数2万个，此时总成本大致就是：100<em>1+20000</em>0.2=4100</p> <p><img src="/docs/assets/img/cost_estimat1.b4127cd8.png" alt="走索引时的成本估算" title="cost_estimat1.png"><br> <img src="/docs/assets/img/cost_estimat2.0609317e.png" alt="走索引时的成本估算" title="cost_estimat2.png"></p> <p>上面就是估算的成本，没办法精确。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>接着我们看看多表关联的成本计算和执行计划的选择，语句如下：<br>
select * from t1 join t2 on t1.x1=t2.x1 where t1.x2=xxx and t1.x3=xxx and t2.x4=xxx and t2.x5=xxx</p> <p>因为t1是驱动表，所以会根据 t1.x2=xxx and t1.x3=xxx这个条件从表里查询出一波符合条件的数据出来，此时就有一个问题了，这里用到了t1的两个字段来筛选数据，可能x2和x3都建立索引了，此时到底该选择哪个索引呢？或者干脆直接走全表扫描？</p> <p>此时就会按前面讲的那套方案来计算针对t1的全表扫描和不同索引的成本，选择一个针对t1表的最佳访问方式，用最低的成本从t1表里查询出符合条件的数据，接着就根据这波数据到t2表里去查数据，按照连接条件t1.x1=t2.x1去查，同时要符合t2.x4=xxx and t2.x5=xxx这两个条件</p> <p>此时一样会根据前面讲解的办法，针对t2表计算全表扫描和基于 t2.x4=xxx and t2.x5=xxx还有x1三个字段走索引的成本，挑选一个成本最低的方法。把数据从t2表里给查出来，这样就完成了多表关联。</p> <h2 id="mysql是如何基于各种规则去优化执行计划的"><a href="#mysql是如何基于各种规则去优化执行计划的" class="header-anchor">#</a> MySQL是如何基于各种规则去优化执行计划的？</h2> <p>MySQL有时候会觉得你写的sql一点都不好，直接按你的sql生成的执行计划效率还是不够高，它会自动帮你改改。</p> <p>首先，MySQL觉得你SQL里有很多括号，那么无关紧要的括号他会给你删除了。<br>
其次，比如你有类似i=5 and j&gt;i这样的SQL，就会帮你改写为i=5 and j&gt;5,做一个常量替换。</p> <p>还有比如x=y and y=k and k=3这样的SQL，会给你优化成x=3 and y=3 and k=3,本质也是做常量替换。</p> <p>或者出现类似a=a and b=b这种看上去乱写的SQL，一看就是没意义的，他会直接给你删了。</p> <p><img src="/docs/assets/img/auto_change_sql2.e232b9b5.png" alt="MySQL自动改写我们的SQL" title="auto_change_sql2.png"></p> <p><font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p><strong>子查询是如何执行的，他的执行计划是如何优化的？</strong></p> <p><strong>第一种子查询</strong>：select * from t1 where x1= (select x1 from t2 where id=xxx)<br>
这个SQL在执行的时候会拆成两个步骤：<br>
第一步：先执行子查询，也就是select x1 from t2 where id=xxx，直接根据主键id定位出一条数据的x1的值<br>
第二步：接着执行select * from x1 where t1=前面那个子查询结果</p> <p><strong>第二种子查询</strong>：select * from t1 where x1= (select x1 from t2 where t1.x2=t2.x2)<br>
你会发现子查询里的where条件依赖了t1表里的字段值，他需要遍历t1表里的每一条数据，对每条数据取出x2字段的值，放到子查询里去执行，找出t2表x1字段的值，再放到外层去判断，是否跟外层t1表查出的数据的x1字段匹配。这个效率是极其低下的。</p> <p><strong>重点讲一下in语句结合子查询的一个优化手段</strong>，假设有如下一个SQL语句：<br>
select * from t1 where x1 in (select x2 from t2 where x3=xxx)<br>
这个SQL语句是典型的一个子查询应用，子查询查一波结果，然后判断t1表哪些数据的x1值在这个子查询的结果集里。<br> <img src="/docs/assets/img/auto_change_sql3.c09ea1cd.png" alt="MySQL自动改写我们的SQL" title="auto_change_sql3.png"></p> <p>所以基于IN语句的查询，会在底层被优化成上述的情况。</p> <p><font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <h3 id="半连接-semi-join-mysql优化子查询执行计划的一种方式。"><a href="#半连接-semi-join-mysql优化子查询执行计划的一种方式。" class="header-anchor">#</a> 半连接（semi join）:MySQL优化子查询执行计划的一种方式。</h3> <p>select * from t1 where x1 in (select x2 from t2 where x3=xxx)，此时可能在底层把它转化为一个半连接，有点类似于下面的样子：<br>
select t1.* from t1 semi join t2 on t1.x1=t2.x2 and t2.x3=xxx<br> <img src="/docs/assets/img/auto_change_sql4.346c03f0.png" alt="MySQL自动改写我们的SQL" title="auto_change_sql4.png"><br> <img src="/docs/assets/img/auto_change_sql5.3c9c45dc.png" alt="MySQL自动改写我们的SQL" title="auto_change_sql5.png"></p> <h2 id="透彻研究通过explain命令得到的sql执行计划"><a href="#透彻研究通过explain命令得到的sql执行计划" class="header-anchor">#</a> 透彻研究通过explain命令得到的SQL执行计划</h2> <h3 id="执行计划各列的含义"><a href="#执行计划各列的含义" class="header-anchor">#</a> 执行计划各列的含义</h3> <p><font color="#FF0000" size="5">explain select * from user</font></p> <p><img src="/docs/assets/img/explain_sql1.84c8a965.png" alt="打印执行计划的命令" title="explain_sql1.png"></p> <p>如果说是一个简单的单表查询，可能这里就一条数据，代表了他打算如何访问这一个表。</p> <p>但是如果你的SQL很复杂，那么可能这里就会有多条数据，因为复杂的SQL语句的执行是要拆分为很多步骤的。</p> <p><strong>id</strong>:就是说每一个select都会对应一个id，多个select就可能会有多个执行计划，每条执行计划都会有一个唯一的id。</p> <blockquote><p>往往一个select字句涉及到了多个表，所以会对应多条执行计划，此时可能多条执行计划的id是一样的。<br> <strong>id相同，从上往下执行；id不同，值越大，优先级越高</strong></p></blockquote> <p><strong>select_type</strong>:这条执行计划对应的查询是什么类型的查询。</p> <blockquote><p>SIMPLE:简单的查询不包含 UNION 和 subqueries<br>
PRIMARY：查询中若包含任何复杂的子查询，最外层查询则被标记为Primary。参考sql：select * from t1 where x1 in (select x1 from t2) or x3='xxxx'<br>
SUBQUERY：在select或者where列表中包含子查询。参考SQL：select * from t1 where x1 in (select x1 from t2) or x3='xxxx'<br>
UNION	若第二个select出现在union之后，则被标记为union。参考SQL：select * from t1 union select * from t2<br>
UNION RESULT:合并结果，这个语句的第三个执行计划就是UNION_RESULT。参考SQL：select * from t1 union select * from t2</p></blockquote> <p>DEPENDENT UNION	跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响<br>
UNION RESULT	从union表获取结果的select<br>
DEPENDENT SUBQUERY	subquery的子查询要受到外部表查询的影响<br>
DERIVED	from子句中出现的子查询，也叫做派生类<br>
UNCACHEABLE SUBQUERY	表示使用子查询的结果不能被缓存<br>
UNCACHEABLE UNION	表示union的查询结果不能被缓存</p> <p><strong>table</strong>：表名<br> <strong>partitions</strong>：表分区的概念，暂不用关注<br> <font color="#FF0000" size="5">type：</font>比较关键，针对当前这个表的访问方法，就是const，ref，range，index，all之类的。<br> <font color="#FF0000" size="5">possible_keys：</font>也比较关键，他是跟type结合起来的，也就是说type确定访问方式了，那么到底有哪些索引可供选择，都会放到这里。<br> <strong>key</strong>：就是possible_keys里实际选择的那个索引。<br> <strong>key_len</strong>：就是索引的长度。其实是指索引里最大值的长度，给你个参考。<br> <strong>ref</strong>：就是使用某个字段的索引进行等值匹配的时候，跟索引列进行等值匹配的那个目标值的一些信息。<br> <strong>rows</strong>：预估通过索引或者别的方式访问这个表的时候，大概可能会读取多少条数据。<br> <strong>filtered</strong>： 经过搜索条件过滤之后查出的数据占总数据量的百分比。<br> <strong>Extra</strong>：一些额外的信息。</p> <h3 id="多表关联执行计划解读"><a href="#多表关联执行计划解读" class="header-anchor">#</a> 多表关联执行计划解读</h3> <p>全表扫描：会直接扫描表的聚簇索引的叶子节点，按顺序扫描去拿表的全部数据。<br>
explain select * from t1 join t2<br> <img src="/docs/assets/img/explain_sql2.aa81d464.png" alt="多表关联执行计划解读" title="explain_sql2.png"></p> <h3 id="子查询sql语句的执行计划分析"><a href="#子查询sql语句的执行计划分析" class="header-anchor">#</a> 子查询SQL语句的执行计划分析</h3> <p>explain select * from t1 where x1 in (select x1 from t2) or x3='xxxx'<br> <img src="/docs/assets/img/explain_sql3.05a813cd.png" alt="子查询sql的执行计划解读" title="explain_sql3.png"></p> <p>第一个执行计划里，select_type是PRIMARY，说明第一个执行计划的查询类型是<strong>主查询</strong>的意思。它有一个where条件是x3='xxxx',所以它的possible_keys里包含了index_x3,就是x3字段的索引，但是它的key实际是null，而且type是all，说明它最后没有选择走x3字段的索引，而是走了全表扫描。</p> <p>第二个执行计划，他的select_type是SUBQUERY，也就是子查询，子查询针对的是t2这个表，子查询本身就是一个全表查询，但是对主查询而言，会使用x1 in 这个筛选条件，它的type是index，key是index_x1，说明使用了扫描x1字段的二级索引的方式，找到一波数据,最后拿前面的结果集和子查询的结果集做比对即可。</p> <p><strong>explain select * from t1 union select * from t2</strong><br> <img src="/docs/assets/img/explain_sql4.765e7b02.png" alt="子查询sql的执行计划解读" title="explain_sql4.png"></p> <p><strong>explain select * from t1 where x1 in (select x1 from t2 where x1='xxx' UNION select x1 from t1 where x1='xxx')</strong></p> <p><img src="/docs/assets/img/explain_sql5.22c11524.png" alt="子查询sql的执行计划解读" title="explain_sql5.png"></p> <p>explain select * from (select x1,count(*) as cnt from t1 group by x1) as _t1 where cnt &gt; 10<br> <img src="/docs/assets/img/explain_sql6.cafa795a.png" alt="子查询sql的执行计划解读" title="explain_sql6.png"></p> <h3 id="type的取值情况"><a href="#type的取值情况" class="header-anchor">#</a> type的取值情况</h3> <p>执行计划中的type很关键，直接决定了如何从某个表里查询数据。type包括const、ref、range、index、all这几种方式，分别是根据主键/唯一索引查询，根据二级索引查询，范围查询，对二级索引进行全索引扫描，全表扫描。</p> <p>首先，类似select * from t1 where id=1这样的sql，直接根据主键进行等值匹配查询，那执行计划里的type就是const，意思是常量级查询。</p> <p>接下来这个sql根据主键进行关联查询：<br>
explain select * from t1, t2 where t1.id=t2.id;</p> <p><img src="/docs/assets/img/explain_sql7.8b1cd003.png" alt="子查询sql的执行计划解读" title="explain_sql7.png"></p> <h3 id="possible-keys"><a href="#possible-keys" class="header-anchor">#</a> possible_keys</h3> <p>它是指在针对一个表进行查询的时候有哪些潜在的索引可以使用。</p> <p>假设有两个索引KEY(x1,x2,x3)和KEY(x1,x2,x4),此时要在where语句里根据x1和x2进行查询，那么上述的两个索引都可以使用，那么到底用哪个呢？<br>
其实还是需要估算使用成本，选择成本低的即可，最终的选择的索引会信息会放入key里面。</p> <p><strong>key_len</strong>：其实就是索引里最大值的长度是多少，给你个参考，让你知道索引里最大值的长度。<br> <strong>rows</strong>：顾名思义是说你使用指定的查询方式会查出多少条数据。<br> <strong>filtered</strong>：意思是说在指定的查询方式查询出的这波数据里再加上其它的不在索引范围内里的查询条件，又会过滤出百分之几的数据。</p> <p><img src="/docs/assets/img/explain_sql8.4f77095c.png" alt="执行计划possible_keys解读" title="explain_sql8.png"></p> <h3 id="extra常用的内容讲解"><a href="#extra常用的内容讲解" class="header-anchor">#</a> extra常用的内容讲解</h3> <p><img src="/docs/assets/img/explain_sql9.e9f42b66.png" alt="执行计划extra字段解读" title="explain_sql9.png"><br> <img src="/docs/assets/img/explain_sql10.787940e2.png" alt="执行计划extra字段解读" title="explain_sql10.png"><br> <img src="/docs/assets/img/explain_sql11.4bc7c538.png" alt="执行计划extra字段解读" title="explain_sql11.png"><br> <img src="/docs/assets/img/explain_sql12.a2b8fec4.png" alt="执行计划extra字段解读" title="explain_sql12.png"></p> <p>extra中的<font color="#0000FF" size="5"><strong>using filesort</strong></font>是什么意思？<br> <img src="/docs/assets/img/explain_sql13.0d5da19a.png" alt="执行计划extra字段解读" title="explain_sql13.png"></p> <p><img src="/docs/assets/img/explain_sql14.eb068469.png" alt="执行计划extra字段解读" title="explain_sql14.png"><br> <img src="/docs/assets/img/explain_sql15.cb645bce.png" alt="执行计划extra字段解读" title="explain_sql15.png"></p> <h2 id="案例实战-千万级用户场景下的运营系统sql调优"><a href="#案例实战-千万级用户场景下的运营系统sql调优" class="header-anchor">#</a> 案例实战：千万级用户场景下的运营系统SQL调优</h2> <h3 id="第一个查询很慢的sql"><a href="#第一个查询很慢的sql" class="header-anchor">#</a> 第一个查询很慢的sql</h3> <p><img src="/docs/assets/img/explain_shizhan1.89909ced.png" alt="执行计划实战1背景介绍" title="explain_shizhan1.png"><br> <strong>同样的SQL在不同版本的MySQL中执行计划可能不一样，因为MySQL每个版本都可能调整生成执行计划的方式</strong><br> <img src="/docs/assets/img/explain_shizhan2.216ad284.png" alt="执行计划分析" title="explain_shizhan2.png"></p> <p><img src="/docs/assets/img/explain_shizhan3.3ba3a0f3.png" alt="执行计划慢的原因分析" title="explain_shizhan3.png"><br> <img src="/docs/assets/img/explain_shizhan4.7c045c2a.png" alt="执行计划慢的原因分析" title="explain_shizhan4.png"><br> <font color="#0000FF" size="5">show warnings:它把优化后的SQL给打印出来了，便于我们分析sql的执行计划。</font><br> <img src="/docs/assets/img/explain_shizhan5.a8fbe724.png" alt="show warnings使用技巧" title="explain_shizhan5.png"></p> <h3 id="第二个查询很慢的sql"><a href="#第二个查询很慢的sql" class="header-anchor">#</a> 第二个查询很慢的sql</h3> <p><img src="/docs/assets/img/explain_shizhan6.1068f8c3.png" alt="sql缓慢的场景" title="explain_shizhan6.png"><br> <img src="/docs/assets/img/explain_shizhan7.00e84a0c.png" alt="sql缓慢的场景" title="explain_shizhan7.png"><br> <img src="/docs/assets/img/explain_shizhan8.24d26982.png" alt="sql缓慢的场景" title="explain_shizhan8.png"><br> <img src="/docs/assets/img/explain_shizhan9.ea3fffc2.png" alt="sql缓慢的场景" title="explain_shizhan9.png"><br> <img src="/docs/assets/img/explain_shizhan10.0bb2e281.png" alt="sql缓慢的场景" title="explain_shizhan10.png"><br> <font color="#0000FF" size="4">感觉这个案例好像在说，如果一个大表，扫不到数据，会导致全表扫描，从前扫到后，每次都扫完整个表才会返回结果。有数据的话，反而sql效率很高。</font></p> <h2 id="案例实战-数十亿数量级评论系统的sql调优实战"><a href="#案例实战-数十亿数量级评论系统的sql调优实战" class="header-anchor">#</a> 案例实战：数十亿数量级评论系统的SQL调优实战</h2> <p><img src="/docs/assets/img/explain_shizhan11.bfd44677.png" alt="sql缓慢的场景" title="explain_shizhan11.png"><br> <img src="/docs/assets/img/explain_shizhan12.360d350d.png" alt="sql缓慢的场景" title="explain_shizhan12.png"><br> <img src="/docs/assets/img/explain_shizhan13.97cd5fce.png" alt="sql缓慢的场景" title="explain_shizhan13.png"></p> <h2 id="案例实战-千万级数据删除导致的慢查询优化实践"><a href="#案例实战-千万级数据删除导致的慢查询优化实践" class="header-anchor">#</a> 案例实战：千万级数据删除导致的慢查询优化实践</h2> <p><img src="/docs/assets/img/explain_shizhan14.b2cedd14.png" alt="sql缓慢的场景" title="explain_shizhan14.png"><br> <img src="/docs/assets/img/explain_shizhan15.93f5d823.png" alt="sql缓慢的场景" title="explain_shizhan15.png"></p> <p>SQL慢排查思路：<br>
第一步：检查SQL，看看执行计划。<br>
第二步：检查MySQL服务器负载，比如磁盘负载、网络负载、cpu负载。<br>
第三步：使用MySQL profilling工具去分析。</p> <p><img src="/docs/assets/img/explain_shizhan16.84d949a7.png" alt="sql缓慢的场景" title="explain_shizhan16.png"><br> <img src="/docs/assets/img/explain_shizhan17.d01aa860.png" alt="sql缓慢的场景" title="explain_shizhan17.png"><br> <img src="/docs/assets/img/explain_shizhan18.dd53e83a.png" alt="sql缓慢的场景" title="explain_shizhan18.png"></p> <p>当时经过排查，发现有大量的更新语句在活跃，而且有那种长期活跃的超长事务一直在跑没有结束，<font color="#0000FF" size="4">结果一问系统负责人，发现他在后台跑了一个定时任务，定时清理数据，结果清理的时候一下子清理了上千万的数据。</font></p> <p>他居然开了一个事务，然后在事务里删除上千万条数据，导致这个事务一直在运行，所以才导致查询缓慢。</p> <p>因为每次扫到一批数据，都发现被标记位删除了，接着就会继续往下扫描，所以才导致一些查询这么慢。</p> <p>那么可能有人会问了，为什么你开启一个事务，在事务里查询，凭什么要去扫描之前那个长事务标记为删除状态的上千万垃圾数据？按说那些垃圾数据被删除了，个您没有任何关系了，你可以不用去扫描他们啊！</p> <p><font color="#0000FF" size="4">这个问题的关键点在于，那个删除千万条数据的事务是长事务。</font></p> <p><img src="/docs/assets/img/mysql_master7.125485bb.png" alt="大量删除数据影响到查询的原因" title="mysql_master7.png"></p> <p><a href="https://www.cnblogs.com/sxdcgaq8080/p/11844079.html" title="explain_shizhan18.png" target="_blank" rel="noopener noreferrer">mysql的profilling分析工具介绍<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre class="language-text"><code>--下面的SQL语句用于查询query_id为9的SQL开销，且按最大耗用时间倒序排列
mysql&gt; set @query_id=9;

SELECT STATE,
            SUM(DURATION) AS Total_R,
           ROUND(100 * SUM(DURATION) /
                  (SELECT SUM(DURATION)
                     FROM INFORMATION_SCHEMA.PROFILING
                   WHERE QUERY_ID = @query_id),
                 2) AS Pct_R,
            COUNT(*) AS Calls,
            SUM(DURATION) / COUNT(*) AS &quot;R/Call&quot;
      FROM INFORMATION_SCHEMA.PROFILING
     WHERE QUERY_ID = @query_id
      GROUP BY STATE
     ORDER BY Total_R DESC;
</code></pre></div><p>--启用session级别的profiling<br>
mysql&gt; set profiling=1;</p> <p>--验证修改后的结果<br>
mysql&gt; show variables like '%profil%';</p> <p>--执行SQL查询<br>
mysql&gt; show databases;<br>
mysql&gt; show tables;</p> <p>--查看当前session所有已产生的profile【注意，要显示Query_ID 和 Query列，需要使用的命令是 show profiles;】<br>
mysql&gt; show profiles;</p> <p>--可以直接使用show profile来查看上一条SQL语句的开销信息<br>
--注，show profile之类的语句不会被profiling，即自身不会产生Profiling<br>
mysql&gt; show profile;</p> <p>--显示所有性能信息【这里的9  就是使用上面的 show profiles;命令获取到的 自己想要查看的哪个 sql语句的 Query_ID】<br>
mysql&gt; show profile all for query 9;</p> <p>--查看特定部分的开销，如下为CPU部分的开销
mysql&gt; show profile cpu for query  9;</p> <p>--如下为MEMORY部分的开销<br>
mysql&gt; show profile memory for query 9 ;</p> <p>--同时查看不同资源开销<br>
mysql&gt; show profile block io,cpu for query 9;</p> <p>--显示swap的次数。<br>
mysql&gt; show profile swaps for query 9;</p> <p>--停止profile,可以设置profiling参数，或者在session退出之后,profiling会被自动关闭<br>
set profiling=off;</p> <h2 id="我们为什么要搭建一套mysql的主从复制架构"><a href="#我们为什么要搭建一套mysql的主从复制架构" class="header-anchor">#</a> 我们为什么要搭建一套MySQL的主从复制架构？</h2> <p><font color="#FF0000" size="4">MySQL在生产环境中一定不是单机版的架构，因为单机版的MySQL一般仅能用于本地开发环境和测试环境，是绝对不可能运用于生产环境的。</font></p> <p>那么生产环境的MySQL架构应该是什么样的呢？</p> <p><font color="#0000FF" size="4">MySQL在生产环境中一定要搭一套主从复制架构，同时还可以基于一些工具实现高可用架构。</font></p> <p>另外，如果有需求，还需要基于一些中间件实现读写分离架构，最后就是如果数据量很大，还必须要实现分库分表的架构。</p> <p>MySQL主从复制架构，顾名思义，就是部署两台服务器，每台服务器上都得有一个MySQL，其中一个MySQL是master（主节点），另外一个MySQL是slave（从节点）。</p> <p><img src="/docs/assets/img/mysql_master1.f6cf5fef.png" alt="mysql主从复制" title="mysql_master1.png"></p> <p>主从复制架构的意义？</p> <p>首先的一个需求就是高可用架构。</p> <p>然后要做一个<strong>读写分离</strong>的架构，它也是依赖于MySQL的主从复制架构的。</p> <p><font color="#FF0000" size="4">读写分离框架</font>的意思是，你的java业务系统可以往主节点写入数据，但是从从节点去查询数据，把读写操作做一个分离，分离到两台MySQL服务器上去，一台服务器让你专门写入数据，然后复制数据到从节点，另外一台服务器专门让你查询数据，如下图所示：<br> <img src="/docs/assets/img/mysql_master2.b6ef950b.png" alt="mysql读写分离" title="mysql_master2.png"></p> <p>假设我们的MySQL服务器配置时8核16G，然后每秒最多能抗4000读写请求，现在假设你真实的业务负载已经达到了，每秒有2500写请求+2500读请求，也就是每秒5000的读写请求了，那么你觉得都放到一台MySQL服务器上，能抗住吗？</p> <p>但是我们可以利用主从复制架构，搭建起读写分离架构，就可以让每秒2500写请求落到主节点那台服务器，2500读请求落到从节点那台服务器，用2台服务器抗下你每秒5000的读写请求，如下图所示：</p> <p><img src="/docs/assets/img/mysql_master3.68e74890.png" alt="mysql读写分离" title="mysql_master3.png"></p> <p><font color="#0000FF" size="4">接着问题来了，大家都知道，java系统大多是读多写少，读请求远多于写请求，那么接着随着系统的日益发展，读请求越来越多，每秒都可能有6000个读请求了，此时一个从节点服务器也抗不下来了，怎么办？</font></p> <p>简单，MySQL的主从复制架构是支持一主多从的，所以此时你可以再在一台机器上部署一个从节点，去从主节点复制数据过来，此时你就有2个从节点了，然后每秒6000个读请求不就可以落到两个从节点上去了，每个服务器要接收3000个读请求，如下图所示：</p> <p><img src="/docs/assets/img/mysql_master4.ecbf7e95.png" alt="mysql主从复制一主多从" title="mysql_master4.png"><br> <img src="/docs/assets/img/mysql_master5.2e9a3cfb.png" alt="mysql主从复制一主多从" title="mysql_master5.png"></p> <p><strong>MySQL实现主从复制的基本工作原理</strong></p> <p>MySQL在执行增删改的时候会记录binlog日志，binlog日志里就记录所有数据增删改的操作。</p> <p>然后从库上有一个IO线程，这个IO线程会负责跟主库建立一个TCP连接，请求主库传输binlog日志给自己，这个时候主库上有一个IO dump线程，就会负责通过这个TCP连接把binlong日志传输给从库的IO线程。</p> <p>接着从库的IO线程会把接收到的binlog日志写入到自己本地的relay日志文件中去，然后从库上另外一个SQL线程负责读取relay日志文件里的内容，进行日志重做，把所有在主库执行过的增删改操作，在从库上做一遍，达到一个还原数据的过程，如下图：<br> <img src="/docs/assets/img/mysql_master6.71d9ca69.png" alt="mysql主从复制一主多从" title="mysql_master6.png"></p> <h2 id="如何为mysql搭建一套主从复制架构"><a href="#如何为mysql搭建一套主从复制架构" class="header-anchor">#</a> 如何为MySQL搭建一套主从复制架构？</h2> <p><a href="https://www.bilibili.com/video/BV1P4411a7pN?from=search&amp;seid=4931699062084653961" target="_blank" rel="noopener noreferrer">主从复制视频课<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre class="language-text"><code>1,create database whc; 创建数据库
2,show databases; 查看数据库
3，配置主从同步。
   修改主服务器my.cnf配置文件
   log-bin=master-a-bin  #日志文件名称
   binlog-format=ROW  #二进制日志的格式 有row，statement，mixed三种类型
   server-id=1   #各个服务器的这个id必须不一样
   binlog-do-db=whc  #同步的数据库的名称
4，在主服务器配置从服务器登录主服务器的账号授权
   grant replication slave on *.* to 'root'@'192.168.37.128' identified by '123456';
5，flush privileges;
6,从服务器配置my.cnf
   log-bin=master-a-bin  #日志文件名称,与主服务器备份日志同名
   binlog-format=ROW  #二进制日志的格式 必须跟主服务器一样，有row，statement，mixed三种类型
   server-id=2   #各个服务器的这个id必须不一样
   log-slave-updates=false  #中继日志执行之后，这些变化是否要记入自己的binarylog。当你的从服务器需要作为另外一个服务器的主服务器的时候，需要 打开。就是多主相互备份或者多主循环备份。   
7，重启mysql主服务器
   service mysqld restart  
8，登录主服务器128
   mysql -uroot -p123456
9,查看主服务器状态
  show master status; 
10,重启从服务器
   service mysqld restart  
11，在从服务器配置
CHANGE MASTER TO MASTER_HOST='192.168.37.128',
MASTER_USER='root',MASTER_PASSWORD='123456',MASTER_PORT=3306,MASTER_LOG_FILE='master-a-bin.000008',MASTER_LOG_POS=154;
12,开启从服务器：
   start slave;
13,查看状态
  show slave status \G;
  如果显示的结果不是下面的情况，需要执行第14步的命令
  或者根据网址它操作：https://zhuanlan.zhihu.com/p/88596039
    Slave_IO_Running: Yes
    Slave_SQL_Running: Yes
   如果是Slave_SQL_Running：no：需要执行下面的命令：
    stop slave; 
    SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; 
    START SLAVE; 
   show slave status \G;
14,用navicat连接主服务器，如果连不上需要在主服务器执行如下命令：
   grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;
   报错信息：
   ERROR 1819 (HY000): Your password does not satisfy the current policy requirements  
   方案：
   [HY000报错解决方案](https://blog.csdn.net/calistom/article/details/87939956)
   flush privileges;
   
</code></pre></div><p><a href="https://www.cnblogs.com/linuxk/p/9371475.html" target="_blank" rel="noopener noreferrer">数据导出和导入详解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
这个网址有很多mysql的学习资料，<a href="https://www.jb51.net/Special/568.htm" target="_blank" rel="noopener noreferrer">其中mysql锁相关的网址是<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://www.jb51.net/article/180748.htm" target="_blank" rel="noopener noreferrer">主从同步存量数据处理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>1、先进入主库进行锁表，注意mysql窗口不要关闭<br>
flush table with read lock;<br>
2、把数据进行备份(在另一个窗口，不是mysql命令行里)<br>
mysqldump -uroot -p  whc &gt; /data/whc.sql<br>
删除user表（库必须要保留，空库都行）
mysql -uroot -p'123456' -e &quot;use whc;drop table student;&quot;
3、再新开个窗口，查看主数据库信息<br>
show master status;<br>
4、在从库上停止slave<br>
stop slave;<br>
5、导入备份的数据文件<br>
mysql -uroot -p'123456' whc &lt; /data/whc.sql<br>
查看数据
mysql -uroot -p'123456' -e &quot;select * from whc.student;&quot;<br>
6、重置同步<br>
reset slave;<br>
7、重新设置同步节点<br>
CHANGE MASTER TO<br>
MASTER_HOST='192.168.37.128',
MASTER_PORT=3306,
MASTER_USER='root',
MASTER_PASSWORD='123456',
MASTER_LOG_FILE='mysql-bin.000005',
MASTER_LOG_POS=1158;<br>
host，port，user，password请根据你的主库设置相应修改，log_file和log_pos根据主库中master status相应修改。<br>
8、开启slave<br>
start slave;<br>
9、查看slave状态<br>
show slave status\G;<br>
10、对主数据库解锁<br>
unlock tables;</p></blockquote> <p>执行上面第11步时报错了，错误信息如下：<br>
ERROR 1794 (HY000): Slave is not configured or failed to initialize properly. You must at least set --server-id to enable either a master or a slave<br>
解决方案链接 <a href="https://blog.csdn.net/chj_1224365967/article/details/107915724" target="_blank" rel="noopener noreferrer">1794 HY000错误解决方案<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br>
/usr/share/mysql/mysql_system_tables.sql</p> <p>1，首先要确保主库和从库的server-id是不同的<br>
2，主库必须打开binlog功能，主库打开binlong功能才会写binlog到本地磁盘。<br>
3，在主库上创建一个用于主从复制的账号：</p> <div class="language- extra-class"><pre class="language-text"><code>create user 'backup_user'@'192.168.37.%' identified by 'backup_pwd';
grant replication slave on *.* to 'backup_user'@'192.168.37.%';
flush_privileges;
</code></pre></div><p><font color="#0000FF" size="4">接下来要考虑一个问题，你主库已经跑了一段时间了，现在要挂一个从库，怎么办？</font></p> <p>应该在凌晨的时候，让系统对外不可用，说是维护状态，然后对主库和从库做一个数据的备份和导入。</p> <p>可以使用<font color="#0000FF" size="4">mysqldump工具</font>把主库在这个时刻的数据做一个全量备份，此时一定不允许操作系统操作主库了，因为主库此时的数据是不能变动的。<br> <font color="#FF0000" size="4">4，执行下面的命令对主库的所有数据做一个备份：</font></p> <div class="language- extra-class"><pre class="language-text"><code>/usr/local/mysql/bin/mysqldump --single-transaction -uroot -proot --master-data=2 -A &gt; backup.sql  
</code></pre></div><p>mysqldump工具不用安装，它就在MySQL安装目录的bin目录下。备份会以SQL语句的方式进入指定的backup.sql文件，只要执行这个文件，就可以恢复出来跟主库一样的数据。</p> <p><strong>上面的命令中--master-data=2的意思是：备份的SQL文件里，要记录一下此时主库的binlog文件和position号，这是为主从复制做准备的</strong>。</p> <p>接着你可以通过scp之类的命令把这个backup.sql文件拷贝到你的从库所在机器上，接着操作步骤转移到从库上执行，在从库上执行如下命令，把backup.sql里面的内容都执行一遍，从库数据就和主库一样了。</p> <p>5，接着在从库上执行下面的命令去指定从主库进行复制。</p> <div class="language- extra-class"><pre class="language-text"><code>CHANGE MASTER TO MASTER_HOST='192.168.37.128',
MASTER_USER='backup_user',MASTER_PASSWORD='backup_pwd',MASTER_LOG_FILE='mysql-bin.000015',MASTER_LOG_POS=1689;
</code></pre></div><p>看到上面的命令可能会疑惑，master的binlog文件和position是从哪里来的？其实在前面的导出的backup.sql里面就有，大家在执行上述命令前，需要打开backup.sql文件，把这些内容拷贝到上面的命令中。打开backup.sql可以看到如下内容：</p> <blockquote><p>MASTER_LOG_FILE='mysql-bin.000015',MASTER_LOG_POS=1689</p></blockquote> <p>6,接着在从库执行开始主从复制的命令。</p> <div class="language- extra-class"><pre class="language-text"><code>start slave
</code></pre></div><p>然后再用<font color="#0000FF" size="4">show slave status</font>查看主从复制的状态，主要看到Slave_IO_Running和Slave_SQL_Running都是yes就说明一切正常，主从复制开始了。</p> <p>接着可以在主库插入一条数据，然后在从库查询这条数据，主要能在从库中查到这条数据，就说明主从复制已经成功了。</p> <p>这仅仅是最简单的一种主从复制，也叫<strong>异步复制</strong>，从库是异步拉取binlog来同步的，所以肯定会出现短暂的主从不一致的问题，比如你在主库插入一条数据，立马在从库查询，有可能是查不到的。</p> <p><font color="#0000FF" size="4">用mycat或者sharding-sphere中间件，就可以实现你的系统写入主库，从从库去读取了。</font></p> <h3 id="异步方式带来的问题"><a href="#异步方式带来的问题" class="header-anchor">#</a> 异步方式带来的问题</h3> <p>前面的主从架构带来的问题，主库把日志写入binlog文件，接着自己就提交事务返回了，他不管从库到底收到日志没有。这样可能会造成数据丢失。</p> <p>因此一般来说，搭建主从复制，都是<font color="#0000FF" size="4">采用半同步的复制方式</font>。半同步的意思是说，你主库写入数据，日志进入binlog后，起码得确保binlog日志复制到从库了，你再告诉客户端说本次写入事务成功了。</p> <h2 id="gtid方式的主从复制"><a href="#gtid方式的主从复制" class="header-anchor">#</a> GTID方式的主从复制</h2> <p><img src="/docs/assets/img/master_slave1.58a60bb9.png" alt="mysql主从复制GTID方式" title="master_slave1.png"><br> <img src="/docs/assets/img/master_slave2.ceef5b72.png" alt="mysql主从复制GTID方式" title="master_slave2.png"></p> <h2 id="主从复制架构中的数据延迟问题-应该如何解决"><a href="#主从复制架构中的数据延迟问题-应该如何解决" class="header-anchor">#</a> 主从复制架构中的数据延迟问题，应该如何解决？</h2> <p>主从延迟问题：就是说你主库里写入了100条数据，结果从库才复制过去50条数据，那么从库就比主库落后了50条数据。<br> <img src="/docs/assets/img/master_slave3.3cd46d22.png" alt="mysql主从复制GTID方式" title="master_slave3.png"></p> <h2 id="数据库高可用-基于主从复制实现故障转移"><a href="#数据库高可用-基于主从复制实现故障转移" class="header-anchor">#</a> 数据库高可用：基于主从复制实现故障转移</h2> <p>其实从库宕机了影响并不是很大，因为大不了就是让所有的读流量都从主库去读就可以了，但是如果主库宕机了呢？那就真的麻烦了，因为主库宕机，你就没法写入数据了，毕竟从库是不允许写入的，只允许读。</p> <p>所以需要一个办法，在主机宕机之后，立马把从库切换为主库，然后所有人的读写请求都走这个新的主库。如果能实现这种效果，那<strong>数据库就实现了高可用</strong>了。</p> <p><strong>一般生产环境中进行数据库高可用架构管理的工具是MHA</strong>（Master High Availability Manager And Tools for MySQL），日本人用perl写的一个脚本工具，这个工具用来监控主库的状态，如果主库出现问题，就会自动把从库切为主库。</p> <p><font color="#0000FF" size="4">这个MHA是需要单独部署的，分为两种节点，一个是Master节点，一个是Node节点，Manager节点一般是单独部署在一台机器上的，Node节点一般是部署在每台MySQL机器上的，因为Node节点通过解析各个MySQL的日志来进行一些操作。</font></p> <p>Master节点会通过探测集群里的Node节点去判断各个Node所在的机器上的MySQL运行是否正常，如果发现某个Master故障了，就直接把它的一个slave提升为Master，然后让其他的slave都挂到新的Master上去，完全透明。</p> <p>这个原理非常简单，不过搭建的过程非常复杂。</p> <p><img src="/docs/assets/img/master_slave1.d805c0fa.png" alt="mysql主从复制GTID方式" title="master_slave1.png"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/mysql.html" class="prev">
        MySQL章节1
      </a></span> <span class="next"><a href="/docs/thread.html">
        多线程知识
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.29562e48.js" defer></script><script src="/docs/assets/js/5.2be00dd9.js" defer></script><script src="/docs/assets/js/2.b17def1c.js" defer></script>
  </body>
</html>
