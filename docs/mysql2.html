<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL章节2 | whc的学习笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="主要是java技术类笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.c2fe0476.css" as="style"><link rel="preload" href="/docs/assets/js/app.6c5ec198.js" as="script"><link rel="preload" href="/docs/assets/js/5.6f787e98.js" as="script"><link rel="preload" href="/docs/assets/js/4.14b81a4f.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.87e322ba.js"><link rel="prefetch" href="/docs/assets/js/11.83708201.js"><link rel="prefetch" href="/docs/assets/js/12.d9d28710.js"><link rel="prefetch" href="/docs/assets/js/2.4c78ffcf.js"><link rel="prefetch" href="/docs/assets/js/3.3347deab.js"><link rel="prefetch" href="/docs/assets/js/6.dfc49162.js"><link rel="prefetch" href="/docs/assets/js/7.f1484325.js"><link rel="prefetch" href="/docs/assets/js/8.8b8142e9.js"><link rel="prefetch" href="/docs/assets/js/9.cc8f999f.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.c2fe0476.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">whc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">站点介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>markdown知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/markdown.html" class="sidebar-link">前端知识介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MySQL知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/mysql0.html" class="sidebar-link">MySQL章节0</a></li><li><a href="/docs/mysql.html" class="sidebar-link">MySQL章节1</a></li><li><a href="/docs/mysql2.html" aria-current="page" class="active sidebar-link">MySQL章节2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="sidebar-link">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#多个事务更新同一行数据时-是如何加锁避免脏写的" class="sidebar-link">多个事务更新同一行数据时，是如何加锁避免脏写的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#共享锁和独占锁到底是什么" class="sidebar-link">共享锁和独占锁到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#哪些操作会导致在表级别加锁呢" class="sidebar-link">哪些操作会导致在表级别加锁呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="sidebar-link">表锁和行锁互相之间的关系以及互斥规则是什么呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#线上数据库不确定性的性能抖动优化实践" class="sidebar-link">线上数据库不确定性的性能抖动优化实践**</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#上述问题导致数据库性能抖动的优化方案" class="sidebar-link">上述问题导致数据库性能抖动的优化方案</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#磁盘数据页的存储结构" class="sidebar-link">磁盘数据页的存储结构</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#数据库是如何根据查询语句搜索数据的" class="sidebar-link">数据库是如何根据查询语句搜索数据的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#不断在表中插入数据时-物理存储是如何进行页分裂的" class="sidebar-link">不断在表中插入数据时，物理存储是如何进行页分裂的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#基于主键的索引是如何设计的" class="sidebar-link">基于主键的索引是如何设计的</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#索引的页存储物理结构-是如何用b-树来实现的" class="sidebar-link">索引的页存储物理结构，是如何用B+树来实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#更新数据的时候-自动维护的聚簇索引到底是什么" class="sidebar-link">更新数据的时候，自动维护的聚簇索引到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#主键之外的字段建立的二级索引-又是如何运作的" class="sidebar-link">主键之外的字段建立的二级索引，又是如何运作的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#插入数据时到底是如何维护好不同索引的b-树的" class="sidebar-link">插入数据时到底是如何维护好不同索引的B+树的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#一个表里是不是索引搞的越多越好" class="sidebar-link">一个表里是不是索引搞的越多越好？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#通过一步一图来深入理解联合索引查询原理以及全值匹配规则" class="sidebar-link">通过一步一图来深入理解联合索引查询原理以及全值匹配规则</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#最常见和最基本的索引使用规则" class="sidebar-link">最常见和最基本的索引使用规则</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#当我们在sql里进行排序的时候-如何才能使用索引" class="sidebar-link">当我们在SQL里进行排序的时候，如何才能使用索引？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#在sql里进行分组的时候-如何才能使用索引" class="sidebar-link">在SQL里进行分组的时候，如何才能使用索引？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#回表查询对性能的损害以及覆盖索引是什么" class="sidebar-link">回表查询对性能的损害以及覆盖索引是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#设计索引的时候-我们一般要考虑哪些因素呢" class="sidebar-link">设计索引的时候，我们一般要考虑哪些因素呢？</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JAVA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/thread.html" class="sidebar-link">多线程知识</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql章节2"><a href="#mysql章节2" class="header-anchor">#</a> MySQL章节2</h1> <h2 id="mysql最牛的rr隔离级别-是如何基于readview机制实现的"><a href="#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="header-anchor">#</a> MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</h2> <h3 id="rr级别下如何解决不可重复读问题的"><a href="#rr级别下如何解决不可重复读问题的" class="header-anchor">#</a> RR级别下如何解决不可重复读问题的</h3> <p>RR(可重复读)级别下，你这个事务读取一条数据，无论读多少次，都是一个值，别的事务哪怕修改数据之后提交了事务，你也是看不到人家修改的值的。这就避免了不可重复读的问题。别的事务插入一条数据，你也是看不到的，这就避免了幻读的问题。</p> <p>那到底是如何实现的呢？<br> <strong>核心地方在于RR隔离级别下，每次查询都是同一个ReadView</strong>
首先，我们还是假设数据库里有一条数据，这个数据是事务id=50的插入的。此时有事务A（id=60）和事务B（id=70）在同时运行，如下图所示：
<img src="/docs/assets/img/repeatable_committed1.d7e3decb.png" alt="可重复读与ReadView" title="repeatable_committed1.png"></p> <p>接着事务A发起了一次查询，因为是第一次查询，所以生成了ReadView，此时min_trx_id=60，max_trx_id=71,creator_trx_id=60,m_ids=[60,70],此时如下图：
<img src="/docs/assets/img/repeatable_committed2.91d36dfa.png" alt="可重复读与ReadView" title="repeatable_committed2.png"></p> <p>这个时候事务A基于这个ReadView去查询数据，此时trx_id=50，是小于min_trx_id=60，说它发起事务之前就已经有事务修改了数据并提交了事务，所以可以查到这条数据的原始值。如下图所示：
<img src="/docs/assets/img/repeatable_committed3.f04afef5.png" alt="可重复读与ReadView" title="repeatable_committed3.png"></p> <p>接着事务B就更新了这行数据的值为B，此时会把trx_id修改为70，同时会生成undo log，关键是事务B提交了，也就是说此时事务B已经结束了，如下图：
<img src="/docs/assets/img/repeatable_committed4.8e5343ba.png" alt="可重复读与ReadView" title="repeatable_committed4.png"></p> <p>这个时候大家思考一个问题，ReadView中的m_ids还是[60,70]吗？</p> <p>那必然是的，因为ReadView一旦生成了就不会改变了，这个时候事务B虽然已经结束了，但是事务A的ReadView里m_ids还是[60,70]。<br>
它的意思是事务A开启的时候，事务B当时是在运行的。</p> <p>那么此时事务A去查询这条数据的值，他会惊讶的发现此时数据的trx_id=70,70在min_trx_id和max_trx_id之间，同时还在m_ids=[60,70]列表中。<br>
这说明事务A开启查询的时候，id=70的事务B还是在运行的，然后事务B更新了这条数据，所以此时事务A是不能查询到事务B更新的值，因此此时会顺着undo log版本链条往下找，如下图所示：
<img src="/docs/assets/img/repeatable_committed5.dc738b79.png" alt="可重复读与ReadView" title="repeatable_committed5.png"><br>
事务A顺着roll_pointer找最近的undo log，发现最近的undo log的trx_id=50,它是小于min_trx_id=60的，说明它是在事务A开启之前就已经提交这个事务了，所以事务A是可以查询到这个值的，此时事务A查到的是原始值。<br> <img src="/docs/assets/img/repeatable_committed6.2caa39b4.png" alt="可重复读与ReadView" title="repeatable_committed6.png"></p> <p>可以看到两次查询查到的结果是一样的，都是原始值。不管别的事务如何修改数据，事务A的ReadView始终是不变的，基于这个ReadView看到的值始终是一样的。</p> <h3 id="rr级别下如何解决幻读问题的"><a href="#rr级别下如何解决幻读问题的" class="header-anchor">#</a> RR级别下如何解决幻读问题的</h3> <p><img src="/docs/assets/img/repeatable_committed7.244d09a1.png" alt="可重复读与ReadView" title="repeatable_committed7.png"><br> <img src="/docs/assets/img/repeatable_committed8.3e7049dd.png" alt="可重复读与ReadView" title="repeatable_committed8.png"></p> <p>MVCC是Multi-Version concurrent control,就是多版本并发控制机制。专门控制多个事务并发运行的时候，互相之间会如何影响。<br>
MySQL实现MVCC机制的时候，是基于<strong>undo log多版本链条+ReadView</strong>机制来做的，默认的RR隔离级别就是基于这套机制实现的。</p> <h2 id="多个事务更新同一行数据时-是如何加锁避免脏写的"><a href="#多个事务更新同一行数据时-是如何加锁避免脏写的" class="header-anchor">#</a> 多个事务更新同一行数据时，是如何加锁避免脏写的？</h2> <p>靠锁机制，依靠锁机制让多个事务更新同一行数据的时候串行化，避免同时更新一条数据。</p> <p>假设MySQL里有一行数据，此时来了一个事务要更新它，更新之前需要先检查这行数据有没有锁，如果没有锁，这个事务就会创建一个锁，里面包含了自己的trx_id和等待状态，然后把锁跟这行数据关联在一起。</p> <p><img src="/docs/assets/img/synchronized1.4d94aafe.png" alt="加锁避免脏写" title="synchronized1.png"></p> <p><strong>注意看上图，因为事务A已经给那行数据加了锁，所以此时就可以说那行数据已经被加锁了。</strong><br> <strong>此时另外一个事务B过来了，它也想更新那行数据，更新前先检查这行数据有没有锁，如果已经有锁，B也给这行数据加个锁，然后排队等着。这个时候事务B也生成了一个锁数据结构，里面有它的trx_id和等待状态，但是因为它是排队等待，所以它的等待状态是true</strong>。如下图所示：
<img src="/docs/assets/img/synchronized2.0e179d60.png" alt="加锁避免脏写" title="synchronized2.png"></p> <p>接着事务A更新完数据就把锁给释放了。锁一旦释放了，他就会去找，此时还有没有别人也对这行数据加锁了呢？他就会发现事务B也对该行数据加锁了，于是这个时候，就会把事务B的锁里的等待状态给修改为false，然后唤醒事务B继续执行，此时事务B就获取到锁了，如下图所示：
<img src="/docs/assets/img/synchronized3.2569590d.png" alt="加锁避免脏写" title="synchronized3.png"></p> <h2 id="共享锁和独占锁到底是什么"><a href="#共享锁和独占锁到底是什么" class="header-anchor">#</a> 共享锁和独占锁到底是什么？</h2> <h3 id="独占锁"><a href="#独占锁" class="header-anchor">#</a> 独占锁</h3> <p>前面讲过，多个事务同时更新一行数据，此时都会加锁，然后都会排队等待，必须一个事务执行完了，提交了，释放了锁，才能唤醒别的事务继续执行。<br>
那么多个事务运行时加的是什么类型的锁呢？<br> <strong>其实是X锁，也就是Exclude独占锁</strong>，当有一个事务加了独占锁之后，此时其他事务再要更新这行数据，都是要加独占锁的，但是智能生成独占锁在后面等待。</p> <p>当有人在更新数据的时候，其他的事务可以读取这行数据吗？默认情况下，需要加锁吗？<br>
答案是：不需要。</p> <p>原因：因为默认情况下，有人在更新数据的时候，你要去读取这行数据，直接默认就是开启MVCC机制的。<br>
也就是说此时对一行数据的读和写两个操作，默认是不会加锁互斥的，因为MySQL设计MVCC机制就是为了解决这个问题的，避免频繁加锁互斥。<br> <font color="#0000FF" size="4">查询操作加互斥锁的方法： select * from table for update</font></p> <h3 id="共享锁"><a href="#共享锁" class="header-anchor">#</a> 共享锁</h3> <p>万一执行查询操作时，就是想要加锁呢？<br>
MySQL也是Ok的，他提供了一种共享锁，就是S锁。<br> <font color="#0000FF" size="4">共享锁的语法如下：select * from table lock in share mode   </font><br>
你在一个查询语句后面加上 lock in share mode，就表示查询时对这行数据加了共享锁。</p> <p><font color="FF0000" size="4">如果此时有别的事务在更新这行数据，已经加了独占锁了，此时你的共享锁还能加吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你这个查询就只能等着了。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人再来更新要加独占锁，行吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你的更新只能等待。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人也来加共享锁，行吗？</font><br>
可以，共享锁和共享锁不会互斥。<br> <img src="/docs/assets/img/share_or_exclude_lock.9039512f.png" alt="共享锁和互斥锁关系图" title="share_or_exclude_lock.png"></p> <h2 id="哪些操作会导致在表级别加锁呢"><a href="#哪些操作会导致在表级别加锁呢" class="header-anchor">#</a> 哪些操作会导致在表级别加锁呢？</h2> <p>在多个事务并发更新数据的时候，都是要在行级别加独占锁的，这就是行锁，独占锁都是互斥的，所以不可能发生脏写问题，一个事务提交了才会释放自己的独占锁，唤醒下一个事务执行。</p> <p>如果你此时去读取别的事务在更新的数据，有两种可能：</p> <p>第一种可能是基于mvcc机制进行事务隔离，读取快照版本，这是比较常见的；<br>
第二种可能是查询的同时基于特殊语法去加独占锁或者共享锁。</p> <p>太建议在数据库粒度去通过行锁实现复杂的业务锁机制，而更加建议通过redis、zookeeper来用分布式锁实现复杂业务下的锁机制，其实更为合适一些。</p> <p>为什么呢？因为如果你把分布式系统里的复杂业务的一些锁机制依托数据库查询的时候，在SQL语句里加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的不好维护的，所以一般是不建议这么做的。</p> <p><strong>比较正常的情况而言，其实还是多个事务并发运行更新一条数据，默认加独占锁互斥，同时其他事务读取基于mvcc机制进行快照版本读，实现事务隔离。</strong></p> <p>有些人可能会以为当你执行增删改的时候默认加行锁，然后执行DDL语句的时候，比如alter table之类的语句，会默认在表级别加表锁。这么说也不太正确，但是也有一定的道理，因为确实你执行DDL的时候，会阻塞所有增删改操作；执行增删改的时候，会阻塞DDL操作。</p> <p>但这是通过MySQL通用的<strong>元数据锁实现的，也就是Metadata Locks，但这还不是表锁的概念</strong>。因为<strong>表锁其实是InnoDB存储引擎的概念</strong>，InnoDB存储引擎提供了自己的表级锁，跟这里DDL语句用的元数据锁还不是一个概念。</p> <p>只不过DDL语句和增删改操作，确实是互斥的，大家要知道这一点。</p> <h2 id="表锁和行锁互相之间的关系以及互斥规则是什么呢"><a href="#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="header-anchor">#</a> 表锁和行锁互相之间的关系以及互斥规则是什么呢？</h2> <p>MySQL的表锁其实非常鸡肋的东西，几乎不会有人用。表锁分为两种，一种是表锁，一种是表级的意向锁。</p> <p><font color="#0000FF" size="4">表锁加锁语法：<br>
LOCK TABLES XXX READ  这是加表级共享锁<br>
LOCK TABLES XXX WRITE 这是加表级独占锁<br></font></p> <p><font color="#0000FF" size="4">我们平时操作数据库，两种常见的表锁：<br>
更新时加的意向独占锁<br>
查询时加的意向共享锁  </font><br>
可以当这两种锁是透明的，因为意向独占锁和意向共享锁是不互斥的。<br> <img src="/docs/assets/img/table_lock.d40f61b5.png" alt="表锁" title="table_lock.png"><br> <img src="/docs/assets/img/lock_relation.c432bee4.png" alt="表锁关系" title="lock_relation.png"></p> <h2 id="线上数据库不确定性的性能抖动优化实践"><a href="#线上数据库不确定性的性能抖动优化实践" class="header-anchor">#</a> 线上数据库不确定性的性能抖动优化实践**</h2> <p>大家都知道，我们平时执行更新语句的时候，实际上都是从磁盘加载数据页到数据库内存的缓存页中，接着就直接更新内存里的缓存页，同时更新对应的redo log并写入一个buffer中，如下图所示：
<img src="/docs/assets/img/redo_log1.33a93a02.png" alt="redo log" title="redo_log1.png"></p> <p>既然我们更新了Buffer Pool里的缓存页，缓存页就变成了脏页，之所以说他是脏页，是因为缓存页里的数据目前跟磁盘文件里的数据页的数据是不一致的，所以此时的缓存页也叫作脏页。</p> <p><strong>既然是脏页就必然要有一个合适的时机把脏页给刷回磁盘文件，脏页刷回磁盘是通过LRU链表实现的，通过LRU链表，就可以知道哪些缓存页是最近经常被使用的。</strong></p> <p>如果后续你要加载磁盘里的数据页到Buffer Pool中去，但是此时并没有空闲的缓存页了，此时就必须把部分脏页给刷回磁盘，根据LRU链表找到最近最少被访问的缓存页刷回磁盘。</p> <p><img src="/docs/assets/img/redo_log2.d17eea1b.png" alt="redo log" title="redo_log2.png"></p> <p><font color="#FF0000" size="4">生产案例：假设你执行的查询语句，需要查询大量的数据到缓存页里去，此时可能会导致大量的脏页需要刷回磁盘，才能腾出足够的内存空间来执行这条查询语句。在这种情况下，可能你会发现，突然莫名其妙的执行某个查询语句慢了很多，平时只要几十毫秒的查询，这次花了几秒，因为你要等待大量脏页刷回磁盘，然后语句才能执行</font></p> <p>还有另外一种脏页刷磁盘的契机，我们知道redo log buffer中的redo log本身也会随着各种条件刷入磁盘，比如redo log buffer里的数据超过容量的一定比例了，或者是事务提交的时候，都会强制把buffer里的redo log刷回磁盘。<br>
然后我们也知道，磁盘上是有多个日志文件的，他会不停的写，如果所有的日志文件都写满了，他会回到第一个日志文件再次写入，这些日志文件是不停的循环写入的。所以<font color="#FF0000" size="4">其实在日志文件都被写满的情况下，也会触发一次脏页刷新。</font></p> <p>主要原因是假如第一个日志文件的redo log对应的缓存页的数据一直没有被刷入磁盘，一旦你往里面写入了别的日志，此时万一数据库崩溃，你之前更新过的数据是不是就丢失了？<br> <font color="#0000FF" size="4">所以一旦你把所有的日志文件都写满了，重新开始从第一个日志文件开始写的时候，他会判断一下，如果是你第一个日志文件里的一些redo log对应的缓存页，迄今为止都没有刷入磁盘，那么此时必然要把那些马上要被覆盖的redo log更新的缓存页都刷入到磁盘</font>，如下图所示：<br> <img src="/docs/assets/img/redo_log_flush_disk.e9b123b3.png" alt="redo log刷入磁盘的特殊时机" title="redo_log_flush_disk.png"></p> <p><strong>尤其是在这种刷脏页的情况下，因为redo log所有日志文件都写满了，此时会导致数据库直接hang死，无法处理任何更新请求，因为执行任何一个更新请求都必须要写redo log，此时你需要刷新一些脏页到磁盘，然后才能继续执行更新语句，把更新语句生成的redo log从第一个日志文件开始覆盖写入</strong>。</p> <p>综上所述：到线上数据库的查询和更新语句莫名其妙出现性能抖动，很有可能就是上述两种情况导致的大量脏页刷入磁盘，你要等刷入磁盘后，才能继续执行。<br> <img src="/docs/assets/img/redo_log_flush_disk2.ca42aeb5.png" alt="redo log刷入磁盘的特殊时机" title="redo_log_flush_disk2.png"></p> <h2 id="上述问题导致数据库性能抖动的优化方案"><a href="#上述问题导致数据库性能抖动的优化方案" class="header-anchor">#</a> 上述问题导致数据库性能抖动的优化方案</h2> <p>上述两个场景导致大量的缓存页flush到磁盘，就会导致莫名其妙的出现SQL语句性能抖动了。<br>
优化的核心思路就两个：<br>
第一种：减少刷磁盘的频率<br>
第二种：加快刷入磁盘的速度<br>
第一种方案可以抛弃，因为你的缓存页正常被使用时，总有被填满的时候，我们没法控制，一旦缓存页被填满就会导致大量缓存页flush到磁盘。除非你给机器加大内存，给buffer pool分配的空间大一些。<br> <font color="#FF0000" size="4">第二种方案的关键是尽可能减少flush缓存页到磁盘的时间。建议可以采用SSD固态硬盘，然后设置一个参数，innodb_io_capacity,这个参数就是告诉数据库采用多大的IO速率把缓存页flush到磁盘里去。</font></p> <p><strong>fio是linux上一种用于测试磁盘最大随机io速率的工具</strong>。</p> <p><font color="#0000FF" size="4">实际在刷入磁盘的时候，它会根据innodb_io_capacity乘以一个百分比进行刷磁盘，这个百分比就是脏页的比例，是由innodb_max_dirty_pct参数控制的，默认是75%，这个参数一般不用动。</font></p> <p><font color="#FF0000" size="4">还有一个参数：innodb_flush_neighbors,它的意思是flush缓存页到磁盘的时候可能会把缓存页临近的其他缓存页也刷入磁盘。可以把这个参数值设置为0，禁止刷临近缓存页到磁盘。</font></p> <h2 id="磁盘数据页的存储结构"><a href="#磁盘数据页的存储结构" class="header-anchor">#</a> 磁盘数据页的存储结构</h2> <h3 id="数据库的索引原理及查询原理"><a href="#数据库的索引原理及查询原理" class="header-anchor">#</a> 数据库的索引原理及查询原理</h3> <p>数据库最终所有的数据（包括我们建的各种表以及表里的数据）都是要存放在磁盘上的文件里的，然后在文件里存储的数据格式就是数据页，那么大量的数据页在磁盘文件里是怎么存储的呢？<br>
首先要明白一点，大量的数据页是按照顺序一页一页存放的，然后相邻数据页之间会采用双向链表的格式相互引用，如下图：
<img src="/docs/assets/img/data_page_list.eb2667d1.png" alt="文件中数据页存放规则" title="data_page_list.png"></p> <p>其实一个数据页在磁盘里就是一段数据，数据页里包含两个指针，一个指向自己上一个数据页的物理地址，一个指针指向自己下一个数据页的物理地址，大概可以认为类似下面这样：<br> <img src="/docs/assets/img/data_page_list2.c8e6c3f2.png" alt="文件中数据页存放规则" title="data_page_list2.png"><br>
每个数据页里可以认为就是DataPage开头一直到||符号之间的一段连续的数据，可以认为就是数据页。<br>
然后数据页内部会存储一行一行的数据，也就是平时我们在表里插入的一行一行的数据就会存储在数据页里，然后数据页里每行数据都会按照主键大小进行排序存储，同时每行数据都有一个指针指向下一行数据的位置，组成单项链表，如下图：
<img src="/docs/assets/img/data_page_list3.abe9cb7c.png" alt="文件中数据页存放规则" title="data_page_list3.png"></p> <h2 id="数据库是如何根据查询语句搜索数据的"><a href="#数据库是如何根据查询语句搜索数据的" class="header-anchor">#</a> 数据库是如何根据查询语句搜索数据的？</h2> <p>没有索引的情况下，数据库是如何根据查询语句搜索数据的？<br> <font color="#FF0000" size="4">我们应该知道数据页之间是组成双向链表的，然后数据页内部的数据行是组成单向链表的，而且数据行是根据主键从小到大排序的。</font><br>
然后每个<strong>数据页里都会有一个页目录，里面存的是主键跟所在槽位的映射关系，如下图所示</strong>：<br> <img src="/docs/assets/img/data_page_list4.6dbd717a.png" alt="文件中数据页存放规则" title="data_page_list4.png"></p> <p>假设你要根据主键查找一条数据，并且假设这个表里没有几条数据，只存了一个数据页。首先会到数据页的页目录里根据主键进行二分查找，找到主键对应的数据在哪个槽位里，然后到那个槽位里去，遍历槽里的每一行数据，就能快速找到那个主键对应的数据了。</p> <p><strong>每个槽位里都有一组数据行</strong>。</p> <p>假设根据非主键查找呢？<br>
那就尴尬了，此时你没法使用主键的那种二分查找方式，只能进入到数据页里，根据单向链表依次遍历查找数据了，这样的性能就很差了。</p> <p>下面来说说有很多数据页的情况：<br>
假设你没有建立任何索引，那么无论你根据主键查询还是根据其他字段为条件查询，都没有什么取巧的办法。<br>
因为表里的所有数据页都是组成双向链表的，查找的时候，要先把第一个数据页给加载到Buffer Pool的缓存页中，然后如果你是根据主键查找的话，就在数据页内使用二分查找的方式；如果是根据非主键查询的话，就只能根据数据行的单向链表来遍历查找，如下图：<br> <img src="/docs/assets/img/data_page_list5.abfe1fa7.png" alt="文件中数据页存放规则" title="data_page_list5.png"><br>
假设第一个数据页没有找到你要的数据，怎么办呢？<br>
没办法，只能根据数据页组成的双向链表，找到下一个数据页，然后加载到Buffer Pool的缓存页里去，然后按照上述的方法在缓存页查找数据。<br>
如果还是查不到呢？<br>
那就只能根据双向链表加载下一个数据页到Buffer Pool的缓存页里去，依次类推，循环往复。</p> <p>其实上面的过程就是<strong>全表扫描</strong>。</p> <h2 id="不断在表中插入数据时-物理存储是如何进行页分裂的"><a href="#不断在表中插入数据时-物理存储是如何进行页分裂的" class="header-anchor">#</a> 不断在表中插入数据时，物理存储是如何进行页分裂的？</h2> <p>往表里不断插入 数据时，会涉及到一个<font color="#FF0000" size="4">页分裂的过程</font>，也就是说，表里是如何出现一个又一个的数据页的。</p> <p>数据页内部的数据行会组成一个单向链表，如下图所示：<br> <img src="/docs/assets/img/data_page_list6.69e4fbc5.png" alt="文件中数据页存放规则" title="data_page_list6.png"><br>
上图中是一行一行的数据，刚开始<font color="#FF0000" size="4">第一行是起始行，它的行类型是2，是最小的一行</font>，然后它有一个指针指向了下一行数据，每一行数据都存字段的值，然后每一行通过指针指向下一行数据，<font color="#FF0000" size="4">普通数据行的类型都是0，最后一行 的行类型是3，代表最大的一行。</font></p> <p>假设你不断的往表里插入数据，如果第一个数据页满了，那么就需要在搞一个数据页，如下图：<br> <img src="/docs/assets/img/data_page_list7.ee1df72a.png" alt="文件中数据页存放规则" title="data_page_list7.png"><br>
但是此时会遇到一个问题，后续我们会讲到索引的机制，<font color="#FF0000" size="4">索引运作的一个核心基础就是要求你后一个数据页里的主键值都必须大于前一个数据页里的主键值。</font></p> <p>如果你的主键是自增的，还可以 保证这一点；但是如果你的主键不是自增长的，可能会出现后一个数据页里的主键值，有的小于前一个数据页里的主键值。</p> <p>所以此时会出现一个过程，叫<strong>页分裂</strong>，就是万一你的主键值都是你自己设置的，那么在增加一个新的数据页的时候，可能会把前一个数据页里主键值较大的挪到后一个数据页里去，然后把你插入的较小的数据挪到上一个数据页里去，保证新数据页里的主键值都比上一个数据页里的主键值大。<br> <img src="/docs/assets/img/data_page_list8.fa12e30a.png" alt="文件中数据页存放规则" title="data_page_list8.png"><br>
如上图所示，第一个数据页里有1，5,6三条数据，第二个数据页里有，2,3,4三条数据，明显第二个数据页里的主键值比第一个数据页里的主键值要小，这是不允许的。<br>
此时会出现页分裂的过程，把新数据页的两条数据挪到上一个数据页，上一个数据页挪两条数据到新数据页中去，如下图：<br> <img src="/docs/assets/img/data_page_list9.1994787d.png" alt="文件中数据页存放规则" title="data_page_list9.png"></p> <p>有了页分裂这个过程，保证了每个数据页里的主键值的规则，就能为后续的索引打下基础。</p> <h2 id="基于主键的索引是如何设计的"><a href="#基于主键的索引是如何设计的" class="header-anchor">#</a> 基于主键的索引是如何设计的</h2> <p>假设我们有多个数据页，我们想根据主键来查询数据，那么直接查询也是不行的，因为我们不知道主键到底在哪里？<br> <img src="/docs/assets/img/data_page_list10.b26d1517.png" alt="文件中数据页存放规则" title="data_page_list10.png"><br>
比如上图，你想查找id=4的数据，你怎么知道在哪个数据页里？<br>
所以假设是这个样子的话，你还是只能走全表扫描了。<br>
所以此时就需要针对主键设计一个索引了，针对主键的索引其实就是<font color="#FF0000" size="4">主键目录，就是把每个数据页的页号，还有数据页里最小的主键值放在一起，组成一个索引目录。</font> 如下图所示：<br> <img src="/docs/assets/img/data_page_list11.6f8d69dd.png" alt="文件中数据页存放规则" title="data_page_list11.png"><br>
现在有了上图的主键目录就方便了，可以直接到主键目录去搜索，比如你要找id=3的数据，此时就会根据每个数据页的最小主键来比，首先id=3大于了数据页2里的最小主键值1，接着小于了数据页8里的最小主键值4。</p> <p>所以既然如此，你直接就可以定位到id=3的数据一定是在数据页2里的！</p> <p><strong>使用二分查找查找数据页：假设你有很多的数据页，在主键目录里就会有很多的数据页和最小主键值，此时你完全可以根据二分查找的方式来找你要找的id到底在哪个数据页里</strong>！</p> <p>所以这个效率是非常之高的，而类似上图的主键目录，就可以认为是主键索引。</p> <p>而大家都知道我们的数据页都是一坨一坨的连续数据放在很多磁盘文件里的，所以只要你能够根据主键索引定位到数据所在的数据页，此时假设我们有别的方式存储了数据页跟磁盘文件的对应关系，此时你就可以找到一个磁盘文件。</p> <p>而且我们假设<strong>数据页在磁盘文件里的位置也就是offset偏移量</strong>，你也是可以知道的，此时就可以直接通过随机读的方式定位到磁盘文件的某个offset偏移量的位置，然后就可以读取连续的 一大坨数据页了！</p> <h2 id="索引的页存储物理结构-是如何用b-树来实现的"><a href="#索引的页存储物理结构-是如何用b-树来实现的" class="header-anchor">#</a> 索引的页存储物理结构，是如何用B+树来实现的？</h2> <p>只要在一个主键索引里包含每个数据页跟它的最小主键值，就可以组成一个索引目录，然后后续你根据主键值查找，就可以在索引目录里二分查找直接定位到那条数据所在的数据页，接着到数据页里二分查找定位那条数据就可以了，如下图：<br> <img src="/docs/assets/img/data_page_list11.6f8d69dd.png" alt="文件中数据页存放规则" title="data_page_list11.png"><br>
但是现在问题来了，假设你的数据很多很多，有上千万的数据，甚至单表几亿数据都是有可能的，此时可能会有大量的数据页，然后你的索引目录里就要存储大量的数据页和最小主键值，这也是有问题的。</p> <p>所以在考虑这个问题的时候，实际上是采取了一种把索引数据存储在数据页里的方式来做的。<br>
也就是说，表数据是存在数据页里，然后表的索引其实也是存在数据页里的，索引放到页里之后，就会有索引页，假设你有很多很多的数据页，那么此时你就会有很多的索引页，如下图所示：<br> <img src="/docs/assets/img/data_page_list12.5398c2a4.png" alt="文件中数据页存放规则" title="data_page_list12.png"><br>
但是现在又有问题了，因为你有太多的索引页，因为你需要知道，应该在哪个索引页里去找你的主键数据，这也是个大问题？</p> <p>于是接下来我们把索引页多加一个层级出来，在更高的索引层级里，保存了每个索引页和索引页里的最小主键值，如下图所示：<br> <img src="/docs/assets/img/data_page_list13.5d335786.png" alt="文件中数据页存放规则" title="data_page_list13.png"></p> <p>现在就好了，假设我们要查询id=46的，直接先到最顶层的索引页35里面去找，直接通过二分查找就可以定位到下一步应该到索引页20（里面存了数据页的页号和最小主键值）里面去找，接下来在索引页20里二分查找，可以定位到数据应该在数据页8里，在进入数据页8里，就可以找到id=46的那行数据了。</p> <p>那么问题又来了，假设最顶层的索引页里存放的下层索引页的页号也非常多，怎么办呢？<br>
此时可以再次分裂，再加一层索引页，比如下图：<br> <img src="/docs/assets/img/data_page_list14.08a5fe72.png" alt="文件中数据页存放规则" title="data_page_list14.png"></p> <p>上图想不想一棵树？<br>
没错，这就是一棵<strong>B+树</strong>，MySQL的索引就是用B+树实现的。<br>
这就是索引最真实的物理存储结构，采用跟数据页一样的数据结构来存储，一个索引就是很多数据页组成的B+树。</p> <h2 id="更新数据的时候-自动维护的聚簇索引到底是什么"><a href="#更新数据的时候-自动维护的聚簇索引到底是什么" class="header-anchor">#</a> 更新数据的时候，自动维护的聚簇索引到底是什么？</h2> <p><strong>聚簇索引：如果一颗大的B+树索引数据结构里，叶子节点就是数据页本身，那么我们可以称这个B+树索引为聚簇索引</strong>。<br>
在innoDB的存储引擎里，对数据增删改的时候，就是直接把你的数据页放在聚簇索引里的。比如你插入数据就是在数据页里插入数据。<br>
如果你的数据页开始分裂了，此时会自动调整数据页内部的行数据，保证数据页内的主键值都是有顺序的，下一个数据页里的主键值大于上一个数据页里的所有主键值。<br>
一般索引页里可以放很多索引条目，<strong>即使你是亿级的大表，所建的索引的层级也就三四层而已</strong>。</p> <h2 id="主键之外的字段建立的二级索引-又是如何运作的"><a href="#主键之外的字段建立的二级索引-又是如何运作的" class="header-anchor">#</a> 主键之外的字段建立的二级索引，又是如何运作的？</h2> <p>主键外的其它字段建立索引的原理：<br>
假设你要基于其他字段建立索引，比如name，age之类的字段，都是同一个原理。比如你插入数据的时候，一方面会把完整数据插入到聚簇索引的叶子结点的数据页里去，同时维护好聚簇索引，另一方面，会为其他字段建立的索引，再建立一棵B+树。<br>
比如你以name字段建立一个索引，那么此时你插入数据的时候，就会从新搞一个B+树，B+树的叶子节点也是数据页，但是这个数据页里仅仅存放主键字段和name字段，如下图：<br> <img src="/docs/assets/img/data_page_list15.5023eacd.png" alt="文件中数据页存放规则" title="data_page_list15.png"><br>
聚簇索引和name字段的B+树是相互独立的两棵树。<br>
name字段的B+树里，<strong>叶子节点的数据页中name的值都是按照大小排序的，同时下一个数据页里的name字段值都大于上一个数据页里的name字段值</strong>，这个整体的排序规则跟聚簇索引里按照主键的排序规则是一样的。<br> <img src="/docs/assets/img/data_page_list16.80a0036d.png" alt="文件中数据页存放规则" title="data_page_list16.png"></p> <p><font color="#FF0000" size="4">根据name字段搜索数据的过程：</font>从name字段的B+树的根节点开始找，一层层往下找，一直找到叶子节点的数据页里，定位到name字段对应的主键值。<br>
此时针对select * from table where name='xxx'这样的语句，你先根据name字段在name字段的B+树索引找，找到叶子节点，也仅仅是能找到对应的主键值，而找不到这行完整的数据。<br>
所以此时需要<strong>回表</strong>，就是说还需要根据主键值，再到聚簇索引里从根节点开始，一路找到叶子节点的数据页，定位到主键对应的完整数据行，此时才能把select *对应的所有字段值拿出来。</p> <p>因为我们根据name字段的索引B+树找到主键后，还需要根据主键去聚簇索引里找，所以一般name字段这种普通字段的索引称为<strong>二级索引</strong>，把聚簇索引称为<strong>一级索引</strong>，这就是普通字段的索引的运行原理。</p> <p>多个字段建立联合索引，比如name+age<br>
联合索引的运行原理也是一样的，只不过在这颗独立的B+树索引里，叶子节点的数据页存放的是id+name+age，然后默认按照name排序，name一样就按照age排序，不同的数据页之间的name+age值的排序也是如此。<br>
然后这个name+age的联合索引的B+树索引页里，放的是下层节点的页号和最小的name+age的值，以此类推，当你根据name+age搜索的时候，就会走name+age联合索引的这棵B+树了，搜索到了主键后，再根据主键到聚簇索引里去搜索。</p> <h2 id="插入数据时到底是如何维护好不同索引的b-树的"><a href="#插入数据时到底是如何维护好不同索引的b-树的" class="header-anchor">#</a> 插入数据时到底是如何维护好不同索引的B+树的？</h2> <p>插入数据时是如何维护不同索引的B+树的？<br>
首先，表刚建的时候，它就是一个数据页，这个数据页属于聚簇索引的一部分，而且目前还是空的。<br>
此时如果你插入数据，就是直接在这个数据页里插入就可以了，也没必要给它弄索引页，如下图：<br> <img src="/docs/assets/img/page_index1.02c27ac1.png" alt="索引页结构" title="page_index1.png"></p> <p>这个初始的数据页其实就是根页，每个数据页内部默认就有一个基于主键的页目录，所以此时你根据主键来搜索都是没问题的，直接在唯一一个数据页里</p> <p>当表里的数据越来越多的时候，如果第一个数据页满了，会再弄一个数据页，根据主键值的大小进行移动，让两个数据页的数据根据主键值排序，并且保证第二个数据页的主键值都大于第一个数据页里的主键值，如下图:<br> <img src="/docs/assets/img/page_index2.67e5c4e4.png" alt="索引页结构" title="page_index2.png"></p> <p>那么此时根页在哪呢？<br>
此时根页就升级为索引页了，这个根页里存放的就是两个数据页的页号和他们里面的最小主键值，所以此时看起来如下图：<br> <img src="/docs/assets/img/page_index3.83743862.png" alt="索引页结构" title="page_index3.png"></p> <p>接着你肯定会不停的往表里插入数据，然后数据页不停的进行页分裂，分裂出越来越多的数据页。<br>
此时你唯一的一个索引页，也就是根页里存放的数据页索引条目越来越多，连你的索引页都放不下了，那你就让一个索引页分裂为两个索引页，然后根页继续往上走一个层级引用两个索引页。如下图：<br> <img src="/docs/assets/img/page_index4.a39b0b81.png" alt="索引页结构" title="page_index4.png"><br>
接着就是以此类推了，你的数据页越来越多，那么根页指向的索引页也不停的分裂，分裂出更多的索引页，当你下层的索引页数量太多的时候，会导致你的根页指向的索引页太多了，此时根页继续分裂为多个索引页，根页再次往上提上去一个层级。<br>
这其实就是增删改时，整个聚簇索引维护的一个过程，其实其他二级索引也是类似的一个原理。<br> <img src="/docs/assets/img/page_index5.5d283ba6.png" alt="索引页结构" title="page_index5.png"></p> <h2 id="一个表里是不是索引搞的越多越好"><a href="#一个表里是不是索引搞的越多越好" class="header-anchor">#</a> 一个表里是不是索引搞的越多越好？</h2> <p>那就大错特错了。<br> <font color="#FF0000" size="4">B+树的特性：那就是数据页/索引页里的记录组成一个单向链表，而且是按照数据大小有序排列的；然后数据页/索引页之间组成双向链表，而且也是按照数据大小有序排列的，所以B+树索引是一个完全有序的数据结构，无论是页内还是页之间。</font><br> <strong>索引的缺点：</strong> 一个是空间上，一个是时间上。<br>
空间上，如果你给很多字段创建索引，那么就会创建很多棵B+树，每一颗B+树都要占用很多的磁盘空间。<br>
时间上，你要是搞了很多索引，那么在你进行增删改的时候，每次都需要维护各个索引的数据的有序性。<br>
所以你不停的增删改，必然会导致各个数据页之间的值可能会没有顺序，比如数据页里插入了一个比较小的值，居然比上一个数据页的值还要小！此时就没有办法了，只能进行数据页的挪动，维护页之间的顺序。</p> <p>或者是你不停的插入，数据页不停的分裂，不停的增加新的索引页，这个过程也是耗费时间的。</p> <h2 id="通过一步一图来深入理解联合索引查询原理以及全值匹配规则"><a href="#通过一步一图来深入理解联合索引查询原理以及全值匹配规则" class="header-anchor">#</a> 通过一步一图来深入理解联合索引查询原理以及全值匹配规则</h2> <p>我们设计系统的时候<strong>一般是设计联合索引，原因是尽可能让索引数量小一些，避免磁盘占用太多，增删改性能太差</strong>。</p> <p>假设我们有一个学生成绩表，这个表有个id字段，是自增长的主键，默认就会基于它做一个聚簇索引。<br>
成绩表包含学生班级、学生姓名、科目名称、分数四个字段，平时可能查的最多的就是找某个班的某个学生某科的成绩。<br>
所以我们基于班级、学生姓名和科目名称建立一个联合索引。<br> <img src="/docs/assets/img/union_index1.1bc4b9e3.png" alt="联合索引结构图" title="union_index1.png"></p> <p>图中有两个数据页，第一个数据页有3条数据，每条数据都包含了联合索引的3个字段值和主键值，数据页内部是按照顺序排序的。<br>
首先按照班级字段的值来排序，如果一样则按照学生姓名排序，如果还一样，则按照科目名称来排序，所以数据页内部是按照三个字段的值来排序的，而且还组成了单向链表。</p> <p>然后数据页之间也是有顺序的，第二个数据页里的三个字段的值一定都大于上一个数据页里三个字段的值，比较方法也是按照班级名称、学生名称、科目名称依次来比较的，数据页之间组成双向链表。</p> <p>索引页里就两条数据，分别指向两个数据页，索引里存放的是数据页里最小的那个数据的值。</p> <p>索引页内部的数据页组成单向链表并且是有序的，如果你有多个索引页，那么索引页之间也是有序的，组成了双向链表。</p> <p>假设我们想搜索：一班+张小强+数学的成绩，此时可能会写类似下面的sql，select * from student_score where class_name='一班' and student_name='张小强' and subject_name='数学'。<br>
此时就涉及到了一个索引的使用规则，那就是你发起的sql语句里，where条件里几个字段都是基于等值来查询，都是用的等于号。而且where条件里的几个字段的名称和顺序也跟你联合索引里一模一样。此时就是<font color="#FF0000" size="4">等值匹配规则</font>，上面的sql语句是百分之百可以使用联合索引来查询。</p> <p>查询的过程：首先到索引页里去找，因为索引页里有多个数据页的最小值记录，此时直接在索引页里基于二分查找就可以了。先根据班级名称来找1班这个值对应的数据页，直接可以定位到他所在的数据页，如下图：<br> <img src="/docs/assets/img/page_index6.a02618c5.png" alt="联合索引结构图" title="page_index6.png"><br>
然后你直接找到索引页中索引指向的数据页，数据页内部是单向链表，你也是根据二分查找来找，先按1班这个值来找，你会发现几条数据都是1班，然后可以按照张小强这个姓名来二分查找，此时你会发现多条数据是张小强，最后按照科目名称进行二分查找。很快就可以定位到下图中的一条数据，1班的张小强的数学成绩对应的主键id=127，如下图所示：<br> <img src="/docs/assets/img/page_index7.ed0e2f2c.png" alt="联合索引结构图" title="page_index7.png"><br>
然后根据主键id=127到聚簇索引里按照一样的思路，从索引根节点开始二分查找迅速定位到下层的索引页，在不停的找，很快就可以找到id=127那条数据，然后从里面提取所有的字段，包括分数就可以了。</p> <h2 id="最常见和最基本的索引使用规则"><a href="#最常见和最基本的索引使用规则" class="header-anchor">#</a> 最常见和最基本的索引使用规则</h2> <p><strong>如果你使用了联合索引的所有字段了，但是顺序和联合索引中字段的顺序有差异，也没关系，MySQL自动优化为按联合索引的字段顺序去找</strong>。<br>
第二个规则，就是<font color="#FF0000" size="4">最左侧列匹配</font>，意思是假设我们的联合索引是KEY(class_name,student_name,subject_name),那么不一定必须要在where语句里根据三个字段来查，其实只要根据最左侧的部分字段来查，也是可以的。</p> <p>比如你的sql如下：select * from student_score where class_name='' and student_name=''，就是查某个班级某个学生的所有科目的成绩是ok的。</p> <p>假设你的sql是：select * from student_score where subject_name=''，这样是不行的，<strong>因为联合索引的B+树里，是必须先按照class_name查，再按student_name查，不能跳过前面两个字段，直接按最后一个字段subject_name来查</strong>。</p> <p>假设你的sql是：select * from student_score where class_name='' and subject_name=''，那么只有class_name可以在索引里搜索，剩下的subject_name是没法在索引里搜索的，道理同上。</p> <p><strong>所以在建立索引的过程中，必须考虑好联合字段索引的顺序，以及平时写sql的时候要按照哪几个字段来查</strong>。</p> <p>第三个规则，<font color="#FF0000" size="4">最左前缀匹配原则（模糊符号必须在右侧）</font>，即如果你要按照like语法来查，比如select * from student_score where class_name like '1%',查找所有1开头的班级的分数，这也是可以用到索引的。</p> <p>但是如果你写class_name like '%班级'，在左侧用一个模糊匹配符，那就没法使用索引了，因为不知道你最左前缀是什么，怎么去索引里找？</p> <p>第四个规则，就是<font color="#FF0000" size="4">范围查找规则</font>，意思是说我们可以使用select * from student_score where class_name &gt;'1班' and class_name&lt;'5班' 这样的语句范围内查找几个班级的分数，这个时候也是走索引的。</p> <p>因为我们的索引的最下层的数据页都是按照顺序组成双向链表的，所以完全可以先找到‘1班’对应的数据页，再找到‘5班’对应的数据页，两个数据页中间的那些数据页，就全都是在你范围内的数据了！</p> <p>但是如果你要写select * from student_score where class_name &gt;'1班' and class_name&lt;'5班' and studeng_name&gt;'xxx'，这里只有class_name是可以基于索引来找，student_name的范围查询是没法用到索引的！</p> <p><font color="#FF0000" size="4">这也是一条规则，就是你的where语句里有范围查询，那只有对联合索引里最左侧的列进行范围查询才会走索引。</font></p> <p>第五个规则，<font color="#FF0000" size="4">等值匹配+范围匹配的规则</font>，如果你要用select * from student_score where class_name ='1班' and student_name&gt;'' and subject_name&lt;'',那么你首先可以根据class_name在索引里精确定位到一波数据，接着这波数据里的student_name都是按照顺序排列的，所以student_name&gt;''也会基于索引来找，但是接下来的subject_name是不能用索引的。</p> <h2 id="当我们在sql里进行排序的时候-如何才能使用索引"><a href="#当我们在sql里进行排序的时候-如何才能使用索引" class="header-anchor">#</a> 当我们在SQL里进行排序的时候，如何才能使用索引？</h2> <p>假设我们建立了一个INDEX(xx1,xx2,xx3)这样的一个联合索引，这个时候默认情况下，索引树里本身就是依次按照xx1，xx2、xx3三个字段的值进行排序的，那么此时你在运行select * from table order by xx1,xx2,xx3 limit 100这样的语句，你觉得还需要再进行排序吗？</p> <p>显然是不用了。直接按照索引树里的顺序把xx1，xx2，xx3三个字段按照从小到大的值获取前面100条就可以了。<br>
然后拿到100条数据的主键，再去聚簇索引里回表查询剩余的所有字段。</p> <p><font color="#0000FF" size="4">所以说，在你的sql语句里，应该尽量按照联合索引的字段顺序进行order by排序，这样就可以直接利用联合索引里数据的有序性，到索引树里直接按照字段值的顺序去获取你需要的数据。</font><br> <font color="#FF0000" size="4">但是直接利用联合索引字段的顺序排序有一定的限制：就是你要么按照联合索引的字段升序查询，要么按照联合索引的字段降序查询</font>，有的升序有的降序的话，就不会再走联合索引了。</p> <p>如果都是升序排列，直接就从索引树里最小的开始读取一定的条数就可以了；如果都是降序排列，那就从索引树里最大的数据开始读取一定的条数就可以了。</p> <h2 id="在sql里进行分组的时候-如何才能使用索引"><a href="#在sql里进行分组的时候-如何才能使用索引" class="header-anchor">#</a> 在SQL里进行分组的时候，如何才能使用索引？</h2> <p>假设你的sql语句如下：<br>
select count(*) from table group by xx,似乎看起来你需要把所有的数据放到一个临时磁盘文件里还有加上部分内存，去搞一个分组，按照指定字段的值分成一组一组的，接着对每一组都执行一个聚合函数，这个性能是极差的，因为毕竟涉及到了大量的磁盘交互。</p> <p>因为在我们的索引树里默认都是按照指定的一些字段排序好的，其实字段相同的值都是在一起的，假设要走索引去执行分组后再聚合，那性能一定是比磁盘文件里自行要快很多了。<br> <strong>所以通常而言，对于group by后的字段，最好也是按照联合索引里最左侧的字段开始，按照顺序排列开来，这样的话，其实就可以完美应用索引来提取一组一组的数据，然后针对每一组的数据执行聚合函数就好了</strong>。<br> <img src="/docs/assets/img/page_index8.a8369efb.png" alt="group by和order by如何走联合索引" title="page_index8.png"><br> <img src="/docs/assets/img/page_index9.2794d53e.png" alt="group by和order by如何走联合索引" title="page_index9.png"></p> <h2 id="回表查询对性能的损害以及覆盖索引是什么"><a href="#回表查询对性能的损害以及覆盖索引是什么" class="header-anchor">#</a> 回表查询对性能的损害以及覆盖索引是什么？</h2> <p><img src="/docs/assets/img/page_index10.23fa0d62.png" alt="走联合索引还是全表扫描" title="page_index10.png"><br> <strong>覆盖索引</strong>：它不是一种索引，它是指基于索引查询的一种方式。<br>
意思是针对类似于select xx1,xx2,xx3 from table order by xx1,xx2,xx3这样的语句，你仅仅需要联合索引里的几个字段的值，那么其实只要扫描联合索引的索引树就可以了，不需要回表查询聚簇索引里的其他字段了。</p> <p>即使你真的要回表到聚簇索引，那你要尽可能的用limit、where之类的语句，限定一下回表到聚簇索引的次数，从联合索引里筛选少量数据，这样回表的次数也会减少，进而提升性能。</p> <h2 id="设计索引的时候-我们一般要考虑哪些因素呢"><a href="#设计索引的时候-我们一般要考虑哪些因素呢" class="header-anchor">#</a> 设计索引的时候，我们一般要考虑哪些因素呢？</h2> <p><img src="/docs/assets/img/design_index1.ad52ff44.png" alt="电商平台表设计" title="design_index1.png"></p> <p>设计好表结构之后，接下来要做的就是设计表的索引，这个设计索引的时候，我们要考虑的第一点，就是未来我们对表进行查询的时候，大概会如何进行查询？</p> <p>如果不知道没关系，在我们系统开发完，功能都跑通后，此时我们已经写完所有的SQL，这个时候稳定知道对表发起了什么样的查询语句了吧？</p> <p><font color="#FF0000" size="4">第一个索引设计原则：</font>针对你sql语句里的where、order by条件以及group by条件去设计索引。<br> <img src="/docs/assets/img/design_index2.240123c4.png" alt="电商平台表设计" title="design_index2.png"></p> <p>在设计索引的时候还得考虑其他因素，首先一个就是<font color="#FF0000" size="4">字段基数问题，</font> 举个例子，假设有10万行数据，但是字段A只有两个值，要么是0，要么是1，那么它的基数就是2。<br>
假设你要针对上面说的这种字段建立索引的话，还不如走全表扫描，因为你的索引数据仅仅包含了0和1两种值，根本没法进行快速的二分查找，所以这个时候选这种基数很低的字段建立索引意义就不大了。</p> <p><font color="#FF0000" size="4">第二个索引设计原则：</font><strong>一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那样才能发挥出B+树二分查找的优势来</strong>。</p> <p><font color="#FF0000" size="4">第三个索引设计原则：</font>尽量对那些<strong>字段类型比较小的列来设计索引</strong>，因为字段类型小的话，占用的磁盘空间也小，此时你搜索时，性能也会好一些。</p> <p><strong>前缀索引（<font color="#FF0000" size="4">第四个索引设计原则</font>）</strong>：<br> <img src="/docs/assets/img/design_index3.575bccf7.png" alt="前缀索引设计" title="design_index3.png"><br> <font color="#FF0000" size="4">第五个索引设计原则：</font>不要在索引列上嵌套函数。<br>
比如where function(a)=xx,这种是不会走索引的。</p> <p>你不停的增删改数据，就会不停的更新你的索引树。<br>
因为你插入的数据值可能不是按照顺序来的，很可能会导致索引树里的某个页会自动分裂，这个页分裂的过程就很耗费时间，<strong>因此一般让大家设计索引别太多，建议两三个联合索引就应该覆盖掉你这个表的全部查询了</strong>。</p> <p>否则索引太多，必然会导致你增删改的时候，要更新多个索引树。</p> <p><font color="#FF0000" size="4">另外关键一点，建议大家主键一定是自增的，别用UUID之类的</font>，因为主键自增，那么起码你的聚簇索引不会频繁的分裂，主键值都是有序的，就会自然的新增一个页而已，但是如果你使用的是UUID，那么会导致聚簇索引频繁的页分裂。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/mysql.html" class="prev">
        MySQL章节1
      </a></span> <span class="next"><a href="/docs/thread.html">
        多线程知识
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.6c5ec198.js" defer></script><script src="/docs/assets/js/5.6f787e98.js" defer></script><script src="/docs/assets/js/4.14b81a4f.js" defer></script>
  </body>
</html>
