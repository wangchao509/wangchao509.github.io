<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL章节2 | whc的学习笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="主要是java技术类笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.44acb28c.css" as="style"><link rel="preload" href="/docs/assets/js/app.92b3039a.js" as="script"><link rel="preload" href="/docs/assets/js/5.4f0d6612.js" as="script"><link rel="preload" href="/docs/assets/js/3.27366f81.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.50cd0b84.js"><link rel="prefetch" href="/docs/assets/js/11.4e21d111.js"><link rel="prefetch" href="/docs/assets/js/12.66aabccd.js"><link rel="prefetch" href="/docs/assets/js/2.ac6e5ba7.js"><link rel="prefetch" href="/docs/assets/js/4.062fc564.js"><link rel="prefetch" href="/docs/assets/js/6.7dc7d677.js"><link rel="prefetch" href="/docs/assets/js/7.80edc091.js"><link rel="prefetch" href="/docs/assets/js/8.e1942d83.js"><link rel="prefetch" href="/docs/assets/js/9.f83f2f4c.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.44acb28c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">whc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">站点介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>markdown知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/markdown.html" class="sidebar-link">前端知识介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MySQL知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/mysql0.html" class="sidebar-link">MySQL章节0</a></li><li><a href="/docs/mysql.html" class="sidebar-link">MySQL章节1</a></li><li><a href="/docs/mysql2.html" aria-current="page" class="active sidebar-link">MySQL章节2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="sidebar-link">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#多个事务更新同一行数据时-是如何加锁避免脏写的" class="sidebar-link">多个事务更新同一行数据时，是如何加锁避免脏写的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#共享锁和独占锁到底是什么" class="sidebar-link">共享锁和独占锁到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#哪些操作会导致在表级别加锁呢" class="sidebar-link">哪些操作会导致在表级别加锁呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="sidebar-link">表锁和行锁互相之间的关系以及互斥规则是什么呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#线上数据库不确定性的性能抖动优化实践" class="sidebar-link">线上数据库不确定性的性能抖动优化实践**</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#上述问题导致数据库性能抖动的优化方案" class="sidebar-link">上述问题导致数据库性能抖动的优化方案</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#磁盘数据页的存储结构" class="sidebar-link">磁盘数据页的存储结构</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#数据库是如何根据查询语句搜索数据的" class="sidebar-link">数据库是如何根据查询语句搜索数据的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#不断在表中插入数据时-物理存储是如何进行页分裂的" class="sidebar-link">不断在表中插入数据时，物理存储是如何进行页分裂的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#基于主键的索引是如何设计的" class="sidebar-link">基于主键的索引是如何设计的</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#索引的页存储物理结构-是如何用b-树来实现的" class="sidebar-link">索引的页存储物理结构，是如何用B+树来实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#更新数据的时候-自动维护的聚簇索引到底是什么" class="sidebar-link">更新数据的时候，自动维护的聚簇索引到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#主键之外的字段建立的二级索引-又是如何运作的" class="sidebar-link">主键之外的字段建立的二级索引，又是如何运作的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#插入数据时到底是如何维护好不同索引的b-树的" class="sidebar-link">插入数据时到底是如何维护好不同索引的B+树的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#一个表里是不是索引搞的越多越好" class="sidebar-link">一个表里是不是索引搞的越多越好？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#通过一步一图来深入理解联合索引查询原理以及全值匹配规则" class="sidebar-link">通过一步一图来深入理解联合索引查询原理以及全值匹配规则</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#最常见和最基本的索引使用规则" class="sidebar-link">最常见和最基本的索引使用规则</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#当我们在sql里进行排序的时候-如何才能使用索引" class="sidebar-link">当我们在SQL里进行排序的时候，如何才能使用索引？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#在sql里进行分组的时候-如何才能使用索引" class="sidebar-link">在SQL里进行分组的时候，如何才能使用索引？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#回表查询对性能的损害以及覆盖索引是什么" class="sidebar-link">回表查询对性能的损害以及覆盖索引是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#设计索引的时候-我们一般要考虑哪些因素呢" class="sidebar-link">设计索引的时候，我们一般要考虑哪些因素呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#案例实战-陌生人社交app的mysql索引设计实战" class="sidebar-link">案例实战：陌生人社交APP的MySQL索引设计实战</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#sql语句的执行计划和性能优化有什么关系" class="sidebar-link">SQL语句的执行计划和性能优化有什么关系</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#以mysql单表查询来举例-看看执行计划包含哪些内容" class="sidebar-link">以MySQL单表查询来举例，看看执行计划包含哪些内容</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#深入探索多表关联的sql语句到底是如何执行的" class="sidebar-link">深入探索多表关联的SQL语句到底是如何执行的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql是如何根据成本优化选择执行计划的" class="sidebar-link">MySQL是如何根据成本优化选择执行计划的？</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JAVA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/thread.html" class="sidebar-link">多线程知识</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql章节2"><a href="#mysql章节2" class="header-anchor">#</a> MySQL章节2</h1> <h2 id="mysql最牛的rr隔离级别-是如何基于readview机制实现的"><a href="#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="header-anchor">#</a> MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</h2> <h3 id="rr级别下如何解决不可重复读问题的"><a href="#rr级别下如何解决不可重复读问题的" class="header-anchor">#</a> RR级别下如何解决不可重复读问题的</h3> <p>RR(可重复读)级别下，你这个事务读取一条数据，无论读多少次，都是一个值，别的事务哪怕修改数据之后提交了事务，你也是看不到人家修改的值的。这就避免了不可重复读的问题。别的事务插入一条数据，你也是看不到的，这就避免了幻读的问题。</p> <p>那到底是如何实现的呢？<br> <strong>核心地方在于RR隔离级别下，每次查询都是同一个ReadView</strong>
首先，我们还是假设数据库里有一条数据，这个数据是事务id=50的插入的。此时有事务A（id=60）和事务B（id=70）在同时运行，如下图所示：
<img src="/docs/assets/img/repeatable_committed1.d7e3decb.png" alt="可重复读与ReadView" title="repeatable_committed1.png"></p> <p>接着事务A发起了一次查询，因为是第一次查询，所以生成了ReadView，此时min_trx_id=60，max_trx_id=71,creator_trx_id=60,m_ids=[60,70],此时如下图：
<img src="/docs/assets/img/repeatable_committed2.91d36dfa.png" alt="可重复读与ReadView" title="repeatable_committed2.png"></p> <p>这个时候事务A基于这个ReadView去查询数据，此时trx_id=50，是小于min_trx_id=60，说它发起事务之前就已经有事务修改了数据并提交了事务，所以可以查到这条数据的原始值。如下图所示：
<img src="/docs/assets/img/repeatable_committed3.f04afef5.png" alt="可重复读与ReadView" title="repeatable_committed3.png"></p> <p>接着事务B就更新了这行数据的值为B，此时会把trx_id修改为70，同时会生成undo log，关键是事务B提交了，也就是说此时事务B已经结束了，如下图：
<img src="/docs/assets/img/repeatable_committed4.8e5343ba.png" alt="可重复读与ReadView" title="repeatable_committed4.png"></p> <p>这个时候大家思考一个问题，ReadView中的m_ids还是[60,70]吗？</p> <p>那必然是的，因为ReadView一旦生成了就不会改变了，这个时候事务B虽然已经结束了，但是事务A的ReadView里m_ids还是[60,70]。<br>
它的意思是事务A开启的时候，事务B当时是在运行的。</p> <p>那么此时事务A去查询这条数据的值，他会惊讶的发现此时数据的trx_id=70,70在min_trx_id和max_trx_id之间，同时还在m_ids=[60,70]列表中。<br>
这说明事务A开启查询的时候，id=70的事务B还是在运行的，然后事务B更新了这条数据，所以此时事务A是不能查询到事务B更新的值，因此此时会顺着undo log版本链条往下找，如下图所示：
<img src="/docs/assets/img/repeatable_committed5.dc738b79.png" alt="可重复读与ReadView" title="repeatable_committed5.png"><br>
事务A顺着roll_pointer找最近的undo log，发现最近的undo log的trx_id=50,它是小于min_trx_id=60的，说明它是在事务A开启之前就已经提交这个事务了，所以事务A是可以查询到这个值的，此时事务A查到的是原始值。<br> <img src="/docs/assets/img/repeatable_committed6.2caa39b4.png" alt="可重复读与ReadView" title="repeatable_committed6.png"></p> <p>可以看到两次查询查到的结果是一样的，都是原始值。不管别的事务如何修改数据，事务A的ReadView始终是不变的，基于这个ReadView看到的值始终是一样的。</p> <h3 id="rr级别下如何解决幻读问题的"><a href="#rr级别下如何解决幻读问题的" class="header-anchor">#</a> RR级别下如何解决幻读问题的</h3> <p><img src="/docs/assets/img/repeatable_committed7.244d09a1.png" alt="可重复读与ReadView" title="repeatable_committed7.png"><br> <img src="/docs/assets/img/repeatable_committed8.3e7049dd.png" alt="可重复读与ReadView" title="repeatable_committed8.png"></p> <p>MVCC是Multi-Version concurrent control,就是多版本并发控制机制。专门控制多个事务并发运行的时候，互相之间会如何影响。<br>
MySQL实现MVCC机制的时候，是基于<strong>undo log多版本链条+ReadView</strong>机制来做的，默认的RR隔离级别就是基于这套机制实现的。</p> <h2 id="多个事务更新同一行数据时-是如何加锁避免脏写的"><a href="#多个事务更新同一行数据时-是如何加锁避免脏写的" class="header-anchor">#</a> 多个事务更新同一行数据时，是如何加锁避免脏写的？</h2> <p>靠锁机制，依靠锁机制让多个事务更新同一行数据的时候串行化，避免同时更新一条数据。</p> <p>假设MySQL里有一行数据，此时来了一个事务要更新它，更新之前需要先检查这行数据有没有锁，如果没有锁，这个事务就会创建一个锁，里面包含了自己的trx_id和等待状态，然后把锁跟这行数据关联在一起。</p> <p><img src="/docs/assets/img/synchronized1.4d94aafe.png" alt="加锁避免脏写" title="synchronized1.png"></p> <p><strong>注意看上图，因为事务A已经给那行数据加了锁，所以此时就可以说那行数据已经被加锁了。</strong><br> <strong>此时另外一个事务B过来了，它也想更新那行数据，更新前先检查这行数据有没有锁，如果已经有锁，B也给这行数据加个锁，然后排队等着。这个时候事务B也生成了一个锁数据结构，里面有它的trx_id和等待状态，但是因为它是排队等待，所以它的等待状态是true</strong>。如下图所示：
<img src="/docs/assets/img/synchronized2.0e179d60.png" alt="加锁避免脏写" title="synchronized2.png"></p> <p>接着事务A更新完数据就把锁给释放了。锁一旦释放了，他就会去找，此时还有没有别人也对这行数据加锁了呢？他就会发现事务B也对该行数据加锁了，于是这个时候，就会把事务B的锁里的等待状态给修改为false，然后唤醒事务B继续执行，此时事务B就获取到锁了，如下图所示：
<img src="/docs/assets/img/synchronized3.2569590d.png" alt="加锁避免脏写" title="synchronized3.png"></p> <h2 id="共享锁和独占锁到底是什么"><a href="#共享锁和独占锁到底是什么" class="header-anchor">#</a> 共享锁和独占锁到底是什么？</h2> <h3 id="独占锁"><a href="#独占锁" class="header-anchor">#</a> 独占锁</h3> <p>前面讲过，多个事务同时更新一行数据，此时都会加锁，然后都会排队等待，必须一个事务执行完了，提交了，释放了锁，才能唤醒别的事务继续执行。<br>
那么多个事务运行时加的是什么类型的锁呢？<br> <strong>其实是X锁，也就是Exclude独占锁</strong>，当有一个事务加了独占锁之后，此时其他事务再要更新这行数据，都是要加独占锁的，但是智能生成独占锁在后面等待。</p> <p>当有人在更新数据的时候，其他的事务可以读取这行数据吗？默认情况下，需要加锁吗？<br>
答案是：不需要。</p> <p>原因：因为默认情况下，有人在更新数据的时候，你要去读取这行数据，直接默认就是开启MVCC机制的。<br>
也就是说此时对一行数据的读和写两个操作，默认是不会加锁互斥的，因为MySQL设计MVCC机制就是为了解决这个问题的，避免频繁加锁互斥。<br> <font color="#0000FF" size="4">查询操作加互斥锁的方法： select * from table for update</font></p> <h3 id="共享锁"><a href="#共享锁" class="header-anchor">#</a> 共享锁</h3> <p>万一执行查询操作时，就是想要加锁呢？<br>
MySQL也是Ok的，他提供了一种共享锁，就是S锁。<br> <font color="#0000FF" size="4">共享锁的语法如下：select * from table lock in share mode   </font><br>
你在一个查询语句后面加上 lock in share mode，就表示查询时对这行数据加了共享锁。</p> <p><font color="FF0000" size="4">如果此时有别的事务在更新这行数据，已经加了独占锁了，此时你的共享锁还能加吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你这个查询就只能等着了。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人再来更新要加独占锁，行吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你的更新只能等待。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人也来加共享锁，行吗？</font><br>
可以，共享锁和共享锁不会互斥。<br> <img src="/docs/assets/img/share_or_exclude_lock.9039512f.png" alt="共享锁和互斥锁关系图" title="share_or_exclude_lock.png"></p> <h2 id="哪些操作会导致在表级别加锁呢"><a href="#哪些操作会导致在表级别加锁呢" class="header-anchor">#</a> 哪些操作会导致在表级别加锁呢？</h2> <p>在多个事务并发更新数据的时候，都是要在行级别加独占锁的，这就是行锁，独占锁都是互斥的，所以不可能发生脏写问题，一个事务提交了才会释放自己的独占锁，唤醒下一个事务执行。</p> <p>如果你此时去读取别的事务在更新的数据，有两种可能：</p> <p>第一种可能是基于mvcc机制进行事务隔离，读取快照版本，这是比较常见的；<br>
第二种可能是查询的同时基于特殊语法去加独占锁或者共享锁。</p> <p>太建议在数据库粒度去通过行锁实现复杂的业务锁机制，而更加建议通过redis、zookeeper来用分布式锁实现复杂业务下的锁机制，其实更为合适一些。</p> <p>为什么呢？因为如果你把分布式系统里的复杂业务的一些锁机制依托数据库查询的时候，在SQL语句里加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的不好维护的，所以一般是不建议这么做的。</p> <p><strong>比较正常的情况而言，其实还是多个事务并发运行更新一条数据，默认加独占锁互斥，同时其他事务读取基于mvcc机制进行快照版本读，实现事务隔离。</strong></p> <p>有些人可能会以为当你执行增删改的时候默认加行锁，然后执行DDL语句的时候，比如alter table之类的语句，会默认在表级别加表锁。这么说也不太正确，但是也有一定的道理，因为确实你执行DDL的时候，会阻塞所有增删改操作；执行增删改的时候，会阻塞DDL操作。</p> <p>但这是通过MySQL通用的<strong>元数据锁实现的，也就是Metadata Locks，但这还不是表锁的概念</strong>。因为<strong>表锁其实是InnoDB存储引擎的概念</strong>，InnoDB存储引擎提供了自己的表级锁，跟这里DDL语句用的元数据锁还不是一个概念。</p> <p>只不过DDL语句和增删改操作，确实是互斥的，大家要知道这一点。</p> <h2 id="表锁和行锁互相之间的关系以及互斥规则是什么呢"><a href="#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="header-anchor">#</a> 表锁和行锁互相之间的关系以及互斥规则是什么呢？</h2> <p>MySQL的表锁其实非常鸡肋的东西，几乎不会有人用。表锁分为两种，一种是表锁，一种是表级的意向锁。</p> <p><font color="#0000FF" size="4">表锁加锁语法：<br>
LOCK TABLES XXX READ  这是加表级共享锁<br>
LOCK TABLES XXX WRITE 这是加表级独占锁<br></font></p> <p><font color="#0000FF" size="4">我们平时操作数据库，两种常见的表锁：<br>
更新时加的意向独占锁<br>
查询时加的意向共享锁  </font><br>
可以当这两种锁是透明的，因为意向独占锁和意向共享锁是不互斥的。<br> <img src="/docs/assets/img/table_lock.d40f61b5.png" alt="表锁" title="table_lock.png"><br> <img src="/docs/assets/img/lock_relation.c432bee4.png" alt="表锁关系" title="lock_relation.png"></p> <h2 id="线上数据库不确定性的性能抖动优化实践"><a href="#线上数据库不确定性的性能抖动优化实践" class="header-anchor">#</a> 线上数据库不确定性的性能抖动优化实践**</h2> <p>大家都知道，我们平时执行更新语句的时候，实际上都是从磁盘加载数据页到数据库内存的缓存页中，接着就直接更新内存里的缓存页，同时更新对应的redo log并写入一个buffer中，如下图所示：
<img src="/docs/assets/img/redo_log1.33a93a02.png" alt="redo log" title="redo_log1.png"></p> <p>既然我们更新了Buffer Pool里的缓存页，缓存页就变成了脏页，之所以说他是脏页，是因为缓存页里的数据目前跟磁盘文件里的数据页的数据是不一致的，所以此时的缓存页也叫作脏页。</p> <p><strong>既然是脏页就必然要有一个合适的时机把脏页给刷回磁盘文件，脏页刷回磁盘是通过LRU链表实现的，通过LRU链表，就可以知道哪些缓存页是最近经常被使用的。</strong></p> <p>如果后续你要加载磁盘里的数据页到Buffer Pool中去，但是此时并没有空闲的缓存页了，此时就必须把部分脏页给刷回磁盘，根据LRU链表找到最近最少被访问的缓存页刷回磁盘。</p> <p><img src="/docs/assets/img/redo_log2.d17eea1b.png" alt="redo log" title="redo_log2.png"></p> <p><font color="#FF0000" size="4">生产案例：假设你执行的查询语句，需要查询大量的数据到缓存页里去，此时可能会导致大量的脏页需要刷回磁盘，才能腾出足够的内存空间来执行这条查询语句。在这种情况下，可能你会发现，突然莫名其妙的执行某个查询语句慢了很多，平时只要几十毫秒的查询，这次花了几秒，因为你要等待大量脏页刷回磁盘，然后语句才能执行</font></p> <p>还有另外一种脏页刷磁盘的契机，我们知道redo log buffer中的redo log本身也会随着各种条件刷入磁盘，比如redo log buffer里的数据超过容量的一定比例了，或者是事务提交的时候，都会强制把buffer里的redo log刷回磁盘。<br>
然后我们也知道，磁盘上是有多个日志文件的，他会不停的写，如果所有的日志文件都写满了，他会回到第一个日志文件再次写入，这些日志文件是不停的循环写入的。所以<font color="#FF0000" size="4">其实在日志文件都被写满的情况下，也会触发一次脏页刷新。</font></p> <p>主要原因是假如第一个日志文件的redo log对应的缓存页的数据一直没有被刷入磁盘，一旦你往里面写入了别的日志，此时万一数据库崩溃，你之前更新过的数据是不是就丢失了？<br> <font color="#0000FF" size="4">所以一旦你把所有的日志文件都写满了，重新开始从第一个日志文件开始写的时候，他会判断一下，如果是你第一个日志文件里的一些redo log对应的缓存页，迄今为止都没有刷入磁盘，那么此时必然要把那些马上要被覆盖的redo log更新的缓存页都刷入到磁盘</font>，如下图所示：<br> <img src="/docs/assets/img/redo_log_flush_disk.e9b123b3.png" alt="redo log刷入磁盘的特殊时机" title="redo_log_flush_disk.png"></p> <p><strong>尤其是在这种刷脏页的情况下，因为redo log所有日志文件都写满了，此时会导致数据库直接hang死，无法处理任何更新请求，因为执行任何一个更新请求都必须要写redo log，此时你需要刷新一些脏页到磁盘，然后才能继续执行更新语句，把更新语句生成的redo log从第一个日志文件开始覆盖写入</strong>。</p> <p>综上所述：到线上数据库的查询和更新语句莫名其妙出现性能抖动，很有可能就是上述两种情况导致的大量脏页刷入磁盘，你要等刷入磁盘后，才能继续执行。<br> <img src="/docs/assets/img/redo_log_flush_disk2.ca42aeb5.png" alt="redo log刷入磁盘的特殊时机" title="redo_log_flush_disk2.png"></p> <h2 id="上述问题导致数据库性能抖动的优化方案"><a href="#上述问题导致数据库性能抖动的优化方案" class="header-anchor">#</a> 上述问题导致数据库性能抖动的优化方案</h2> <p>上述两个场景导致大量的缓存页flush到磁盘，就会导致莫名其妙的出现SQL语句性能抖动了。<br>
优化的核心思路就两个：<br>
第一种：减少刷磁盘的频率<br>
第二种：加快刷入磁盘的速度<br>
第一种方案可以抛弃，因为你的缓存页正常被使用时，总有被填满的时候，我们没法控制，一旦缓存页被填满就会导致大量缓存页flush到磁盘。除非你给机器加大内存，给buffer pool分配的空间大一些。<br> <font color="#FF0000" size="4">第二种方案的关键是尽可能减少flush缓存页到磁盘的时间。建议可以采用SSD固态硬盘，然后设置一个参数，innodb_io_capacity,这个参数就是告诉数据库采用多大的IO速率把缓存页flush到磁盘里去。</font></p> <p><strong>fio是linux上一种用于测试磁盘最大随机io速率的工具</strong>。</p> <p><font color="#0000FF" size="4">实际在刷入磁盘的时候，它会根据innodb_io_capacity乘以一个百分比进行刷磁盘，这个百分比就是脏页的比例，是由innodb_max_dirty_pct参数控制的，默认是75%，这个参数一般不用动。</font></p> <p><font color="#FF0000" size="4">还有一个参数：innodb_flush_neighbors,它的意思是flush缓存页到磁盘的时候可能会把缓存页临近的其他缓存页也刷入磁盘。可以把这个参数值设置为0，禁止刷临近缓存页到磁盘。</font></p> <h2 id="磁盘数据页的存储结构"><a href="#磁盘数据页的存储结构" class="header-anchor">#</a> 磁盘数据页的存储结构</h2> <h3 id="数据库的索引原理及查询原理"><a href="#数据库的索引原理及查询原理" class="header-anchor">#</a> 数据库的索引原理及查询原理</h3> <p>数据库最终所有的数据（包括我们建的各种表以及表里的数据）都是要存放在磁盘上的文件里的，然后在文件里存储的数据格式就是数据页，那么大量的数据页在磁盘文件里是怎么存储的呢？<br>
首先要明白一点，大量的数据页是按照顺序一页一页存放的，然后相邻数据页之间会采用双向链表的格式相互引用，如下图：
<img src="/docs/assets/img/data_page_list.eb2667d1.png" alt="文件中数据页存放规则" title="data_page_list.png"></p> <p>其实一个数据页在磁盘里就是一段数据，数据页里包含两个指针，一个指向自己上一个数据页的物理地址，一个指针指向自己下一个数据页的物理地址，大概可以认为类似下面这样：<br> <img src="/docs/assets/img/data_page_list2.c8e6c3f2.png" alt="文件中数据页存放规则" title="data_page_list2.png"><br>
每个数据页里可以认为就是DataPage开头一直到||符号之间的一段连续的数据，可以认为就是数据页。<br>
然后数据页内部会存储一行一行的数据，也就是平时我们在表里插入的一行一行的数据就会存储在数据页里，然后数据页里每行数据都会按照主键大小进行排序存储，同时每行数据都有一个指针指向下一行数据的位置，组成单项链表，如下图：
<img src="/docs/assets/img/data_page_list3.abe9cb7c.png" alt="文件中数据页存放规则" title="data_page_list3.png"></p> <h2 id="数据库是如何根据查询语句搜索数据的"><a href="#数据库是如何根据查询语句搜索数据的" class="header-anchor">#</a> 数据库是如何根据查询语句搜索数据的？</h2> <p>没有索引的情况下，数据库是如何根据查询语句搜索数据的？<br> <font color="#FF0000" size="4">我们应该知道数据页之间是组成双向链表的，然后数据页内部的数据行是组成单向链表的，而且数据行是根据主键从小到大排序的。</font><br>
然后每个<strong>数据页里都会有一个页目录，里面存的是主键跟所在槽位的映射关系，如下图所示</strong>：<br> <img src="/docs/assets/img/data_page_list4.6dbd717a.png" alt="文件中数据页存放规则" title="data_page_list4.png"></p> <p>假设你要根据主键查找一条数据，并且假设这个表里没有几条数据，只存了一个数据页。首先会到数据页的页目录里根据主键进行二分查找，找到主键对应的数据在哪个槽位里，然后到那个槽位里去，遍历槽里的每一行数据，就能快速找到那个主键对应的数据了。</p> <p><strong>每个槽位里都有一组数据行</strong>。</p> <p>假设根据非主键查找呢？<br>
那就尴尬了，此时你没法使用主键的那种二分查找方式，只能进入到数据页里，根据单向链表依次遍历查找数据了，这样的性能就很差了。</p> <p>下面来说说有很多数据页的情况：<br>
假设你没有建立任何索引，那么无论你根据主键查询还是根据其他字段为条件查询，都没有什么取巧的办法。<br>
因为表里的所有数据页都是组成双向链表的，查找的时候，要先把第一个数据页给加载到Buffer Pool的缓存页中，然后如果你是根据主键查找的话，就在数据页内使用二分查找的方式；如果是根据非主键查询的话，就只能根据数据行的单向链表来遍历查找，如下图：<br> <img src="/docs/assets/img/data_page_list5.abfe1fa7.png" alt="文件中数据页存放规则" title="data_page_list5.png"><br>
假设第一个数据页没有找到你要的数据，怎么办呢？<br>
没办法，只能根据数据页组成的双向链表，找到下一个数据页，然后加载到Buffer Pool的缓存页里去，然后按照上述的方法在缓存页查找数据。<br>
如果还是查不到呢？<br>
那就只能根据双向链表加载下一个数据页到Buffer Pool的缓存页里去，依次类推，循环往复。</p> <p>其实上面的过程就是<strong>全表扫描</strong>。</p> <h2 id="不断在表中插入数据时-物理存储是如何进行页分裂的"><a href="#不断在表中插入数据时-物理存储是如何进行页分裂的" class="header-anchor">#</a> 不断在表中插入数据时，物理存储是如何进行页分裂的？</h2> <p>往表里不断插入 数据时，会涉及到一个<font color="#FF0000" size="4">页分裂的过程</font>，也就是说，表里是如何出现一个又一个的数据页的。</p> <p>数据页内部的数据行会组成一个单向链表，如下图所示：<br> <img src="/docs/assets/img/data_page_list6.69e4fbc5.png" alt="文件中数据页存放规则" title="data_page_list6.png"><br>
上图中是一行一行的数据，刚开始<font color="#FF0000" size="4">第一行是起始行，它的行类型是2，是最小的一行</font>，然后它有一个指针指向了下一行数据，每一行数据都存字段的值，然后每一行通过指针指向下一行数据，<font color="#FF0000" size="4">普通数据行的类型都是0，最后一行 的行类型是3，代表最大的一行。</font></p> <p>假设你不断的往表里插入数据，如果第一个数据页满了，那么就需要在搞一个数据页，如下图：<br> <img src="/docs/assets/img/data_page_list7.ee1df72a.png" alt="文件中数据页存放规则" title="data_page_list7.png"><br>
但是此时会遇到一个问题，后续我们会讲到索引的机制，<font color="#FF0000" size="4">索引运作的一个核心基础就是要求你后一个数据页里的主键值都必须大于前一个数据页里的主键值。</font></p> <p>如果你的主键是自增的，还可以 保证这一点；但是如果你的主键不是自增长的，可能会出现后一个数据页里的主键值，有的小于前一个数据页里的主键值。</p> <p>所以此时会出现一个过程，叫<strong>页分裂</strong>，就是万一你的主键值都是你自己设置的，那么在增加一个新的数据页的时候，可能会把前一个数据页里主键值较大的挪到后一个数据页里去，然后把你插入的较小的数据挪到上一个数据页里去，保证新数据页里的主键值都比上一个数据页里的主键值大。<br> <img src="/docs/assets/img/data_page_list8.fa12e30a.png" alt="文件中数据页存放规则" title="data_page_list8.png"><br>
如上图所示，第一个数据页里有1，5,6三条数据，第二个数据页里有，2,3,4三条数据，明显第二个数据页里的主键值比第一个数据页里的主键值要小，这是不允许的。<br>
此时会出现页分裂的过程，把新数据页的两条数据挪到上一个数据页，上一个数据页挪两条数据到新数据页中去，如下图：<br> <img src="/docs/assets/img/data_page_list9.1994787d.png" alt="文件中数据页存放规则" title="data_page_list9.png"></p> <p>有了页分裂这个过程，保证了每个数据页里的主键值的规则，就能为后续的索引打下基础。</p> <h2 id="基于主键的索引是如何设计的"><a href="#基于主键的索引是如何设计的" class="header-anchor">#</a> 基于主键的索引是如何设计的</h2> <p>假设我们有多个数据页，我们想根据主键来查询数据，那么直接查询也是不行的，因为我们不知道主键到底在哪里？<br> <img src="/docs/assets/img/data_page_list10.b26d1517.png" alt="文件中数据页存放规则" title="data_page_list10.png"><br>
比如上图，你想查找id=4的数据，你怎么知道在哪个数据页里？<br>
所以假设是这个样子的话，你还是只能走全表扫描了。<br>
所以此时就需要针对主键设计一个索引了，针对主键的索引其实就是<font color="#FF0000" size="4">主键目录，就是把每个数据页的页号，还有数据页里最小的主键值放在一起，组成一个索引目录。</font> 如下图所示：<br> <img src="/docs/assets/img/data_page_list11.6f8d69dd.png" alt="文件中数据页存放规则" title="data_page_list11.png"><br>
现在有了上图的主键目录就方便了，可以直接到主键目录去搜索，比如你要找id=3的数据，此时就会根据每个数据页的最小主键来比，首先id=3大于了数据页2里的最小主键值1，接着小于了数据页8里的最小主键值4。</p> <p>所以既然如此，你直接就可以定位到id=3的数据一定是在数据页2里的！</p> <p><strong>使用二分查找查找数据页：假设你有很多的数据页，在主键目录里就会有很多的数据页和最小主键值，此时你完全可以根据二分查找的方式来找你要找的id到底在哪个数据页里</strong>！</p> <p>所以这个效率是非常之高的，而类似上图的主键目录，就可以认为是主键索引。</p> <p>而大家都知道我们的数据页都是一坨一坨的连续数据放在很多磁盘文件里的，所以只要你能够根据主键索引定位到数据所在的数据页，此时假设我们有别的方式存储了数据页跟磁盘文件的对应关系，此时你就可以找到一个磁盘文件。</p> <p>而且我们假设<strong>数据页在磁盘文件里的位置也就是offset偏移量</strong>，你也是可以知道的，此时就可以直接通过随机读的方式定位到磁盘文件的某个offset偏移量的位置，然后就可以读取连续的 一大坨数据页了！</p> <h2 id="索引的页存储物理结构-是如何用b-树来实现的"><a href="#索引的页存储物理结构-是如何用b-树来实现的" class="header-anchor">#</a> 索引的页存储物理结构，是如何用B+树来实现的？</h2> <p>只要在一个主键索引里包含每个数据页跟它的最小主键值，就可以组成一个索引目录，然后后续你根据主键值查找，就可以在索引目录里二分查找直接定位到那条数据所在的数据页，接着到数据页里二分查找定位那条数据就可以了，如下图：<br> <img src="/docs/assets/img/data_page_list11.6f8d69dd.png" alt="文件中数据页存放规则" title="data_page_list11.png"><br>
但是现在问题来了，假设你的数据很多很多，有上千万的数据，甚至单表几亿数据都是有可能的，此时可能会有大量的数据页，然后你的索引目录里就要存储大量的数据页和最小主键值，这也是有问题的。</p> <p>所以在考虑这个问题的时候，实际上是采取了一种把索引数据存储在数据页里的方式来做的。<br>
也就是说，表数据是存在数据页里，然后表的索引其实也是存在数据页里的，索引放到页里之后，就会有索引页，假设你有很多很多的数据页，那么此时你就会有很多的索引页，如下图所示：<br> <img src="/docs/assets/img/data_page_list12.5398c2a4.png" alt="文件中数据页存放规则" title="data_page_list12.png"><br>
但是现在又有问题了，因为你有太多的索引页，因为你需要知道，应该在哪个索引页里去找你的主键数据，这也是个大问题？</p> <p>于是接下来我们把索引页多加一个层级出来，在更高的索引层级里，保存了每个索引页和索引页里的最小主键值，如下图所示：<br> <img src="/docs/assets/img/data_page_list13.5d335786.png" alt="文件中数据页存放规则" title="data_page_list13.png"></p> <p>现在就好了，假设我们要查询id=46的，直接先到最顶层的索引页35里面去找，直接通过二分查找就可以定位到下一步应该到索引页20（里面存了数据页的页号和最小主键值）里面去找，接下来在索引页20里二分查找，可以定位到数据应该在数据页8里，在进入数据页8里，就可以找到id=46的那行数据了。</p> <p>那么问题又来了，假设最顶层的索引页里存放的下层索引页的页号也非常多，怎么办呢？<br>
此时可以再次分裂，再加一层索引页，比如下图：<br> <img src="/docs/assets/img/data_page_list14.08a5fe72.png" alt="文件中数据页存放规则" title="data_page_list14.png"></p> <p>上图想不想一棵树？<br>
没错，这就是一棵<strong>B+树</strong>，MySQL的索引就是用B+树实现的。<br>
这就是索引最真实的物理存储结构，采用跟数据页一样的数据结构来存储，一个索引就是很多数据页组成的B+树。</p> <h2 id="更新数据的时候-自动维护的聚簇索引到底是什么"><a href="#更新数据的时候-自动维护的聚簇索引到底是什么" class="header-anchor">#</a> 更新数据的时候，自动维护的聚簇索引到底是什么？</h2> <p><strong>聚簇索引：如果一颗大的B+树索引数据结构里，叶子节点就是数据页本身，那么我们可以称这个B+树索引为聚簇索引</strong>。<br>
在innoDB的存储引擎里，对数据增删改的时候，就是直接把你的数据页放在聚簇索引里的。比如你插入数据就是在数据页里插入数据。<br>
如果你的数据页开始分裂了，此时会自动调整数据页内部的行数据，保证数据页内的主键值都是有顺序的，下一个数据页里的主键值大于上一个数据页里的所有主键值。<br>
一般索引页里可以放很多索引条目，<strong>即使你是亿级的大表，所建的索引的层级也就三四层而已</strong>。</p> <h2 id="主键之外的字段建立的二级索引-又是如何运作的"><a href="#主键之外的字段建立的二级索引-又是如何运作的" class="header-anchor">#</a> 主键之外的字段建立的二级索引，又是如何运作的？</h2> <p>主键外的其它字段建立索引的原理：<br>
假设你要基于其他字段建立索引，比如name，age之类的字段，都是同一个原理。比如你插入数据的时候，一方面会把完整数据插入到聚簇索引的叶子结点的数据页里去，同时维护好聚簇索引，另一方面，会为其他字段建立的索引，再建立一棵B+树。<br>
比如你以name字段建立一个索引，那么此时你插入数据的时候，就会从新搞一个B+树，B+树的叶子节点也是数据页，但是这个数据页里仅仅存放主键字段和name字段，如下图：<br> <img src="/docs/assets/img/data_page_list15.5023eacd.png" alt="文件中数据页存放规则" title="data_page_list15.png"><br>
聚簇索引和name字段的B+树是相互独立的两棵树。<br>
name字段的B+树里，<strong>叶子节点的数据页中name的值都是按照大小排序的，同时下一个数据页里的name字段值都大于上一个数据页里的name字段值</strong>，这个整体的排序规则跟聚簇索引里按照主键的排序规则是一样的。<br> <img src="/docs/assets/img/data_page_list16.80a0036d.png" alt="文件中数据页存放规则" title="data_page_list16.png"></p> <p><font color="#FF0000" size="4">根据name字段搜索数据的过程：</font>从name字段的B+树的根节点开始找，一层层往下找，一直找到叶子节点的数据页里，定位到name字段对应的主键值。<br>
此时针对select * from table where name='xxx'这样的语句，你先根据name字段在name字段的B+树索引找，找到叶子节点，也仅仅是能找到对应的主键值，而找不到这行完整的数据。<br>
所以此时需要<strong>回表</strong>，就是说还需要根据主键值，再到聚簇索引里从根节点开始，一路找到叶子节点的数据页，定位到主键对应的完整数据行，此时才能把select *对应的所有字段值拿出来。</p> <p>因为我们根据name字段的索引B+树找到主键后，还需要根据主键去聚簇索引里找，所以一般name字段这种普通字段的索引称为<strong>二级索引</strong>，把聚簇索引称为<strong>一级索引</strong>，这就是普通字段的索引的运行原理。</p> <p>多个字段建立联合索引，比如name+age<br>
联合索引的运行原理也是一样的，只不过在这颗独立的B+树索引里，叶子节点的数据页存放的是id+name+age，然后默认按照name排序，name一样就按照age排序，不同的数据页之间的name+age值的排序也是如此。<br>
然后这个name+age的联合索引的B+树索引页里，放的是下层节点的页号和最小的name+age的值，以此类推，当你根据name+age搜索的时候，就会走name+age联合索引的这棵B+树了，搜索到了主键后，再根据主键到聚簇索引里去搜索。</p> <h2 id="插入数据时到底是如何维护好不同索引的b-树的"><a href="#插入数据时到底是如何维护好不同索引的b-树的" class="header-anchor">#</a> 插入数据时到底是如何维护好不同索引的B+树的？</h2> <p>插入数据时是如何维护不同索引的B+树的？<br>
首先，表刚建的时候，它就是一个数据页，这个数据页属于聚簇索引的一部分，而且目前还是空的。<br>
此时如果你插入数据，就是直接在这个数据页里插入就可以了，也没必要给它弄索引页，如下图：<br> <img src="/docs/assets/img/page_index1.02c27ac1.png" alt="索引页结构" title="page_index1.png"></p> <p>这个初始的数据页其实就是根页，每个数据页内部默认就有一个基于主键的页目录，所以此时你根据主键来搜索都是没问题的，直接在唯一一个数据页里</p> <p>当表里的数据越来越多的时候，如果第一个数据页满了，会再弄一个数据页，根据主键值的大小进行移动，让两个数据页的数据根据主键值排序，并且保证第二个数据页的主键值都大于第一个数据页里的主键值，如下图:<br> <img src="/docs/assets/img/page_index2.67e5c4e4.png" alt="索引页结构" title="page_index2.png"></p> <p>那么此时根页在哪呢？<br>
此时根页就升级为索引页了，这个根页里存放的就是两个数据页的页号和他们里面的最小主键值，所以此时看起来如下图：<br> <img src="/docs/assets/img/page_index3.83743862.png" alt="索引页结构" title="page_index3.png"></p> <p>接着你肯定会不停的往表里插入数据，然后数据页不停的进行页分裂，分裂出越来越多的数据页。<br>
此时你唯一的一个索引页，也就是根页里存放的数据页索引条目越来越多，连你的索引页都放不下了，那你就让一个索引页分裂为两个索引页，然后根页继续往上走一个层级引用两个索引页。如下图：<br> <img src="/docs/assets/img/page_index4.a39b0b81.png" alt="索引页结构" title="page_index4.png"><br>
接着就是以此类推了，你的数据页越来越多，那么根页指向的索引页也不停的分裂，分裂出更多的索引页，当你下层的索引页数量太多的时候，会导致你的根页指向的索引页太多了，此时根页继续分裂为多个索引页，根页再次往上提上去一个层级。<br>
这其实就是增删改时，整个聚簇索引维护的一个过程，其实其他二级索引也是类似的一个原理。<br> <img src="/docs/assets/img/page_index5.5d283ba6.png" alt="索引页结构" title="page_index5.png"></p> <h2 id="一个表里是不是索引搞的越多越好"><a href="#一个表里是不是索引搞的越多越好" class="header-anchor">#</a> 一个表里是不是索引搞的越多越好？</h2> <p>那就大错特错了。<br> <font color="#FF0000" size="4">B+树的特性：那就是数据页/索引页里的记录组成一个单向链表，而且是按照数据大小有序排列的；然后数据页/索引页之间组成双向链表，而且也是按照数据大小有序排列的，所以B+树索引是一个完全有序的数据结构，无论是页内还是页之间。</font><br> <strong>索引的缺点：</strong> 一个是空间上，一个是时间上。<br>
空间上，如果你给很多字段创建索引，那么就会创建很多棵B+树，每一颗B+树都要占用很多的磁盘空间。<br>
时间上，你要是搞了很多索引，那么在你进行增删改的时候，每次都需要维护各个索引的数据的有序性。<br>
所以你不停的增删改，必然会导致各个数据页之间的值可能会没有顺序，比如数据页里插入了一个比较小的值，居然比上一个数据页的值还要小！此时就没有办法了，只能进行数据页的挪动，维护页之间的顺序。</p> <p>或者是你不停的插入，数据页不停的分裂，不停的增加新的索引页，这个过程也是耗费时间的。</p> <h2 id="通过一步一图来深入理解联合索引查询原理以及全值匹配规则"><a href="#通过一步一图来深入理解联合索引查询原理以及全值匹配规则" class="header-anchor">#</a> 通过一步一图来深入理解联合索引查询原理以及全值匹配规则</h2> <p>我们设计系统的时候<strong>一般是设计联合索引，原因是尽可能让索引数量小一些，避免磁盘占用太多，增删改性能太差</strong>。</p> <p>假设我们有一个学生成绩表，这个表有个id字段，是自增长的主键，默认就会基于它做一个聚簇索引。<br>
成绩表包含学生班级、学生姓名、科目名称、分数四个字段，平时可能查的最多的就是找某个班的某个学生某科的成绩。<br>
所以我们基于班级、学生姓名和科目名称建立一个联合索引。<br> <img src="/docs/assets/img/union_index1.1bc4b9e3.png" alt="联合索引结构图" title="union_index1.png"></p> <p>图中有两个数据页，第一个数据页有3条数据，每条数据都包含了联合索引的3个字段值和主键值，数据页内部是按照顺序排序的。<br>
首先按照班级字段的值来排序，如果一样则按照学生姓名排序，如果还一样，则按照科目名称来排序，所以数据页内部是按照三个字段的值来排序的，而且还组成了单向链表。</p> <p>然后数据页之间也是有顺序的，第二个数据页里的三个字段的值一定都大于上一个数据页里三个字段的值，比较方法也是按照班级名称、学生名称、科目名称依次来比较的，数据页之间组成双向链表。</p> <p>索引页里就两条数据，分别指向两个数据页，索引里存放的是数据页里最小的那个数据的值。</p> <p>索引页内部的数据页组成单向链表并且是有序的，如果你有多个索引页，那么索引页之间也是有序的，组成了双向链表。</p> <p>假设我们想搜索：一班+张小强+数学的成绩，此时可能会写类似下面的sql，select * from student_score where class_name='一班' and student_name='张小强' and subject_name='数学'。<br>
此时就涉及到了一个索引的使用规则，那就是你发起的sql语句里，where条件里几个字段都是基于等值来查询，都是用的等于号。而且where条件里的几个字段的名称和顺序也跟你联合索引里一模一样。此时就是<font color="#FF0000" size="4">等值匹配规则</font>，上面的sql语句是百分之百可以使用联合索引来查询。</p> <p>查询的过程：首先到索引页里去找，因为索引页里有多个数据页的最小值记录，此时直接在索引页里基于二分查找就可以了。先根据班级名称来找1班这个值对应的数据页，直接可以定位到他所在的数据页，如下图：<br> <img src="/docs/assets/img/page_index6.a02618c5.png" alt="联合索引结构图" title="page_index6.png"><br>
然后你直接找到索引页中索引指向的数据页，数据页内部是单向链表，你也是根据二分查找来找，先按1班这个值来找，你会发现几条数据都是1班，然后可以按照张小强这个姓名来二分查找，此时你会发现多条数据是张小强，最后按照科目名称进行二分查找。很快就可以定位到下图中的一条数据，1班的张小强的数学成绩对应的主键id=127，如下图所示：<br> <img src="/docs/assets/img/page_index7.ed0e2f2c.png" alt="联合索引结构图" title="page_index7.png"><br>
然后根据主键id=127到聚簇索引里按照一样的思路，从索引根节点开始二分查找迅速定位到下层的索引页，在不停的找，很快就可以找到id=127那条数据，然后从里面提取所有的字段，包括分数就可以了。</p> <h2 id="最常见和最基本的索引使用规则"><a href="#最常见和最基本的索引使用规则" class="header-anchor">#</a> 最常见和最基本的索引使用规则</h2> <p><strong>如果你使用了联合索引的所有字段了，但是顺序和联合索引中字段的顺序有差异，也没关系，MySQL自动优化为按联合索引的字段顺序去找</strong>。<br>
第二个规则，就是<font color="#FF0000" size="4">最左侧列匹配</font>，意思是假设我们的联合索引是KEY(class_name,student_name,subject_name),那么不一定必须要在where语句里根据三个字段来查，其实只要根据最左侧的部分字段来查，也是可以的。</p> <p>比如你的sql如下：select * from student_score where class_name='' and student_name=''，就是查某个班级某个学生的所有科目的成绩是ok的。</p> <p>假设你的sql是：select * from student_score where subject_name=''，这样是不行的，<strong>因为联合索引的B+树里，是必须先按照class_name查，再按student_name查，不能跳过前面两个字段，直接按最后一个字段subject_name来查</strong>。</p> <p>假设你的sql是：select * from student_score where class_name='' and subject_name=''，那么只有class_name可以在索引里搜索，剩下的subject_name是没法在索引里搜索的，道理同上。</p> <p><strong>所以在建立索引的过程中，必须考虑好联合字段索引的顺序，以及平时写sql的时候要按照哪几个字段来查</strong>。</p> <p>第三个规则，<font color="#FF0000" size="4">最左前缀匹配原则（模糊符号必须在右侧）</font>，即如果你要按照like语法来查，比如select * from student_score where class_name like '1%',查找所有1开头的班级的分数，这也是可以用到索引的。</p> <p>但是如果你写class_name like '%班级'，在左侧用一个模糊匹配符，那就没法使用索引了，因为不知道你最左前缀是什么，怎么去索引里找？</p> <p>第四个规则，就是<font color="#FF0000" size="4">范围查找规则</font>，意思是说我们可以使用select * from student_score where class_name &gt;'1班' and class_name&lt;'5班' 这样的语句范围内查找几个班级的分数，这个时候也是走索引的。</p> <p>因为我们的索引的最下层的数据页都是按照顺序组成双向链表的，所以完全可以先找到‘1班’对应的数据页，再找到‘5班’对应的数据页，两个数据页中间的那些数据页，就全都是在你范围内的数据了！</p> <p>但是如果你要写select * from student_score where class_name &gt;'1班' and class_name&lt;'5班' and studeng_name&gt;'xxx'，这里只有class_name是可以基于索引来找，student_name的范围查询是没法用到索引的！</p> <p><font color="#FF0000" size="4">这也是一条规则，就是你的where语句里有范围查询，那只有对联合索引里最左侧的列进行范围查询才会走索引。</font></p> <p>第五个规则，<font color="#FF0000" size="4">等值匹配+范围匹配的规则</font>，如果你要用select * from student_score where class_name ='1班' and student_name&gt;'' and subject_name&lt;'',那么你首先可以根据class_name在索引里精确定位到一波数据，接着这波数据里的student_name都是按照顺序排列的，所以student_name&gt;''也会基于索引来找，但是接下来的subject_name是不能用索引的。</p> <h2 id="当我们在sql里进行排序的时候-如何才能使用索引"><a href="#当我们在sql里进行排序的时候-如何才能使用索引" class="header-anchor">#</a> 当我们在SQL里进行排序的时候，如何才能使用索引？</h2> <p>假设我们建立了一个INDEX(xx1,xx2,xx3)这样的一个联合索引，这个时候默认情况下，索引树里本身就是依次按照xx1，xx2、xx3三个字段的值进行排序的，那么此时你在运行select * from table order by xx1,xx2,xx3 limit 100这样的语句，你觉得还需要再进行排序吗？</p> <p>显然是不用了。直接按照索引树里的顺序把xx1，xx2，xx3三个字段按照从小到大的值获取前面100条就可以了。<br>
然后拿到100条数据的主键，再去聚簇索引里回表查询剩余的所有字段。</p> <p><font color="#0000FF" size="4">所以说，在你的sql语句里，应该尽量按照联合索引的字段顺序进行order by排序，这样就可以直接利用联合索引里数据的有序性，到索引树里直接按照字段值的顺序去获取你需要的数据。</font><br> <font color="#FF0000" size="4">但是直接利用联合索引字段的顺序排序有一定的限制：就是你要么按照联合索引的字段升序查询，要么按照联合索引的字段降序查询</font>，有的升序有的降序的话，就不会再走联合索引了。</p> <p>如果都是升序排列，直接就从索引树里最小的开始读取一定的条数就可以了；如果都是降序排列，那就从索引树里最大的数据开始读取一定的条数就可以了。</p> <h2 id="在sql里进行分组的时候-如何才能使用索引"><a href="#在sql里进行分组的时候-如何才能使用索引" class="header-anchor">#</a> 在SQL里进行分组的时候，如何才能使用索引？</h2> <p>假设你的sql语句如下：<br>
select count(*) from table group by xx,似乎看起来你需要把所有的数据放到一个临时磁盘文件里还有加上部分内存，去搞一个分组，按照指定字段的值分成一组一组的，接着对每一组都执行一个聚合函数，这个性能是极差的，因为毕竟涉及到了大量的磁盘交互。</p> <p>因为在我们的索引树里默认都是按照指定的一些字段排序好的，其实字段相同的值都是在一起的，假设要走索引去执行分组后再聚合，那性能一定是比磁盘文件里自行要快很多了。<br> <strong>所以通常而言，对于group by后的字段，最好也是按照联合索引里最左侧的字段开始，按照顺序排列开来，这样的话，其实就可以完美应用索引来提取一组一组的数据，然后针对每一组的数据执行聚合函数就好了</strong>。<br> <img src="/docs/assets/img/page_index8.a8369efb.png" alt="group by和order by如何走联合索引" title="page_index8.png"><br> <img src="/docs/assets/img/page_index9.2794d53e.png" alt="group by和order by如何走联合索引" title="page_index9.png"></p> <h2 id="回表查询对性能的损害以及覆盖索引是什么"><a href="#回表查询对性能的损害以及覆盖索引是什么" class="header-anchor">#</a> 回表查询对性能的损害以及覆盖索引是什么？</h2> <p><img src="/docs/assets/img/page_index10.23fa0d62.png" alt="走联合索引还是全表扫描" title="page_index10.png"><br> <strong>覆盖索引</strong>：它不是一种索引，它是指基于索引查询的一种方式。<br>
意思是针对类似于select xx1,xx2,xx3 from table order by xx1,xx2,xx3这样的语句，你仅仅需要联合索引里的几个字段的值，那么其实只要扫描联合索引的索引树就可以了，不需要回表查询聚簇索引里的其他字段了。</p> <p>即使你真的要回表到聚簇索引，那你要尽可能的用limit、where之类的语句，限定一下回表到聚簇索引的次数，从联合索引里筛选少量数据，这样回表的次数也会减少，进而提升性能。</p> <h2 id="设计索引的时候-我们一般要考虑哪些因素呢"><a href="#设计索引的时候-我们一般要考虑哪些因素呢" class="header-anchor">#</a> 设计索引的时候，我们一般要考虑哪些因素呢？</h2> <p><img src="/docs/assets/img/design_index1.ad52ff44.png" alt="电商平台表设计" title="design_index1.png"></p> <p>设计好表结构之后，接下来要做的就是设计表的索引，这个设计索引的时候，我们要考虑的第一点，就是未来我们对表进行查询的时候，大概会如何进行查询？</p> <p>如果不知道没关系，在我们系统开发完，功能都跑通后，此时我们已经写完所有的SQL，这个时候稳定知道对表发起了什么样的查询语句了吧？</p> <p><font color="#FF0000" size="4">第一个索引设计原则：</font>针对你sql语句里的where、order by条件以及group by条件去设计索引。<br> <img src="/docs/assets/img/design_index2.240123c4.png" alt="电商平台表设计" title="design_index2.png"></p> <p>在设计索引的时候还得考虑其他因素，首先一个就是<font color="#FF0000" size="4">字段基数问题，</font> 举个例子，假设有10万行数据，但是字段A只有两个值，要么是0，要么是1，那么它的基数就是2。<br>
假设你要针对上面说的这种字段建立索引的话，还不如走全表扫描，因为你的索引数据仅仅包含了0和1两种值，根本没法进行快速的二分查找，所以这个时候选这种基数很低的字段建立索引意义就不大了。</p> <p><font color="#FF0000" size="4">第二个索引设计原则：</font><strong>一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，那样才能发挥出B+树二分查找的优势来</strong>。</p> <p><font color="#FF0000" size="4">第三个索引设计原则：</font>尽量对那些<strong>字段类型比较小的列来设计索引</strong>，因为字段类型小的话，占用的磁盘空间也小，此时你搜索时，性能也会好一些。</p> <p><strong>前缀索引（<font color="#FF0000" size="4">第四个索引设计原则</font>）</strong>：<br> <img src="/docs/assets/img/design_index3.575bccf7.png" alt="前缀索引设计" title="design_index3.png"><br> <font color="#FF0000" size="4">第五个索引设计原则：</font>不要在索引列上嵌套函数。<br>
比如where function(a)=xx,这种是不会走索引的。</p> <p>你不停的增删改数据，就会不停的更新你的索引树。<br>
因为你插入的数据值可能不是按照顺序来的，很可能会导致索引树里的某个页会自动分裂，这个页分裂的过程就很耗费时间，<strong>因此一般让大家设计索引别太多，建议两三个联合索引就应该覆盖掉你这个表的全部查询了</strong>。</p> <p>否则索引太多，必然会导致你增删改的时候，要更新多个索引树。</p> <p><font color="#FF0000" size="4">另外关键一点，建议大家主键一定是自增的，别用UUID之类的</font>，因为主键自增，那么起码你的聚簇索引不会频繁的分裂，主键值都是有序的，就会自然的新增一个页而已，但是如果你使用的是UUID，那么会导致聚簇索引频繁的页分裂。</p> <h2 id="案例实战-陌生人社交app的mysql索引设计实战"><a href="#案例实战-陌生人社交app的mysql索引设计实战" class="header-anchor">#</a> 案例实战：陌生人社交APP的MySQL索引设计实战</h2> <p>我们通过一些条件去筛选一些好友，社交app，筛选的话一般是针对用户表进行筛选，假设用户表叫user_info.<br> <img src="/docs/assets/img/momo1.a70e045f.png" alt="陌生人用户表的信息" title="momo1.png"></p> <p>针对这个用户表进行搜索，科不仅仅是筛选那么简单，除了where条件，你肯定得<strong>支持分页</strong>吧，还有一点你稳定不是随便胡乱排序的吧，总得根据一定的规则对筛选出来的结果进行一个排序，把最符合你的期望的用户排在最上面，各位想想是不是？</p> <p>那么你的sql会类似这样：select xx from user_info where xx=xxx order by xx limit 1,10  。<br>
这样会出现一个难题，根据使用索引的规则，where条件语句必须是使用联合索引里最左侧开始的连续多个字段进行筛选，然后排序的时候也必须使用联合索引里最左侧开始的连续多个字段进行筛选。</p> <p>那问题就来了，假设你的sql需要按照年龄范围进行筛选，同时按照用户的评分进行排序，类似下面select xx from user_info where age between 20 and 25 order byscore，那就有问题了。</p> <p><strong>针对这个场景，你要明白的一个问题就是，往往类似这种SQL里，你的where条件和order by实际上大部分情况下是没法用到索引的</strong>！</p> <p><font color="#0000FF" size="4">根据前面的场景可知，在where和order by出现索引设计冲突，鱼与熊掌不可兼得的时候，到底是针对where去设计索引，还是针对order by去设计索引？</font></p> <p>一般这个时候往往是让where条件去使用索引来快速筛选出少部分数据，接着在进行排序，这样代价要小很多。</p> <p>确定根据where语句设计索引的时候，又犯难了，你要考虑用户在搜索潜在好友的时候，<strong>一般会用上哪些条件呢？我们要把哪些字段包含到联合索引里，这些字段按照上面顺序排列呢</strong>？</p> <p>我们首先要在联合索引里包含三个字段，省份、城市、性别。</p> <p>因为你搜索潜在好友，必定会搜索跟你在同一个地方的，然后搜索某个性别的其他用户。</p> <p>之前不是说过，基数太低的字段最好别放到索引中去，那省份、城市、性别都是基数非常小的几个字段，可选的值就那么几个，为什么要放到索引里去？</p> <p>规则是死的，但是人是活的。<br>
你想想，假设你就因为省份、城市、性别几个字段的基数太小了，此时<strong>不把他们几个包含到联合索引里去</strong>，那么你实际查询的时候都要基于这几个字段去搜索，此时你只能<strong>把这几个条件放到where语句的最后</strong>，那么每次查询都必须要先用联合索引查询出来一部分数据，接着加载到内存中去，然后再根据省份、城市、性别几个字段记性筛选，每次查询都得经过这么一个步骤，是不是很麻烦。</p> <p>所以与其如此，还不如把省份、城市、性别三个字段放在联合索引的最左侧，这样跟其他字段组成联合索引后，让大部分的查询都可以直接通过索引树就可以把where条件指定的数据筛选出来了。</p> <p>从前面可知，联合索引中已经确定了三个字段(province，city，sex)，因为他们三个是几乎每次查询都会用到的条件，使用频率高，先把他们放入联合索引的左侧，然后接着分析这个联合索引还需要放哪些字段？</p> <p>假设我们查询的时候不指定性别，而是指定了省份、城市，还加了一个年龄，也就是where province=xx and city=xx and age between 10 and 30，那此时怎么办呢，age不在索引里，age这块不会走索引。</p> <p>那如果把索引设计成（province，city，sex，age），此时你的语句写成where province=xx and city=xx and age between 10 and 30，也是没法让age用上索引，因为中间隔了个sex，所以此时是不符合<strong>最左侧连续多个字段的原则</strong>了。</p> <p><em>其实针对这个问题，完全不用担心，因为不限定性别，我们把语句写成where province=xx and city=xx and sex in('femail','mail') and age between 10 and 30，这样的话，就匹配最左连续多个字段的原则了。</em></p> <p>假设我们的查询语句里还有一些频繁使用的条件，通常都是兴趣爱好和性格特点，他们往往都有一些固定的枚举值。<br>
比如兴趣爱好可以有下面的可选值：运动、电影、旅游、烹饪，性格特点可以有：温柔、霸气、御姐、体贴、善良。</p> <p><font color="#0000FF" size="4">那么针对这样一些频繁使用的包含枚举值范围的一些字段，也完全可以加入到联合索引里去。</font>可以设计成（province，city，sex，hobby，character，age），假设有这么一个查询，按照省份、城市、性格和年龄进行搜索，此时SQL怎么写？</p> <p>还是按照之前的策略和思路：写成where province=xx and city=xx and sex in(xx,xx) and hobby in (xx,xx,xxx,xx,xx) and character in(xx,xx,xxx) and age between 10 and 30</p> <p><strong>也就是说即使你不需要按性别和爱好进行筛选，但是在SQL语句里你可以对这两个字段用in语句，把他们所有的枚举值都放进去。这样的话，就可以顺利的让province、city、character和age四个真正需要筛选的字段用上索引</strong>。</p> <p><font color="#FF0000" size="4">那么为什么一直强调age字段必须放到联合索引的最后一个呢？</font></p> <p>很简单，前面讲索引规则的时候说过，<strong>假设你where语句里有等值匹配，还有范围匹配，此时必须先让联合索引最左侧开始的多个字段使用等值匹配，接着最后一个字段是范围匹配</strong>。<br>
比如上面的语句：where province=xx and city=xx and sex in(xx,xx) and hobby in (xx,xx,xxx,xx,xx) and character in(xx,xx,xxx) and age between 10 and 30，完全是按照联合索引最左侧开始的连续四个字段（province、city、sex、hobby）进行等值匹配查询，然后最后一个字段使用的是范围匹配，这种就可以完全使用上面的索引。</p> <p>但是假设你要把age放在联合索引的中间位置，比如（province，city，sex，age，hobby，character），接着SQL写成where province=xx and city=xx and sex in(xx,xx) and age between 10 and 30 and hobby in (xx,xx,xxx,xx,xx) and character in(xx,xx,xxx) 的话，那么不好意思，只有province，city，sex，age几个字段可以使用上索引。</p> <p><font color="#FF0000" size="4">因为在SQL里，一旦你的一个字段做范围查询用到了索引，那么这个字段接下来的条件都不能使用索引了，这就是规则。<br>
所以说，实际设计索引的时候，必须把经常做范围查询的字段放在联合索引的最后一个，才能保证你的SQL里每个字段都能基于索引去查询。</font></p> <p>假设查询时还有一个条件，要根据用户登录时间在7天内来进行筛选，筛选最近7天登录过app的用户，表里有一个字段：latest_login_time.</p> <p>你要是在where条件里加上latest_login_time&lt;7天的语句，这个肯定是没法用上索引了。因为此处必定会用上一些计算或者函数，才能进行一些时间上的比对。</p> <p>而且假设你的查询里还有age进行范围查询，那么前面说过，范围查询的时候，也就只有第一个范围查询可以使用上索引，第一个范围查询之后的其他范围查询是用不上索引的。</p> <p>也就是说，即使你的索引设计成（province，city，sex，hobby，character，age，latest_login_time），然后你的where语句写成where xx xxx and age&gt;=xx and age&lt;=xxx and latest_login_time&gt;=xx,虽然age和latest_login_time都在联合索引里，但是按照规则，只有age范围查询可以用到索引，lastest_login_time是始终用不到索引的。</p> <p><font color="#FF0000" size="4">所以在设计表的时候，你就要考虑这个问题，此时你完全可以设计一个字段为：does_login_in_7_days,也就是说这个人7天内是否登陆过app。<br>
假设7天内登陆过app，这个值就是1，没有登陆过，就是0！这样就把一个时间字段转换为了一个枚举值的字段。</font></p> <p>接下来设计方案就简单了，可以设计这样一个联合索引（province，city，sex，hobby，character，does_login_in_7_days,age）,然后搜索的时候where语句里带上does_login_in_7_days=1即可，最后再跟上age范围查询，这样就可以让where语句里的字段都走索引来筛选。</p> <p>但有时候又怕另外一个问题，就是说万一你仅仅用联合索引里一些基数特别小的字段来筛选呢？</p> <p>比如说你要基于性别来筛选，筛选出所有的女性，可能会有上百万的数据，接着还要再磁盘中进行分页再排序？那会导致性能非常差。</p> <p>所以针对上述问题，可以针对那种基数很低的字段再加上排序字段单独额外设计一个辅助索引，专门用于解决where条件里都是基数很低的字段，然后还要排序后分页的问题，比如说可以设计一个联合索引：（sex,score）</p> <p>此时万一你写出如下sql：select xx from user_info where sex='femail' order by score limit xx and xxx,假设还用以前的那个联合索引，那就完蛋了，没法使用，不满足最左侧连续字段原则。</p> <p>但是使用我们设计的辅助索引（sex,score）呢？</p> <p>此时因为where条件里的字段是等值匹配，而且还是等于某个常量值，所以虽然order by后跟的score字段是（sex，score）索引里的第二个字段，没有从索引最左侧字段排列，但是它也可以使用索引来排序。原因如下：</p> <p>它会先根据where条件里sex=‘femail’在索引树里筛选出这部分数据，你可以想一下，这部分数据实际在索引树里也是按顺序排列在一起的，因为在索引里，会先按照sex排序，然后再按照score排序，所以可以想象，sex=‘femail’的数据都是在一块的。</p> <p>这部分字段本身就是按照score排序的，直接按照顺序取就对了，取的条数按照limit指定的数字就可以。</p> <p><strong>本章核心就是：尽量利用一两个复杂的多字段联合索引，抗下你80%以上的查询，然后利用一两个辅助索引抗下那20%的非典型查询，保证你90%以上的查询都能充分利用索引，就能保证你的查询速度和性能</strong></p> <h2 id="sql语句的执行计划和性能优化有什么关系"><a href="#sql语句的执行计划和性能优化有什么关系" class="header-anchor">#</a> SQL语句的执行计划和性能优化有什么关系</h2> <p>根据查询语句设计良好的索引，让所有的查询尽可能的都用上索引，这本身就是SQL优化的一个技巧，并不是说掌握了这个就掌握了所有的SQL优化技巧。这仅仅是其中的一个技巧罢了。</p> <p>实际上有时候往往你会发现数据库里有很多表，每个表的数据量也不小，然后写出来的SQL也比较复杂，各种关联和嵌套子查询，看得人眼晕，然后表面看起来这个SQL部分用上了索引，但是性能还是很差，这是为什么呢？</p> <p>针对复杂表结构和大数据量的上百行复杂SQL的优化，必须得建立在你先懂得这个复杂SQL是怎么执行的。</p> <p>这个SQL语句（不管简单还是复杂），在实际的MySQL底层，针对磁盘上的大量数据表、聚簇索引和二级索引，如何检索查询，如何筛选过滤，如何使用函数，如何进行排序，如何进行分组，到底怎么能把你想要的东西查出来，这个过程就是：<strong>执行计划</strong>！</p> <p><font color="#FF0000" size="4">也就是说，每次你提交一个SQL到MySQL，他内核里的查询优化器，都会针对这个SQL语句的语义去生成一个执行计划，这个执行计划就代表了，它会怎么查各个表，用哪些索引，如何做排序和分组，看懂了这个执行计划，你就学会了真正SQL优化的一半了。</font></p> <p><font color="#FF0000" size="4">当你看懂执行计划后，还能根据它的实际情况去想各种办法改写你的SQL语句，改良你的索引设计，进而优化SQL语句的执行计划，最终让SQL的性能得到提升，这个就是所谓的SQL调优。</font></p> <h2 id="以mysql单表查询来举例-看看执行计划包含哪些内容"><a href="#以mysql单表查询来举例-看看执行计划包含哪些内容" class="header-anchor">#</a> 以MySQL单表查询来举例，看看执行计划包含哪些内容</h2> <p>我们之前都知道，假设你写一个select * from table where id=xx，或者select * from table where name=xx的语句，直接可以通过聚簇索引或者二级索引+聚簇索引回表，轻松查到你想要的数据，<strong>这种根据索引快速查找数据的过程，在执行计划里称之为<font color="#FF0000" size="5">const</font>，意思是性能很高的常量级的</strong>。</p> <p>所以你以后再执行计划里看到const的时候，就知道他是直接通过索引定位到数据，速度极快，这就是const的意思。</p> <p><strong>但是这里有一个要点，你的二级索引必须是唯一的，才是属于const方式的，也就是说你必须建立unique key唯一索引，保证一个二级索引的每一个值都是唯一的，才可以</strong>。</p> <p>那么你是一个普通的二级索引呢？就是普通的key索引，这个时候如果写一个select * from table where name=xx的语句，name是个普通的二级索引，不是唯一索引，那么此时这种查询速度也是很快的，他在执行计划里叫做<font color="#FF0000" size="5">ref</font>。</p> <p><img src="/docs/assets/img/const_ref1.513a5eb2.png" alt="执行计划中的const和ref" title="const_ref1.png"></p> <p><strong>我们换个角度来看，假设我们以后在分析执行计划的时候看到了const，那是什么？对，肯定是通过主键或者唯一索引的访问，速度超高</strong>。</p> <p><strong>如果你看到了ref是什么意思？对，就是用了普通索引，或者用主键/唯一索引搞了一个IS NULL/IS NOT NULL</strong></p> <p>执行计划里的<font color="#FF0000" size="5">range</font>，顾名思义，就是说你SQL有范围查询的时候就会走这个方式。</p> <p>比如你写了sql，select * from table where age&gt;=x and age&lt;=x,假设age就是一个普通索引，此时就必然会利用索引来进行范围查询，一旦利用索引做了范围筛选，那么这种方式就是range。</p> <p><font color="#FF0000" size="4">假设我们有一个表，联合索引是KEY（x1，x2，x3），我们写的sql语句是：select x1，x2，x3 from table where x2=xx，</font>相信很多人看到这里就觉得完蛋了，x2不是联合索引最左侧的字段，不会走索引！</p> <p>对，这个sql确实没办法直接从联合索引的索引树的根节点开始进行二分查找，快速一层一层跳转的，那么他会怎么执行呢？不知道大家有没有发现，这个sql里要查的几个字段，就是联合索引里的几个字段，巧了。</p> <p>所以针对这种sql，在实际查询的时候，就会直接遍历KEY（x1，x2，x3）这个联合索引的索引树的叶子节点，因为联合索引的叶子节点存放的也是页，但是页里每一行都是x1，x2，x3和主键的值。</p> <p><strong>所以针对这个sql，会直接遍历KEY（x1，x2，x3）索引树的叶子节点的那些页，一个接一个的遍历，然后找到x2=xx的那个数据，就把里面的x1，x2，x3三个字段的值直接提取出来就可以了</strong>！这个遍历二级索引的过程，要比遍历聚簇索引要快多了，毕竟二级索引的叶子节点只包含几个字段的值，比聚簇索引叶子节点小多了，所以速度也快多了。</p> <p>也就是说只要遍历一个KEY（x1，x2，x3）索引就可以了，不需要回源到聚簇索引里去！<strong>针对这种只要遍历二级索引就可以拿到你想要的数据，而不需要回源到聚簇索引的访问方式，叫做<font color="#FF0000" size="5">index</font>访问方式</strong>！</p> <p><strong>总结</strong>：之前说的const、ref、range，本质都是基于索引树的二分查找和多层跳转来查询，所以性能都是很高的。然后index查询方式，速度比上面三种要差一些，因为它是走遍历二级索引树的叶子节点的方式来执行的，那肯定是比基于索引树的二分查找要慢多了，但是比全表扫描要好很多。</p> <p>执行计划里最次的一种就是<font color="#FF0000" size="5">all</font>，all的意思是直接全表扫描，扫描你的聚簇索引的所有叶子节点，也就是一个表里一行一行的去扫描，如果表里只有几百条数据还好，如果有几万，几百万的数据，那全表扫描就得跪了！</p> <p><font color="#FF0000" size="5">***************************************************************************</font>
下面开始分析具体的sql，会走什么样的执行计划。</p> <p>首先大家看一个sql语句：select * from table where x1=xx and x2&gt;=xxx，此时可能有人会说，对x1和x2建立一个联合索引，那不就可以通过索引去扫描了？<br>
但是万一你建的索引是两个呢？比如（x1，x3），（x2，x4），此时你这个sql只能选择其中一个索引去使用，此时会选择哪个呢？<strong>MySQL负责生成执行计划的查询优化器，一般会选择在索引里扫描行数比较少的那个条件</strong>。</p> <p>比如说x1=xx，在索引里只要做等值比较，扫描数据比较少，那么就可能会挑选x1的索引，做一个索引的查找，在执行计划里，其实就是一个ref的方式，找到数据后，接着做一个回表，回到聚簇索引里找出完整的数据，接着加载到内存里，根据x2的值，做一个x2&gt;=xx的筛选即可。</p> <p>这就是面对两个字段都能用索引的时候如何选择，以及如何进行处理的方式。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>接下来我没再考虑另外一种情况，就是：select * from table where x1=xx and c1=xxx and c2&gt;=xxx and c3 IS NOT NULL</p> <p>其实我们平时经常会写出类似这样的SQL语句，就是这个SQL的筛选语句里，就一个x1是有索引的，其他字段都是没有索引的。</p> <p>所以这种情况，必然很多SQL语句里，可能where后的条件有好几个，<strong>结果就一个字段可以用到索引</strong>，此时查询优化器生成的执行计划，就会仅仅针对x1字段走一个ref访问，直接通过x1字段的索引树快速定位到一波数据。</p> <p><strong>接着根据这波数据对应的主键值，回表，回到聚簇索引中查询完整的数据行，然后都加载到内存中去。接着就可以针对这些数据的c1、c2和c3条件过滤，最后拿到的就是符合条件的数据了</strong>。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>一般一个sql只能用到一个二级索引，但是有些sql可能会用到多个二级索引，这是怎么回事呢？</p> <p><strong>比如有这么一个sql：select * from table where x1=xx and x2=xx,然后x1和x2分别各有一个索引，其实也有一定的可能让查询优化器生成一个执行计划，执行计划里，先对x1的索引树查找，查出一波数据，接着对x2的索引树，查出一波数据，然后对两拨数据，按照主键值做一个交集</strong>。</p> <p>这个交集就是符合两个条件的数据了，接着回表到聚簇索引去查完整的数据就可以了。</p> <p>但是其实之前我们对这种情况一直说的是，选择x1或x2其中一个字段走索引，找出数据后，再回表到聚簇索引里查出完整的数据，再根据另外一个字段的值进行过滤就行了。</p> <p><img src="/docs/assets/img/union_index2.c93f2da0.png" alt="走多个二级索引的情况" title="union_index2.png"><br> <img src="/docs/assets/img/union_index3.3da91a6f.png" alt="走多个二级索引的情况" title="union_index3.png"></p> <p><font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p>如果你在SQL里写了类似x1=xx or x2=xx的语句，也可能会用多个索引，只不过查多个大索引树之后，会取一个并集。<br> <img src="/docs/assets/img/union_index4.64b89e18.png" alt="走多个二级索引的情况" title="union_index4.png"></p> <h2 id="深入探索多表关联的sql语句到底是如何执行的"><a href="#深入探索多表关联的sql语句到底是如何执行的" class="header-anchor">#</a> 深入探索多表关联的SQL语句到底是如何执行的？</h2> <p>假设我们有个sql语句：select * from t1,t2 where t1.x1=xx and t1.x2=t2.x2 and t2.x3=xxx</p> <p>其实这个sql的执行过程可能是这样的，首先根据x1=xx这个筛选条件，去t1表里查出一批数据，此时可能是const或者ref，也可能是index或者all，都有可能，具体看你的索引是如何建的，他会挑选一种执行计划访问方式。</p> <p>然后假设从t1表里按照t1.x1=xxx条件筛选出两条数据，接着对这两条数据，根据每条数据的x2字段的值，以及t2.x3=xxx这个条件，去t2表里查找x2字段值和x3字段值都匹配的数据，比如说t1表第一条数据的x2字段的值是265，此时就可以根据t2.x2=265和x3=xxx这两个条件，来找出一波数据，比如找出2条吧。</p> <p>此时就把t1表里x2=265的那条数据跟t2表里t2.x2=265 和 t2.x3=xxx的两条数据，关联起来就可以了，t1表里的另外一条数据也是如法炮制而已，这就是<strong>多表关联最最基础的原理</strong>。<br> <font color="#FF0000" size="5">---------------------------------------------------------------------------</font></p> <p><strong>嵌套循环关联（nested-loop join）</strong>,它其实就是前面我们给大家讲的最初的关联执行原理。</p> <p>简单来说，假设有两个表要一起执行关联，此时会现在一个<strong>驱动表</strong>(关联表中左侧的表) 里根据它的where筛选条件找出一波数据，比如说10条吧。<br>
接着就对着10条数据走一个循环，用每条数据都到另外一个<strong>被驱动表</strong>（关联表中右侧的表）去根据ON连接条件和WHERE里的被驱动表筛选条件去查找数据，找出的数据就进行关联。</p> <p>依次类推，驱动表有10条数据，那么就要到被驱动表里去查询10次。</p> <p>那么如果是3个表进行关联呢？那就更夸张了，你从表1里查出10条数据，接着去表2查10次，假设每次都查出3条数据，然后关联起来，此时你会得到一个30条数据的结果集，接着再去表3里继续查询30次。相当于进行了3次for循环，效率不低才怪呢。</p> <p>所以有时候为什么多表关联很慢呢？原因就是两个表都没有走索引。<br>
所以通常而言，<strong>针对多表查询的语句，我们要尽量给两个表都加上索引</strong>，<strong>索引要确保从驱动表里查询是通过索引的方式，接着对被动表的查询也是通过索引去查找</strong>。这样多表关联查询的效率才会很高。</p> <h2 id="mysql是如何根据成本优化选择执行计划的"><a href="#mysql是如何根据成本优化选择执行计划的" class="header-anchor">#</a> MySQL是如何根据成本优化选择执行计划的？</h2> <p>无论我们是执行单表查询还是多表关联查询，似乎都有多种执行计划可以选择，比如有的表可以全表扫描，也可以用索引A，也可以用索引B，那么到底用哪种执行计划呢？</p> <p><strong>MySQL是如何对一个查询语句的多个执行计划评估它的成本的？如果根据成本评估选择一个成本最低的执行计划，保证最佳的查询速度</strong>   ？<br> <img src="/docs/assets/img/explain1.677d2995.png" alt="执行计划的成本" title="explain1.png"></p> <p>假设有如下sql语句：select * from table where x1=xx and x2=xx,此时你有两个索引，分别是针对x1和x2建立的MySQL就会先看看这个sql可以用到哪几个索引，此时发现x1和x2的索引都能用到，他们两个的索引就是<strong>possible keys</strong>。</p> <p><font color="#FF0000" size="4">接着会针对这个sql计算一下全表扫描的成本，这个全表扫描就比较坑了，因为他需要先磁盘IO把聚簇索引里的叶子节点上的数据页一页一页都读到内存里，有多少数据页就得耗费多少IO成本，接着对内存里的每条数据都判断是否符合条件，这有多少条数据，就得耗费多少CPU成本。</font></p> <p>怎么上述的成本呢，需要一个命令：<br> <font color="#FF0000" size="5">show table status like '表名'</font><br>
这个命令可以拿到表的统计信息，你在对表进行增删改的时候，MySQL会帮你维护这个表的一些统计信息，比如可以看到<font color="#FF0000" size="5">rows和data_length</font>两个信息，不过对于innodb来说，rows是估计值。</p> <p>rows就是表里的记录数，data_length就是表的聚簇索引的字节数大小，数据页数量=data_length/1024/16，因为data_length/1024可以得到kb，一个数据页大小是16kb，再除以16,就可以得到数据页的个数了。</p> <p><font color="#0000FF" size="4">IO的成本就是：数据页数量<em>1.0+微调值，CPU成本就是：行记录数</em>0.2+微调值，他们两个相加，就是总的成本值。</font><br>
比如你有数据页100个，记录数2万个，此时总成本大致就是：100<em>1+20000</em>0.2=4100</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/mysql.html" class="prev">
        MySQL章节1
      </a></span> <span class="next"><a href="/docs/thread.html">
        多线程知识
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.92b3039a.js" defer></script><script src="/docs/assets/js/5.4f0d6612.js" defer></script><script src="/docs/assets/js/3.27366f81.js" defer></script>
  </body>
</html>
