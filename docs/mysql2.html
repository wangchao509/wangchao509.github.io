<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL章节2 | whc的学习笔记</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="主要是java技术类笔记">
    
    <link rel="preload" href="/docs/assets/css/0.styles.a889b764.css" as="style"><link rel="preload" href="/docs/assets/js/app.fc28f30e.js" as="script"><link rel="preload" href="/docs/assets/js/3.2d99bf22.js" as="script"><link rel="preload" href="/docs/assets/js/5.61759597.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.a040fdcc.js"><link rel="prefetch" href="/docs/assets/js/11.3db4bb60.js"><link rel="prefetch" href="/docs/assets/js/12.5e3e29ec.js"><link rel="prefetch" href="/docs/assets/js/2.1da3447e.js"><link rel="prefetch" href="/docs/assets/js/4.65d204eb.js"><link rel="prefetch" href="/docs/assets/js/6.7e231f6c.js"><link rel="prefetch" href="/docs/assets/js/7.2ae0f9b7.js"><link rel="prefetch" href="/docs/assets/js/8.309b3b65.js"><link rel="prefetch" href="/docs/assets/js/9.a42d928f.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.a889b764.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">whc的学习笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/docs/" aria-current="page" class="sidebar-link">站点介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>markdown知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/markdown.html" class="sidebar-link">前端知识介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>MySQL知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/mysql0.html" class="sidebar-link">MySQL章节0</a></li><li><a href="/docs/mysql.html" class="sidebar-link">MySQL章节1</a></li><li><a href="/docs/mysql2.html" aria-current="page" class="active sidebar-link">MySQL章节2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/mysql2.html#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="sidebar-link">MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#多个事务更新同一行数据时-是如何加锁避免脏写的" class="sidebar-link">多个事务更新同一行数据时，是如何加锁避免脏写的？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#共享锁和独占锁到底是什么" class="sidebar-link">共享锁和独占锁到底是什么？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#哪些操作会导致在表级别加锁呢" class="sidebar-link">哪些操作会导致在表级别加锁呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="sidebar-link">表锁和行锁互相之间的关系以及互斥规则是什么呢？</a></li><li class="sidebar-sub-header"><a href="/docs/mysql2.html#线上数据库不确定性的性能抖动优化实践" class="sidebar-link">线上数据库不确定性的性能抖动优化实践**</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JAVA知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/thread.html" class="sidebar-link">多线程知识</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql章节2"><a href="#mysql章节2" class="header-anchor">#</a> MySQL章节2</h1> <h2 id="mysql最牛的rr隔离级别-是如何基于readview机制实现的"><a href="#mysql最牛的rr隔离级别-是如何基于readview机制实现的" class="header-anchor">#</a> MySQL最牛的RR隔离级别，是如何基于ReadView机制实现的？</h2> <h3 id="rr级别下如何解决不可重复读问题的"><a href="#rr级别下如何解决不可重复读问题的" class="header-anchor">#</a> RR级别下如何解决不可重复读问题的</h3> <p>RR(可重复读)级别下，你这个事务读取一条数据，无论读多少次，都是一个值，别的事务哪怕修改数据之后提交了事务，你也是看不到人家修改的值的。这就避免了不可重复读的问题。别的事务插入一条数据，你也是看不到的，这就避免了幻读的问题。</p> <p>那到底是如何实现的呢？<br> <strong>核心地方在于RR隔离级别下，每次查询都是同一个ReadView</strong>
首先，我们还是假设数据库里有一条数据，这个数据是事务id=50的插入的。此时有事务A（id=60）和事务B（id=70）在同时运行，如下图所示：
<img src="/docs/assets/img/repeatable_committed1.d7e3decb.png" alt="可重复读与ReadView" title="repeatable_committed1.png"></p> <p>接着事务A发起了一次查询，因为是第一次查询，所以生成了ReadView，此时min_trx_id=60，max_trx_id=71,creator_trx_id=60,m_ids=[60,70],此时如下图：
<img src="/docs/assets/img/repeatable_committed2.91d36dfa.png" alt="可重复读与ReadView" title="repeatable_committed2.png"></p> <p>这个时候事务A基于这个ReadView去查询数据，此时trx_id=50，是小于min_trx_id=60，说它发起事务之前就已经有事务修改了数据并提交了事务，所以可以查到这条数据的原始值。如下图所示：
<img src="/docs/assets/img/repeatable_committed3.f04afef5.png" alt="可重复读与ReadView" title="repeatable_committed3.png"></p> <p>接着事务B就更新了这行数据的值为B，此时会把trx_id修改为70，同时会生成undo log，关键是事务B提交了，也就是说此时事务B已经结束了，如下图：
<img src="/docs/assets/img/repeatable_committed4.8e5343ba.png" alt="可重复读与ReadView" title="repeatable_committed4.png"></p> <p>这个时候大家思考一个问题，ReadView中的m_ids还是[60,70]吗？</p> <p>那必然是的，因为ReadView一旦生成了就不会改变了，这个时候事务B虽然已经结束了，但是事务A的ReadView里m_ids还是[60,70]。<br>
它的意思是事务A开启的时候，事务B当时是在运行的。</p> <p>那么此时事务A去查询这条数据的值，他会惊讶的发现此时数据的trx_id=70,70在min_trx_id和max_trx_id之间，同时还在m_ids=[60,70]列表中。<br>
这说明事务A开启查询的时候，id=70的事务B还是在运行的，然后事务B更新了这条数据，所以此时事务A是不能查询到事务B更新的值，因此此时会顺着undo log版本链条往下找，如下图所示：
<img src="/docs/assets/img/repeatable_committed5.dc738b79.png" alt="可重复读与ReadView" title="repeatable_committed5.png"><br>
事务A顺着roll_pointer找最近的undo log，发现最近的undo log的trx_id=50,它是小于min_trx_id=60的，说明它是在事务A开启之前就已经提交这个事务了，所以事务A是可以查询到这个值的，此时事务A查到的是原始值。<br> <img src="/docs/assets/img/repeatable_committed6.2caa39b4.png" alt="可重复读与ReadView" title="repeatable_committed6.png"></p> <p>可以看到两次查询查到的结果是一样的，都是原始值。不管别的事务如何修改数据，事务A的ReadView始终是不变的，基于这个ReadView看到的值始终是一样的。</p> <h3 id="rr级别下如何解决幻读问题的"><a href="#rr级别下如何解决幻读问题的" class="header-anchor">#</a> RR级别下如何解决幻读问题的</h3> <p><img src="/docs/assets/img/repeatable_committed7.244d09a1.png" alt="可重复读与ReadView" title="repeatable_committed7.png"><br> <img src="/docs/assets/img/repeatable_committed8.3e7049dd.png" alt="可重复读与ReadView" title="repeatable_committed8.png"></p> <p>MVCC是Multi-Version concurrent control,就是多版本并发控制机制。专门控制多个事务并发运行的时候，互相之间会如何影响。<br>
MySQL实现MVCC机制的时候，是基于<strong>undo log多版本链条+ReadView</strong>机制来做的，默认的RR隔离级别就是基于这套机制实现的。</p> <h2 id="多个事务更新同一行数据时-是如何加锁避免脏写的"><a href="#多个事务更新同一行数据时-是如何加锁避免脏写的" class="header-anchor">#</a> 多个事务更新同一行数据时，是如何加锁避免脏写的？</h2> <p>靠锁机制，依靠锁机制让多个事务更新同一行数据的时候串行化，避免同时更新一条数据。</p> <p>假设MySQL里有一行数据，此时来了一个事务要更新它，更新之前需要先检查这行数据有没有锁，如果没有锁，这个事务就会创建一个锁，里面包含了自己的trx_id和等待状态，然后把锁跟这行数据关联在一起。</p> <p><img src="/docs/assets/img/synchronized1.4d94aafe.png" alt="加锁避免脏写" title="synchronized1.png"></p> <p><strong>注意看上图，因为事务A已经给那行数据加了锁，所以此时就可以说那行数据已经被加锁了。</strong><br> <strong>此时另外一个事务B过来了，它也想更新那行数据，更新前先检查这行数据有没有锁，如果已经有锁，B也给这行数据加个锁，然后排队等着。这个时候事务B也生成了一个锁数据结构，里面有它的trx_id和等待状态，但是因为它是排队等待，所以它的等待状态是true</strong>。如下图所示：
<img src="/docs/assets/img/synchronized2.0e179d60.png" alt="加锁避免脏写" title="synchronized2.png"></p> <p>接着事务A更新完数据就把锁给释放了。锁一旦释放了，他就会去找，此时还有没有别人也对这行数据加锁了呢？他就会发现事务B也对该行数据加锁了，于是这个时候，就会把事务B的锁里的等待状态给修改为false，然后唤醒事务B继续执行，此时事务B就获取到锁了，如下图所示：
<img src="/docs/assets/img/synchronized3.2569590d.png" alt="加锁避免脏写" title="synchronized3.png"></p> <h2 id="共享锁和独占锁到底是什么"><a href="#共享锁和独占锁到底是什么" class="header-anchor">#</a> 共享锁和独占锁到底是什么？</h2> <h3 id="独占锁"><a href="#独占锁" class="header-anchor">#</a> 独占锁</h3> <p>前面讲过，多个事务同时更新一行数据，此时都会加锁，然后都会排队等待，必须一个事务执行完了，提交了，释放了锁，才能唤醒别的事务继续执行。<br>
那么多个事务运行时加的是什么类型的锁呢？<br> <strong>其实是X锁，也就是Exclude独占锁</strong>，当有一个事务加了独占锁之后，此时其他事务再要更新这行数据，都是要加独占锁的，但是智能生成独占锁在后面等待。</p> <p>当有人在更新数据的时候，其他的事务可以读取这行数据吗？默认情况下，需要加锁吗？<br>
答案是：不需要。</p> <p>原因：因为默认情况下，有人在更新数据的时候，你要去读取这行数据，直接默认就是开启MVCC机制的。<br>
也就是说此时对一行数据的读和写两个操作，默认是不会加锁互斥的，因为MySQL设计MVCC机制就是为了解决这个问题的，避免频繁加锁互斥。<br> <font color="#0000FF" size="4">查询操作加互斥锁的方法： select * from table for update</font></p> <h3 id="共享锁"><a href="#共享锁" class="header-anchor">#</a> 共享锁</h3> <p>万一执行查询操作时，就是想要加锁呢？<br>
MySQL也是Ok的，他提供了一种共享锁，就是S锁。<br> <font color="#0000FF" size="4">共享锁的语法如下：select * from table lock in share mode   </font><br>
你在一个查询语句后面加上 lock in share mode，就表示查询时对这行数据加了共享锁。</p> <p><font color="FF0000" size="4">如果此时有别的事务在更新这行数据，已经加了独占锁了，此时你的共享锁还能加吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你这个查询就只能等着了。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人再来更新要加独占锁，行吗？</font><br>
当然不行，共享锁和独占锁是互斥的。此时你的更新只能等待。</p> <p><font color="FF0000" size="4">如果你先加了共享锁，别人也来加共享锁，行吗？</font><br>
可以，共享锁和共享锁不会互斥。<br> <img src="/docs/assets/img/share_or_exclude_lock.9039512f.png" alt="共享锁和互斥锁关系图" title="share_or_exclude_lock.png"></p> <h2 id="哪些操作会导致在表级别加锁呢"><a href="#哪些操作会导致在表级别加锁呢" class="header-anchor">#</a> 哪些操作会导致在表级别加锁呢？</h2> <p>在多个事务并发更新数据的时候，都是要在行级别加独占锁的，这就是行锁，独占锁都是互斥的，所以不可能发生脏写问题，一个事务提交了才会释放自己的独占锁，唤醒下一个事务执行。</p> <p>如果你此时去读取别的事务在更新的数据，有两种可能：</p> <p>第一种可能是基于mvcc机制进行事务隔离，读取快照版本，这是比较常见的；<br>
第二种可能是查询的同时基于特殊语法去加独占锁或者共享锁。</p> <p>太建议在数据库粒度去通过行锁实现复杂的业务锁机制，而更加建议通过redis、zookeeper来用分布式锁实现复杂业务下的锁机制，其实更为合适一些。</p> <p>为什么呢？因为如果你把分布式系统里的复杂业务的一些锁机制依托数据库查询的时候，在SQL语句里加共享锁或者独占锁，会导致这个加锁逻辑隐藏在SQL语句里，在你的Java业务系统层面其实是非常的不好维护的，所以一般是不建议这么做的。</p> <p><strong>比较正常的情况而言，其实还是多个事务并发运行更新一条数据，默认加独占锁互斥，同时其他事务读取基于mvcc机制进行快照版本读，实现事务隔离。</strong></p> <p>有些人可能会以为当你执行增删改的时候默认加行锁，然后执行DDL语句的时候，比如alter table之类的语句，会默认在表级别加表锁。这么说也不太正确，但是也有一定的道理，因为确实你执行DDL的时候，会阻塞所有增删改操作；执行增删改的时候，会阻塞DDL操作。</p> <p>但这是通过MySQL通用的<strong>元数据锁实现的，也就是Metadata Locks，但这还不是表锁的概念</strong>。因为<strong>表锁其实是InnoDB存储引擎的概念</strong>，InnoDB存储引擎提供了自己的表级锁，跟这里DDL语句用的元数据锁还不是一个概念。</p> <p>只不过DDL语句和增删改操作，确实是互斥的，大家要知道这一点。</p> <h2 id="表锁和行锁互相之间的关系以及互斥规则是什么呢"><a href="#表锁和行锁互相之间的关系以及互斥规则是什么呢" class="header-anchor">#</a> 表锁和行锁互相之间的关系以及互斥规则是什么呢？</h2> <p>MySQL的表锁其实非常鸡肋的东西，几乎不会有人用。表锁分为两种，一种是表锁，一种是表级的意向锁。</p> <p><font color="#0000FF" size="4">表锁加锁语法：<br>
LOCK TABLES XXX READ  这是加表级共享锁<br>
LOCK TABLES XXX WRITE 这是加表级独占锁<br></font></p> <p><font color="#0000FF" size="4">我们平时操作数据库，两种常见的表锁：<br>
更新时加的意向独占锁<br>
查询时加的意向共享锁  </font><br>
可以当这两种锁是透明的，因为意向独占锁和意向共享锁是不互斥的。<br> <img src="/docs/assets/img/table_lock.d40f61b5.png" alt="表锁" title="table_lock.png"><br> <img src="/docs/assets/img/lock_relation.c432bee4.png" alt="表锁关系" title="lock_relation.png"></p> <h2 id="线上数据库不确定性的性能抖动优化实践"><a href="#线上数据库不确定性的性能抖动优化实践" class="header-anchor">#</a> 线上数据库不确定性的性能抖动优化实践**</h2> <p>大家都知道，我们平时执行更新语句的时候，实际上都是从磁盘加载数据页到数据库内存的缓存页中，接着就直接更新内存里的缓存页，同时更新对应的redo log并写入一个buffer中，如下图所示：
<img src="/docs/assets/img/redo_log1.33a93a02.png" alt="redo log" title="redo_log1.png"></p> <p>既然我们更新了Buffer Pool里的缓存页，缓存页就变成了脏页，之所以说他是脏页，是因为缓存页里的数据目前跟磁盘文件里的数据页的数据是不一致的，所以此时的缓存页也叫作脏页。</p> <p><strong>既然是脏页就必然要有一个合适的时机把脏页给刷回磁盘文件，脏页刷回磁盘是通过LRU链表实现的，通过LRU链表，就可以知道哪些缓存页是最近经常被使用的。</strong></p> <p>如果后续你要加载磁盘里的数据页到Buffer Pool中去，但是此时并没有空闲的缓存页了，此时就必须把部分脏页给刷回磁盘，根据LRU链表找到最近最少被访问的缓存页刷回磁盘。</p> <p><img src="/docs/assets/img/redo_log2.d17eea1b.png" alt="redo log" title="redo_log2.png"></p> <p><font color="#FF0000" size="4">生产案例：假设你执行的查询语句，需要查询大量的数据到缓存页里去，此时可能会导致大量的脏页需要刷回磁盘，才能腾出足够的内存空间来执行这条查询语句。在这种情况下，可能你会发现，突然莫名其妙的执行某个查询语句慢了很多，平时只要几十毫秒的查询，这次花了几秒，因为你要等待大量脏页刷回磁盘，然后语句才能执行</font></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/docs/mysql.html" class="prev">
        MySQL章节1
      </a></span> <span class="next"><a href="/docs/thread.html">
        多线程知识
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.fc28f30e.js" defer></script><script src="/docs/assets/js/3.2d99bf22.js" defer></script><script src="/docs/assets/js/5.61759597.js" defer></script>
  </body>
</html>
